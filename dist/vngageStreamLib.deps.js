/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define("vngageStreamLib", [], factory);
	else if(typeof exports === 'object')
		exports["vngageStreamLib"] = factory();
	else
		root["vngageStreamLib"] = factory();
})(this, function() {
return /******/ (function() { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./src/StreamConnector.js":
/*!********************************!*\
  !*** ./src/StreamConnector.js ***!
  \********************************/
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__], __WEBPACK_AMD_DEFINE_RESULT__ = (function (require) {\n  'use strict';\n\n  var signalr = __webpack_require__(/*! @microsoft/signalr/dist/browser/signalr */ \"./node_modules/@microsoft/signalr/dist/browser/signalr.js\"),\n      StreamErrors = __webpack_require__(/*! ./StreamErrors */ \"./src/StreamErrors.js\"),\n      StreamUtils = __webpack_require__(/*! ./StreamUtils */ \"./src/StreamUtils.js\"),\n      StreamEventTypes = __webpack_require__(/*! ./StreamEventTypes */ \"./src/StreamEventTypes.js\");\n\n  var machina = null;\n  var reconnectRetryDelay = 3;\n  var resubscribeDelay = 1;\n  var reconnectMaxRetries = 60; // 60 = 3 minutes if reconnectRetryDelay == 3\n\n  var topicStartId = 1;\n\n  var noop = function noop() {};\n\n  var noDebug = {\n    log: noop,\n    warn: noop,\n    error: noop,\n    info: noop\n  };\n  var debug = noDebug;\n  var options = {\n    brokerUrl: null,\n    brokerTransport: 'WebSockets',\n    brokerLogLevel: 'none'\n  };\n  var brokerEventCallbacks = {};\n  var subscriptions = {};\n  var lastSubscribeInvocationId = 0;\n  var brokerConnection = null;\n\n  function initBrokerConnectionFsm(machina) {\n    /*******************************************************************************************\r\n     ** brokerConnection state machine\r\n     * Should probably be broken out from this module...\r\n     *******************************************************************************************/\n    brokerConnection = new machina.Fsm({\n      initialize: function initialize() {\n        this.connection = null;\n        this.reconnectCounter = 0;\n      },\n      initialState: 'disconnected',\n      states: {\n        disconnected: {\n          _onEnter: function _onEnter() {\n            debug.log('FSM: disconnected._onEnter()');\n            this.connection = null;\n          },\n          connect: function connect() {\n            this.transition('connecting');\n          }\n        },\n        connecting: {\n          _onEnter: function _onEnter() {\n            debug.log('FSM: connecting._onEnter()');\n\n            _connect();\n          },\n          connection_ok: function connection_ok(connection) {\n            this.connection = connection;\n            this.transition('connected');\n          },\n          connection_failed: function connection_failed(err) {\n            this.transition('disconnected');\n          },\n          disconnect: function disconnect() {\n            this.transition('disconnecting');\n          }\n        },\n        connected: {\n          _onEnter: function _onEnter() {\n            debug.log('FSM: connected._onEnter()');\n          },\n          connection_failed: function connection_failed() {\n            // Broker connection closed in \"connected\"-state - try to auto-reconnect to broker...\n            if (brokerEventCallbacks && typeof brokerEventCallbacks.onConnectionFailed === 'function') {\n              brokerEventCallbacks.onConnectionFailed('connection failed');\n            }\n\n            this.connection = null;\n            this.reconnectCounter = 0;\n            this.transition('reconnect_wait');\n          },\n          disconnect: function disconnect() {\n            this.transition('disconnecting');\n          }\n        },\n        reconnect_wait: {\n          _onEnter: function _onEnter() {\n            debug.log('FSM: reconnect_wait._onEnter()');\n\n            if (this.reconnectCounter < reconnectMaxRetries) {\n              this.handle('schedule_reconnect');\n            } else {\n              // i.e. don't try to reconnect even once if reconnectMaxRetries <= 0\n              this.handle('reconnection_failed');\n            }\n          },\n          schedule_reconnect: function schedule_reconnect() {\n            debug.log('FSM reconnect_wait.schedule_reconnect(): Reconnecting to broker in ' + reconnectRetryDelay + ' sec...');\n            clearTimeout(this.reconnectTimer); // Just make sure no other reconnects are already scheduled (should not happen, but maybe SignalR's connection.onclose() *could* be fired twice in that case we'd end up here twice before handling the 'reconnect'-action...)\n\n            this.reconnectTimer = setTimeout(function () {\n              this.handle('connect');\n            }.bind(this), reconnectRetryDelay * 1000);\n          },\n          connect: function connect() {\n            this.transition('reconnecting');\n          },\n          disconnect: function disconnect() {\n            this.transition('disconnecting');\n          },\n          reconnection_failed: function reconnection_failed() {\n            this.transition('disconnected');\n          },\n          _onExit: function _onExit() {\n            clearTimeout(this.reconnectTimer);\n          }\n        },\n        reconnecting: {\n          _onEnter: function _onEnter() {\n            debug.log('FSM: reconnecting._onEnter()');\n            this.reconnectCounter++;\n\n            _connect();\n          },\n          connection_ok: function connection_ok(connection) {\n            this.connection = connection;\n            this.transition('connected');\n            reSubscribeAll(); // After successful re-connect, also re-subscribe to all topics! (i.e. different from \"connection_ok\" in the state \"connecting\")\n          },\n          connection_failed: function connection_failed(err) {\n            if (brokerEventCallbacks && typeof brokerEventCallbacks.onConnectionFailed === 'function') {\n              brokerEventCallbacks.onConnectionFailed(err);\n            }\n\n            this.transition('reconnect_wait');\n          },\n          disconnect: function disconnect() {\n            this.transition('disconnecting');\n          }\n        },\n        disconnecting: {\n          _onEnter: function _onEnter() {\n            debug.log('FSM: disconnecting._onEnter()');\n            unSubscribeAll();\n\n            if (!this.connection) {\n              // No connection to stop - fire \"disconnect_ok\"-action at once\n              this.handle('disconnect_ok');\n            } else {\n              this.connection.stop()[\"catch\"](function () {})[\"finally\"](function () {\n                debug.log('connection stopped');\n                this.handle('disconnect_ok');\n              }.bind(this));\n            }\n          },\n          disconnect_ok: function disconnect_ok() {\n            this.transition('disconnected');\n          }\n        }\n      }\n    });\n  }\n  /*******************************************************************************************\r\n   ** Function for connecting (and maintaining connection) to broker\r\n   *******************************************************************************************/\n\n\n  function _connect() {\n    debug.log('_connect: Connecting to broker url: ' + options.brokerUrl);\n    var brokerConnectionOptions;\n\n    switch (options.brokerTransport) {\n      case 'None':\n      case 'Negotiate':\n        brokerConnectionOptions = null;\n        break;\n\n      case 'LongPolling':\n        brokerConnectionOptions = {\n          transport: signalr.HttpTransportType.LongPolling\n        };\n        break;\n\n      case 'ServerSentEvents':\n        brokerConnectionOptions = {\n          transport: signalr.HttpTransportType.ServerSentEvents\n        };\n        break;\n\n      default:\n        // Use WebSockets without negotiation by default... Is this ok? Do we ever want WebSockets *WITH* negotiation?\n        brokerConnectionOptions = {\n          skipNegotiation: true,\n          transport: signalr.HttpTransportType.WebSockets\n        };\n    }\n\n    var hubConnectionBuilder = new signalr.HubConnectionBuilder().withUrl(options.brokerUrl, brokerConnectionOptions).configureLogging(options.brokerLogLevel).withAutomaticReconnect([0, 500, 3000, 5000, 10000]);\n    var connection = hubConnectionBuilder.build();\n    connection.onreconnecting(function (err) {\n      debug.warn('_connect: Broker connection onreconnecting:', err, connection.connectionState, connection.receivedHandshakeResponse);\n      unSubscribeAll();\n    });\n    connection.onreconnected(function () {\n      debug.warn('_connect: Broker connection onreconnected:', connection.connectionState, connection.receivedHandshakeResponse);\n      reSubscribeAll();\n    });\n    connection.onclose(function (err) {\n      debug.log('_connect: Broker connection closed:', err, connection.connectionState, connection.receivedHandshakeResponse);\n      brokerConnection.handle('connection_failed');\n    }); // Start the connection...\n\n    connection.start().then(function () {\n      debug.log('_connect: Broker connection.start() successful:', connection, connection.connectionState, connection.receivedHandshakeResponse);\n\n      if (brokerEventCallbacks && typeof brokerEventCallbacks.onConnectionStarted === 'function') {\n        brokerEventCallbacks.onConnectionStarted(connection);\n      }\n\n      brokerConnection.handle('connection_ok', connection);\n      /*\t\t\tsetTimeout(function() {\r\n      \t\t\t\t// Due to SignalR-lib stupidity: Do not try to handle \"connection_ok\" immediately, but in a setTimeout() (in antoher thread)\r\n      \t\t\t\t// The broker will accept the connection but immediately disconnect on e.g. an invalid session\r\n      \t\t\t\t// If we handle \"connection_ok\" immediately, the brokerConnection-FSM will think we're properly connected...\r\n      \t\t\t\t// But if brokerConnection.handle('connection_ok', connection) is called in a setTimeout(), the connection.onclose()-handler will be called first.\r\n      \t\t\t\t// CAN WE RELY ON THIS?!?\r\n      \t\t\t\tbrokerConnection.handle('connection_ok', connection);\r\n      \t\t\t}, 0);*/\n    }, function (err) {\n      debug.log('_connect: Broker connection.start() error: ', err, connection, connection.connectionState);\n      brokerConnection.handle('connection_failed', err);\n    });\n  }\n\n  function isConnected() {\n    return brokerConnection.state === 'connected';\n  }\n\n  function isDisconnected() {\n    return brokerConnection.state === 'disconnected';\n  }\n\n  function connectToBroker() {\n    return new Promise(function (resolve, reject) {\n      if (isConnected()) {\n        // Already connected. Resolve with brokerConnection.connection\n        resolve(brokerConnection.connection);\n      } else {\n        // Not connected. Hook up a state transition-listener to monitor brokerConnection state changes...\n        var transitionListener = brokerConnection.on('transition', function (data) {\n          if (data.toState === 'connected') {\n            // Succesfully connected: Resolve and stop listening\n            resolve(brokerConnection.connection);\n            transitionListener.off();\n          } else if (data.toState === 'disconnected' || data.toState === 'reconnect_wait') {\n            // Transitioned to \"disconnected\": Reject and stop listening\n            reject();\n            transitionListener.off();\n          }\n        }); // Try to connect...\n        // Note: The \"connect\"-action will only be effective in states \"disconnected\" and \"reconnect_wait\".\n        // In all other states, we should soon end up in either \"connected\", \"disconnected\" or \"reconnect_wait\" very soon anyway\n\n        brokerConnection.handle('connect');\n      }\n    });\n  }\n\n  function disconnectFromBroker() {\n    return new Promise(function (resolve, reject) {\n      if (brokerConnection.state === 'disconnected') {\n        // Already disconnected. Resolve\n        resolve();\n      } // Not disconnected. Hook up a state transition-listener to monitor brokerConnection state changes...\n\n\n      var disconnectedTransitionListener = brokerConnection.on('transition', function (data) {\n        if (data.toState === 'disconnected') {\n          // Succesfully disconnected: Resolve and stop listening\n          resolve();\n          disconnectedTransitionListener.off();\n        }\n      }); // Try to disconnect...\n\n      brokerConnection.handle('disconnect');\n    });\n  }\n\n  function reConnectToBroker() {\n    return disconnectFromBroker().then(function () {\n      return connectToBroker().then(function (connection) {\n        reSubscribeAll().then(function (subscriptions) {\n          // Don't care about the result of this...\n          debug.log('reConnectToBroker: all topics re-subscribed:', subscriptions);\n        });\n        return Promise.resolve(connection); // Resolve with connection (reSubscribeAll() resolves with subscriptions, and that's probably not what the caller of reConnectToBroker() expects)\n      });\n    });\n  }\n\n  function getConnection() {\n    // Todo: Do we need more checks that connection is in the right state?\n    return connectToBroker();\n  }\n  /*******************************************************************************************\r\n   ** Functions for addig and remoing topic subscriptions\r\n   *******************************************************************************************/\n\n\n  function addSubscription(subscription, timeout) {\n    debug.log('addSubscription:', subscription, timeout);\n    unsubscribeToTopic(subscription.topic);\n    subscriptions[subscription.topic] = subscription; // Subscribe to topic, skip retrying on failures (better to reject and let caller handle it)...\n    // If a \"timeout\" is specified, reject if it's taking too long...\n\n    if (timeout) {\n      return StreamUtils.promiseTimeout(getAndSubscribeToTopic(subscription.topic), timeout);\n    } else {\n      return getAndSubscribeToTopic(subscription.topic);\n    }\n  }\n\n  function removeTopicSubscription(topic) {\n    debug.log('removeTopicSubscription:', topic);\n\n    if (subscriptions[topic]) {\n      unsubscribeToTopic(topic);\n      delete subscriptions[topic];\n    }\n\n    if (StreamUtils.isEmpty(subscriptions)) {\n      // No more active subscriptions - disconnect from broker\n      debug.log('No more subscriptions - disconnecting from broker');\n      disconnectFromBroker();\n    }\n  }\n\n  function reSubscribeAll() {\n    var subscribePromises = [];\n    Object.keys(subscriptions).forEach(function (topic) {\n      debug.log('reSubscribeAll: Re-subscribing to topic: ', topic);\n      subscribePromises.push(getAndSubscribeToTopic(topic, true)[\"catch\"](function (err) {\n        // Catch any errors from _getAndSubscribeToTopic() to prevent Promise.all() below to \"fail-fast\" on errors...\n        debug.warn('reSubscribeAll: Error re-subscribing to topic: \"' + topic + '\"', err);\n      }));\n    });\n    return Promise.all(subscribePromises);\n  }\n\n  function unSubscribeAll() {\n    // Unsubscribe any active subscription...\n    Object.keys(subscriptions).forEach(function (topic) {\n      unsubscribeToTopic(topic);\n    });\n  }\n  /*******************************************************************************************\r\n   ** Functions for getting and subscribing/unsubscribing to any topic\r\n   *******************************************************************************************/\n\n\n  function getTopic(connection, topic, fromId) {\n    // debug.log('getTopic:', topic, 'from:', fromId);\n    var resultArray = [];\n    return new Promise(function (resolve, reject) {\n      connection.stream('Get', topic, fromId).subscribe({\n        next: function next(event) {\n          // debug.log('getTopic Get stream next:', event);\n          resultArray.push(event);\n        },\n        complete: function complete() {\n          // debug.log('getTopic Get stream complete:', resultArray);\n          resolve(resultArray);\n        },\n        error: function error(err) {\n          debug.error('getTopic(): Get stream error:', err);\n\n          if (err && typeof err.message === 'string' && err.message.indexOf('HubException: Unauthorized') !== -1) {\n            // Unathorized: Nothing to do but to reject...\n            reject(err);\n          } else {\n            // Other error from hub, try to \"connection.invoke()\" instead of \"connection.stream()\" for backwards compatibility with legacy CommSrv (.NET Core 2)\n            debug.log('getTopic(): Retrying with connection.invoke(\\'Get\\', topic, fromId)');\n            connection.invoke('Get', topic, fromId).then(resolve, reject);\n          }\n        }\n      });\n    });\n  }\n\n  function getAndSubscribeToTopic(topic, keepRetrying) {\n    if (keepRetrying) {\n      return StreamUtils.retryPromiseFunc(_getAndSubscribeToTopic.bind(null, topic), resubscribeDelay * 1000, reconnectMaxRetries, 'abort');\n    } else {\n      return _getAndSubscribeToTopic(topic);\n    }\n  }\n\n  function _getAndSubscribeToTopic(topic) {\n    debug.log('_getAndSubscribeToTopic:', topic);\n    return new Promise(function (resolve, reject) {\n      // Unsubscribe if already subscribing...\n      unsubscribeToTopic(topic);\n      var subscription = subscriptions[topic];\n\n      if (!subscription) {\n        return reject('abort'); // Reject with reason 'abort' to skip retrying...\n      } // Track invocations to _getAndSubscribeToTopic() by subscription.subscribeInvocationId\n\n\n      var currentSubscribeInvocationId = ++lastSubscribeInvocationId;\n      subscription.subscribeInvocationId = currentSubscribeInvocationId;\n      debug.log('_getAndSubscribeToTopic currentSubscribeInvocationId:', currentSubscribeInvocationId);\n      getConnection().then(function (connection) {\n        debug.log('_getAndSubscribeToTopic: gotConnection:', connection); // Important: Look up the subscription for this topic again - it may have changed while waiting for connection!\n\n        subscription = subscriptions[topic];\n\n        if (subscription.subscribeInvocationId !== currentSubscribeInvocationId) {\n          debug.log('_getAndSubscribeToTopic: A newer subscription to this topic has been invoked while waiting for connection - abort this one...');\n          return reject('abort'); // Reject with reason 'abort' to skip retrying...\n        }\n\n        if (subscription.subscriberRef) {\n          // Stop any existing subscription on this topic if exists (should not happen, as we have already called unsubscribeToTopic() before connecting, and if we get here we should be in the same invocation)\n          unsubscribeToTopic(topic);\n        }\n\n        var getFullTopicState = subscription.lastReceivedEventId < 0 && (typeof subscription.fromEventId !== 'number' || subscription.fromEventId === topicStartId); // No events received yet, and no \"fromEventId\" specified (different from \"topicStartId\") => We want the full topic state!\n\n        var fromEventId = getFullTopicState ? topicStartId : subscription.lastReceivedEventId >= 0 ? subscription.lastReceivedEventId + 1 : subscription.fromEventId;\n        var getTopicPromise;\n\n        if (options.streamingSubscribeOnly) {\n          getTopicPromise = Promise.resolve([]);\n        } else {\n          debug.log('_getAndSubscribeToTopic: \\'Get\\' topic: ', topic, ' from: ', fromEventId, 'invocationId:', currentSubscribeInvocationId);\n          getTopicPromise = getTopic(connection, subscription.topic, fromEventId);\n        }\n\n        getTopicPromise.then(function (eventsArray) {\n          // Important: Look up the subscription for this topic again - it may have changed while waiting for connection!\n          subscription = subscriptions[topic];\n\n          if (subscription.subscribeInvocationId !== currentSubscribeInvocationId) {\n            debug.log('_getAndSubscribeToTopic: A newer subscription to this topic has been invoked while waiting for getTopic() - abort this one...');\n            return reject('abort'); // Reject with reason 'abort' to skip retrying...\n          }\n\n          if (eventsArray && Array.isArray(eventsArray) && eventsArray.length) {\n            // Handle events from broker 'Get' (if any exists)\n            debug.log('_getAndSubscribeToTopic: Got topic eventsArray:', eventsArray, 'invocationId:', currentSubscribeInvocationId);\n\n            try {\n              // Filter eventsArray to remove duplicates (which is a recoverable error condition)\n              // Or throw a StreamErrors.TOPIC_STREAM_OUT_OF_ORDER if expected event(s) are missing (which is an unrecoverable error)\n              eventsArray = eventsArray.filter(function (event) {\n                if (event.id < subscription.lastReceivedEventId + 1) {\n                  debug.error('Error: Broker event id in response-array from \\'Get\\' out of order (old event received). Expected ' + (subscription.lastReceivedEventId + 1) + ', received ' + event.id, event, 'invocationId:', currentSubscribeInvocationId);\n                  debug.log('Skipping event...');\n                  return false; // return false to skip by filter\n                } else if (subscription.lastReceivedEventId != -1 && event.id > subscription.lastReceivedEventId + 1) {\n                  debug.error('Error: Broker event id in response-array from \\'Get\\' out of order (gap - event(s) missing). Expected ' + (subscription.lastReceivedEventId + 1) + ', received ' + event.id, event, 'invocationId:', currentSubscribeInvocationId);\n                  throw StreamErrors.TOPIC_STREAM_OUT_OF_ORDER; // throw exception to abort (unrecoverable error)\n                }\n\n                subscription.lastReceivedEventId = event.id;\n                return true; // All ok, return true to include event\n              });\n              var receivedAs = getFullTopicState ? StreamEventTypes.STATE : StreamEventTypes.STREAMED_CHUNK;\n\n              var preparedEventsData = _prepareEventsData(eventsArray, receivedAs, 'invocationId: ' + currentSubscribeInvocationId);\n\n              subscription.onDataReceived(preparedEventsData.eventsArray, preparedEventsData.receivedAs);\n            } catch (e) {\n              if (e === StreamErrors.TOPIC_STREAM_OUT_OF_ORDER) {\n                debug.log('Unrecoverable error: Re-subscribing to topic...');\n              } else {\n                debug.log('Unknown error:', e);\n              }\n\n              getAndSubscribeToTopic(topic).then(resolve, reject); // Try to resubscribe, but skip retrying on failures...\n\n              return;\n            }\n\n            fromEventId = subscription.lastReceivedEventId + 1;\n          }\n\n          try {\n            debug.log('_getAndSubscribeToTopic: \\'Subscribe\\' to topic: ', topic, ' from id: ', fromEventId, 'invocationId:', currentSubscribeInvocationId);\n            subscription.subscriberRef = connection.stream('Subscribe', topic, fromEventId) // subscription.subscriberRef = connection.stream('Subscribe', '1'+topic, fromEventId) // Test invalid topic\n            .subscribe({\n              next: function next(event) {\n                // Handle events from broker 'Subscribe'\n                if (event.id < subscription.lastReceivedEventId + 1) {\n                  debug.error('Error: Broker event id in \\'Subscribe\\'-stream out of order (old event received). Expected ' + (subscription.lastReceivedEventId + 1) + ', received ' + event.id, event, 'invocationId:', currentSubscribeInvocationId);\n                  debug.log('Skipping event...');\n                  return;\n                } else if (subscription.lastReceivedEventId != -1 && event.id > subscription.lastReceivedEventId + 1) {\n                  debug.error('Error: Broker event id in \\'Subscribe\\'-stream out of order: (gap - event(s) missing). Expected ' + (subscription.lastReceivedEventId + 1) + ', received ' + event.id, event, 'invocationId:', currentSubscribeInvocationId);\n                  debug.log('Re-subscribing to topic...');\n                  getAndSubscribeToTopic(topic, true)[\"catch\"](function (err) {\n                    debug.log('Error resubscribing to topic (subscribe, stream out of order, gap)', err);\n                  });\n                  return;\n                }\n\n                var preparedEventsData = _prepareEventsData(event, StreamEventTypes.STREAM, 'invocationId: ' + currentSubscribeInvocationId);\n\n                subscription.onDataReceived(preparedEventsData.eventsArray, preparedEventsData.receivedAs);\n                subscription.lastReceivedEventId = event.id;\n              },\n              complete: function complete() {\n                debug.log('Stream completed on topic \"' + topic + '\"', 'invocationId:', currentSubscribeInvocationId);\n              },\n              error: function error(err) {\n                debug.error('Stream error on topic \"' + topic + '\":', err, connection, connection.connectionState, 'invocationId:', currentSubscribeInvocationId);\n                /*\r\n                \t\t\t\t\t\t\t\t\tif (useSignalRv3) {\r\n                \t\t\t\t\t\t\t\t\t\t// SignalRv3 detected: Do nothing (let auto-reconnect take care of the business)\r\n                \t\t\t\t\t\t\t\t\t\t// TODO: SOME stream errors should be handled here on signalr v3, e.g. \"slow consumer\", etc\r\n                */\n\n                debug.log('SignalR v3: Do nothing (let auto-reconnect take care of business)');\n                /*\r\n                \t\t\t\t\t\t\t\t\t\treturn;\r\n                \t\t\t\t\t\t\t\t\t}\r\n                \t\t\t\t\t\t\t\t\tdebug.log('Re-subscribing...');\r\n                \t\t\t\t\t\t\t\t\tsetTimeout(function() {\r\n                \t\t\t\t\t\t\t\t\t\tgetAndSubscribeToTopic(topic, true).catch(function (err) {\r\n                \t\t\t\t\t\t\t\t\t\t\tdebug.log('Error resubscribing to topic (subscribe, error)', err, connection, connection.connectionState);\r\n                \t\t\t\t\t\t\t\t\t\t});\r\n                \t\t\t\t\t\t\t\t\t}, resubscribeDelay * 1000);\r\n                */\n              }\n            }); // After successful subscription: Call onSubscriptionStart()-hook in the subscription, if it exists\n\n            if (subscription.onSubscriptionStart) {\n              subscription.onSubscriptionStart();\n            }\n\n            resolve(subscription.subscriberRef);\n          } catch (err) {\n            debug.error('Exception subscribing to topic \"' + topic + '\":', err, 'invocationId:', currentSubscribeInvocationId, connection, connection.connectionState);\n            reject({\n              errorCode: StreamErrors.TOPIC_SUBSCRIBE_ERROR,\n              errorMessage: 'Error subscribing to topic: ' + topic,\n              err: err\n            });\n          }\n        })[\"catch\"](function (err) {\n          // getTopic() rejected or unrecoverable reSubscribe from eventsArray array out of order\n          debug.error('_getAndSubscribeToTopic: Exception from getTopic(\"' + subscription.topic + '\"):', err, 'invocationId:', currentSubscribeInvocationId, connection, connection.connectionState);\n          reject({\n            errorCode: StreamErrors.TOPIC_GET_ERROR,\n            errorMessage: 'Error getting topic: ' + subscription.topic,\n            err: err\n          });\n        });\n      }, function (err) {\n        debug.error('_getAndSubscribeToTopic: Exception from getConnection(\"' + subscription.topic + '\"):', err, 'invocationId:', currentSubscribeInvocationId);\n        reject({\n          errorCode: StreamErrors.BROKER_CONNECT_ERROR,\n          errorMessage: 'Could not connect to broker (from _getAndSubscribeToTopic)',\n          err: err\n        });\n      });\n    });\n  }\n\n  function unsubscribeToTopic(topic) {\n    var subscription = subscriptions[topic];\n\n    if (subscription) {\n      if (subscription.subscriberRef) {\n        debug.log('unsubscribeToTopic:', topic); // Before unsubscribing an active subscription: Call onSubscriptionEnd()-hooks in the subscription, if it exists\n\n        if (subscription.onSubscriptionEnd) {\n          subscription.onSubscriptionEnd();\n        }\n\n        try {\n          subscription.subscriberRef.dispose();\n          debug.log('topic subscriber disposed');\n        } catch (e) {\n          debug.log('Exception disposing topic subscriber:', e);\n        }\n\n        subscription.subscriberRef = null;\n      }\n    }\n  }\n\n  function publishTopicWhenConnected(topic, data) {\n    return getConnection().then(function (connection) {\n      try {\n        return connection.invoke('Publish', topic, data);\n      } catch (e) {\n        debug.log('Exception in publishTopic: ', e);\n        return Promise.reject(e);\n      }\n    });\n  }\n\n  function publishTopicIfConnected(topic, data) {\n    if (!isConnected()) {\n      return Promise.reject('Not connetced');\n    }\n\n    return publishTopicWhenConnected(topic, data);\n  }\n\n  function getSubscriptions() {\n    return subscriptions;\n  }\n  /*******************************************************************************************\r\n   ** Util-function to prepare the received events before calling the subscription.onDataReceived() hook\r\n   *******************************************************************************************/\n\n\n  function _prepareEventsData(events, receivedAs, extraLoggingArg) {\n    // Incoming data from broker\n    // \"events\" contains the actual event data\n    // \t\tIt can be an array (from 'Get' topic, together with \"receivedAs\" = StreamEventTypes.STATE or StreamEventTypes.STREAMED_CHUNK)\n    // \t\tor a single event object (together with \"receivedAs\" = StreamEventTypes.STREAM)\n    // \"receivedAs\" can be StreamEventTypes.STATE, StreamEventTypes.STREAM or StreamEventTypes.STREAMED_CHUNK depending on how the data was received\n    //\t\tStreamEventTypes.STATE means than \"events\" contains the full topic state as an array\n    // \t\tStreamEventTypes.STREAMED_CHUNK means than \"events\" contains an events-array, but it does not begin with topic start, so it's not a full state (but rather a \"chunk\" of streamed data in the middle of the topic)\n    // \t\tStreamEventTypes.STREAM means than \"events\" contains a single, streamed event object (from connection.stream('Subscribe', ...)\n    // \"extraLoggingArg\" (optional) will be added to the debug log\n    // Assemble debug data...\n    var debugData = [];\n\n    if (receivedAs === StreamEventTypes.STREAM) {\n      debugData.push('conversationData STREAM-event:', events.data.type + (events.data.type === 'conversationMessage' ? ' (' + events.data.messageType + ')' : ''));\n    } else if (receivedAs === StreamEventTypes.STREAMED_CHUNK) {\n      debugData.push('conversationData STREAMED_CHUNK-array:');\n    } else if (receivedAs === StreamEventTypes.STATE) {\n      debugData.push('conversationData STATE-array:');\n    } else {\n      debugData.push('conversationData (receivedAs = unknown)):');\n    }\n\n    debugData.push(events, extraLoggingArg);\n    debug.log.apply(null, debugData);\n    return {\n      eventsArray: receivedAs === StreamEventTypes.STREAM ? [events] : events,\n      receivedAs: receivedAs\n    };\n  }\n  /*******************************************************************************************\r\n   ** Init function to configure StreamConnector\r\n   *\r\n   *   brokerUrl \t\t= URL to CommSrv broker endpoint (Note: Should include sessionId as query parameter!)\r\n   *\r\n   *   streamOptions\t= Config object for signalR and related behavior\r\n   *    \tstreamOptions.brokerTransport (optional, default 'WebSockets'):\r\n   *      \tOne of: 'None' | 'Negotiate' | 'WebSockets' | 'LongPolling' | 'ServerSentEvents'\r\n   *      streamOptions.brokerLogLevel (optional, default 'none'):\r\n   *        \tOne of: 'trace' | 'debug' | 'info' | 'warn' | 'error' | 'critical' | 'none'\r\n   *      streamOptions.streamingSubscribeOnly (optional, default false):\r\n   *      \tIf true, topic history/state is not fetched using 'Get' (i.e. everything is streamed using 'Subscribe' only)\r\n   *\r\n   *   eventHandlers\t= Object containing (optional) event handler hook functions, e.g.\r\n   *    \t{\r\n   *    \t\tonConnectionStarted = function (connection) { // Do something on broker connection started...  },\r\n   *    \t\tonConnectionFailed = function (connection) { // Do something on broker connection failed... },\r\n   *\t\t}\r\n   *\r\n   *\t dependencyLibs\t= Object containing dependency libraries (for now, only 'machina')\r\n   *\t \tThis library needs to be injected at runtime (Visitor already uses it, so we don't want to include it twice)\r\n   *\r\n   *\t initDebug\t\t= Optional object containing debug functions, e.g.\r\n   *\t \t{\r\n   * \t\t\tlog: function () { ... },\r\n   * \t\t\twarn: function () { ... },\r\n   * \t\t\terror: function () { ... },\r\n   * \t\t\tinfo: function () { ... },\r\n   *\t \t}\r\n   *******************************************************************************************/\n\n\n  var init = function init(brokerUrl, streamOptions, eventHandlers, dependencyLibs, initDebug) {\n    if (!machina) {\n      machina = dependencyLibs.machina;\n      initBrokerConnectionFsm(machina);\n    }\n\n    streamOptions = streamOptions || {};\n    initDebug = initDebug || noDebug;\n    streamOptions.brokerTransport = streamOptions.brokerTransport || 'WebSockets';\n    streamOptions.brokerLogLevel = streamOptions.brokerLogLevel || 'none';\n    streamOptions.streamingSubscribeOnly = streamOptions.streamingSubscribeOnly || false;\n\n    if (brokerUrl && brokerUrl !== options.brokerUrl || streamOptions.brokerTransport !== options.brokerTransport || streamOptions.brokerLogLevel !== options.brokerLogLevel) {\n      debug = initDebug;\n      options.brokerUrl = brokerUrl;\n      options.brokerTransport = streamOptions.brokerTransport;\n      options.brokerLogLevel = streamOptions.brokerLogLevel;\n      options.streamingSubscribeOnly = streamOptions.streamingSubscribeOnly;\n      brokerEventCallbacks = eventHandlers;\n      debug.log('Initializing StreamConnector');\n      debug.log('SignalR client lib version:', signalr.VERSION);\n\n      if (!isDisconnected()) {\n        // If we have an active connection: Re-connect to broker with the new brokerUrl...\n        reConnectToBroker().then(function (connection) {\n          debug.log('StreamConnector: broker config changed: Successfully re-connected to broker', connection);\n        }, function (err) {\n          debug.error('StreamConnector: broker config changed: Error re-connecting to broker', err);\n        });\n      }\n    }\n  };\n\n  return {\n    _signalr: signalr,\n    // Expose the signalr lib  - mainly for debugging...\n    init: init,\n    getSubscriptions: getSubscriptions,\n    addSubscription: addSubscription,\n    removeTopicSubscription: removeTopicSubscription,\n    publishTopicIfConnected: publishTopicIfConnected\n  };\n}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n//# sourceURL=webpack://vngageStreamLib/./src/StreamConnector.js?");

/***/ }),

/***/ "./src/StreamErrors.js":
/*!*****************************!*\
  !*** ./src/StreamErrors.js ***!
  \*****************************/
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_RESULT__ = (function () {\n  'use strict';\n\n  return {\n    BROKER_DISCONNECTED: 0,\n    BROKER_CONNECT_ERROR: 1,\n    BROKER_RECONNECT_ATTEMPT_ERROR: 2,\n    BROKER_RECONNECT_FATAL_ERROR: 3,\n    BROKER_INVALID_CONNECTION_ERROR: 4,\n    TOPIC_GET_ERROR: 5,\n    TOPIC_SUBSCRIBE_ERROR: 6,\n    TOPIC_STREAM_OUT_OF_ORDER: 7\n  };\n}).call(exports, __webpack_require__, exports, module),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n//# sourceURL=webpack://vngageStreamLib/./src/StreamErrors.js?");

/***/ }),

/***/ "./src/StreamEventTypes.js":
/*!*********************************!*\
  !*** ./src/StreamEventTypes.js ***!
  \*********************************/
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_RESULT__ = (function () {\n  'use strict';\n\n  return {\n    STATE: 'state',\n    STREAM: 'stream',\n    STREAMED_CHUNK: 'chunk'\n  };\n}).call(exports, __webpack_require__, exports, module),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n//# sourceURL=webpack://vngageStreamLib/./src/StreamEventTypes.js?");

/***/ }),

/***/ "./src/StreamUtils.js":
/*!****************************!*\
  !*** ./src/StreamUtils.js ***!
  \****************************/
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_RESULT__ = (function (require) {\n  'use strict';\n\n  function wait(ms) {\n    return new Promise(function (r) {\n      return setTimeout(r, ms);\n    });\n  }\n\n  function retryPromiseFunc(promisedFunction, delay, maxRetries, abortReason) {\n    // This function retries \"promisedFunction\" (a function which is expected to return a Promise) until it's reloved, or until retried \"maxRetries\" number of times or until rejected with reason == \"abortReason\"...\n    return new Promise(function (resolve, reject) {\n      return promisedFunction().then(resolve)[\"catch\"](function (reason) {\n        if (maxRetries - 1 > 0 && reason !== abortReason) {\n          return wait(delay).then(retryPromiseFunc.bind(null, promisedFunction, delay, maxRetries - 1, abortReason)).then(resolve)[\"catch\"](reject);\n        }\n\n        return reject(reason);\n      });\n    });\n  }\n\n  function promiseTimeout(promise, ms) {\n    // Create a promise that rejects in <ms> milliseconds\n    // Returns a race between our timeout and the passed in promise\n    return Promise.race([promise, new Promise(function (resolve, reject) {\n      wait(ms).then(reject.bind(null, 'timeout'));\n    })]);\n  }\n\n  function isEmpty(obj) {\n    for (var prop in obj) {\n      if (obj.hasOwnProperty(prop)) return false;\n    }\n\n    return true;\n  } // From: https://gomakethings.com/merging-objects-with-vanilla-javascript/\n\n\n  var extend = function extend() {\n    // Variables\n    var extended = {};\n    var deep = false;\n    var i = 0; // Check if a deep merge\n\n    if (typeof arguments[0] === 'boolean') {\n      deep = arguments[0];\n      i++;\n    } // Merge the object into the extended object\n\n\n    var merge = function merge(obj) {\n      for (var prop in obj) {\n        if (obj.hasOwnProperty(prop)) {\n          if (deep && Object.prototype.toString.call(obj[prop]) === '[object Object]') {\n            // If we're doing a deep merge and the property is an object\n            extended[prop] = extend(true, extended[prop], obj[prop]);\n          } else {\n            // Otherwise, do a regular merge\n            extended[prop] = obj[prop];\n          }\n        }\n      }\n    }; // Loop through each object and conduct a merge\n\n\n    for (; i < arguments.length; i++) {\n      merge(arguments[i]);\n    }\n\n    return extended;\n  };\n\n  return {\n    retryPromiseFunc: retryPromiseFunc,\n    promiseTimeout: promiseTimeout,\n    isEmpty: isEmpty,\n    extend: extend\n  };\n}).call(exports, __webpack_require__, exports, module),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n//# sourceURL=webpack://vngageStreamLib/./src/StreamUtils.js?");

/***/ }),

/***/ "./src/Subscription.js":
/*!*****************************!*\
  !*** ./src/Subscription.js ***!
  \*****************************/
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_RESULT__;// Simple module to create a new \"subscription\"-object to subscribe to events from streaming broker (via SignalR)\n// It will add and init correct default properties for usage by StreamConnector\n// Add overridden and/or custom props as the arg to extend()\n!(__WEBPACK_AMD_DEFINE_RESULT__ = (function (require) {\n  'use strict';\n\n  var StreamUtils = __webpack_require__(/*! ./StreamUtils */ \"./src/StreamUtils.js\");\n\n  var defaultSubscriptionProps = {\n    topic: '',\n    fromEventId: null,\n    subscribeInvocationId: -1,\n    subscriberRef: null,\n    lastReceivedEventId: -1,\n    onDataReceived: function onDataReceived() {},\n    onSubscriptionStart: null,\n    onSubscriptionEnd: null\n  };\n  return {\n    extend: function extend(props) {\n      return StreamUtils.extend({}, defaultSubscriptionProps, props);\n    }\n  };\n}).call(exports, __webpack_require__, exports, module),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n//# sourceURL=webpack://vngageStreamLib/./src/Subscription.js?");

/***/ }),

/***/ "./src/VngageStream.js":
/*!*****************************!*\
  !*** ./src/VngageStream.js ***!
  \*****************************/
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_RESULT__ = (function (require) {\n  'use strict';\n\n  var StreamEventTypes = __webpack_require__(/*! ./StreamEventTypes */ \"./src/StreamEventTypes.js\"),\n      StreamErrors = __webpack_require__(/*! ./StreamErrors */ \"./src/StreamErrors.js\"),\n      StreamConnector_WithDependencyInjection = __webpack_require__(/*! ./StreamConnector */ \"./src/StreamConnector.js\"),\n      Subscription = __webpack_require__(/*! ./Subscription */ \"./src/Subscription.js\");\n\n  return {\n    StreamEventTypes: StreamEventTypes,\n    // Is this needed? Or could it be required/imported directly?\n    StreamErrors: StreamErrors,\n    // Is this needed? Or could it be required/imported directly?\n    StreamConnector: StreamConnector_WithDependencyInjection,\n    Subscription: Subscription\n  };\n}).call(exports, __webpack_require__, exports, module),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n//# sourceURL=webpack://vngageStreamLib/./src/VngageStream.js?");

/***/ }),

/***/ "./node_modules/@microsoft/signalr/dist/browser/signalr.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@microsoft/signalr/dist/browser/signalr.js ***!
  \*****************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("var t, e;\nt = self, e = function () {\n  return (() => {\n    var t = {\n      d: (e, s) => {\n        for (var n in s) t.o(s, n) && !t.o(e, n) && Object.defineProperty(e, n, {\n          enumerable: !0,\n          get: s[n]\n        });\n      }\n    };\n    t.g = function () {\n      if (\"object\" == typeof globalThis) return globalThis;\n\n      try {\n        return this || new Function(\"return this\")();\n      } catch (t) {\n        if (\"object\" == typeof window) return window;\n      }\n    }(), t.o = (t, e) => Object.prototype.hasOwnProperty.call(t, e), t.r = t => {\n      \"undefined\" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(t, Symbol.toStringTag, {\n        value: \"Module\"\n      }), Object.defineProperty(t, \"t\", {\n        value: !0\n      });\n    };\n    var e,\n        s = {};\n    t.r(s), t.d(s, {\n      AbortError: () => r,\n      DefaultHttpClient: () => H,\n      HttpClient: () => d,\n      HttpError: () => n,\n      HttpResponse: () => u,\n      HttpTransportType: () => W,\n      HubConnection: () => L,\n      HubConnectionBuilder: () => Q,\n      HubConnectionState: () => R,\n      JsonHubProtocol: () => G,\n      LogLevel: () => e,\n      MessageType: () => A,\n      NullLogger: () => f,\n      Subject: () => U,\n      TimeoutError: () => i,\n      TransferFormat: () => O,\n      VERSION: () => p\n    });\n\n    class n extends Error {\n      constructor(t, e) {\n        const s = new.target.prototype;\n        super(`${t}: Status code '${e}'`), this.statusCode = e, this.__proto__ = s;\n      }\n\n    }\n\n    class i extends Error {\n      constructor(t = \"A timeout occurred.\") {\n        const e = new.target.prototype;\n        super(t), this.__proto__ = e;\n      }\n\n    }\n\n    class r extends Error {\n      constructor(t = \"An abort occurred.\") {\n        const e = new.target.prototype;\n        super(t), this.__proto__ = e;\n      }\n\n    }\n\n    class o extends Error {\n      constructor(t, e) {\n        const s = new.target.prototype;\n        super(t), this.transport = e, this.errorType = \"UnsupportedTransportError\", this.__proto__ = s;\n      }\n\n    }\n\n    class h extends Error {\n      constructor(t, e) {\n        const s = new.target.prototype;\n        super(t), this.transport = e, this.errorType = \"DisabledTransportError\", this.__proto__ = s;\n      }\n\n    }\n\n    class c extends Error {\n      constructor(t, e) {\n        const s = new.target.prototype;\n        super(t), this.transport = e, this.errorType = \"FailedToStartTransportError\", this.__proto__ = s;\n      }\n\n    }\n\n    class a extends Error {\n      constructor(t) {\n        const e = new.target.prototype;\n        super(t), this.errorType = \"FailedToNegotiateWithServerError\", this.__proto__ = e;\n      }\n\n    }\n\n    class l extends Error {\n      constructor(t, e) {\n        const s = new.target.prototype;\n        super(t), this.innerErrors = e, this.__proto__ = s;\n      }\n\n    }\n\n    class u {\n      constructor(t, e, s) {\n        this.statusCode = t, this.statusText = e, this.content = s;\n      }\n\n    }\n\n    class d {\n      get(t, e) {\n        return this.send({ ...e,\n          method: \"GET\",\n          url: t\n        });\n      }\n\n      post(t, e) {\n        return this.send({ ...e,\n          method: \"POST\",\n          url: t\n        });\n      }\n\n      delete(t, e) {\n        return this.send({ ...e,\n          method: \"DELETE\",\n          url: t\n        });\n      }\n\n      getCookieString(t) {\n        return \"\";\n      }\n\n    }\n\n    !function (t) {\n      t[t.Trace = 0] = \"Trace\", t[t.Debug = 1] = \"Debug\", t[t.Information = 2] = \"Information\", t[t.Warning = 3] = \"Warning\", t[t.Error = 4] = \"Error\", t[t.Critical = 5] = \"Critical\", t[t.None = 6] = \"None\";\n    }(e || (e = {}));\n\n    class f {\n      constructor() {}\n\n      log(t, e) {}\n\n    }\n\n    f.instance = new f();\n    const p = \"6.0.1\";\n\n    class w {\n      static isRequired(t, e) {\n        if (null == t) throw new Error(`The '${e}' argument is required.`);\n      }\n\n      static isNotEmpty(t, e) {\n        if (!t || t.match(/^\\s*$/)) throw new Error(`The '${e}' argument should not be empty.`);\n      }\n\n      static isIn(t, e, s) {\n        if (!(t in e)) throw new Error(`Unknown ${s} value: ${t}.`);\n      }\n\n    }\n\n    class g {\n      static get isBrowser() {\n        return \"object\" == typeof window;\n      }\n\n      static get isWebWorker() {\n        return \"object\" == typeof self && \"importScripts\" in self;\n      }\n\n      static get isNode() {\n        return !this.isBrowser && !this.isWebWorker;\n      }\n\n    }\n\n    function m(t, e) {\n      let s = \"\";\n      return y(t) ? (s = `Binary data of length ${t.byteLength}`, e && (s += `. Content: '${function (t) {\n        const e = new Uint8Array(t);\n        let s = \"\";\n        return e.forEach(t => {\n          s += `0x${t < 16 ? \"0\" : \"\"}${t.toString(16)} `;\n        }), s.substr(0, s.length - 1);\n      }(t)}'`)) : \"string\" == typeof t && (s = `String data of length ${t.length}`, e && (s += `. Content: '${t}'`)), s;\n    }\n\n    function y(t) {\n      return t && \"undefined\" != typeof ArrayBuffer && (t instanceof ArrayBuffer || t.constructor && \"ArrayBuffer\" === t.constructor.name);\n    }\n\n    async function b(t, s, n, i, r, o, h) {\n      let c = {};\n\n      if (r) {\n        const t = await r();\n        t && (c = {\n          Authorization: `Bearer ${t}`\n        });\n      }\n\n      const [a, l] = $();\n      c[a] = l, t.log(e.Trace, `(${s} transport) sending data. ${m(o, h.logMessageContent)}.`);\n      const u = y(o) ? \"arraybuffer\" : \"text\",\n            d = await n.post(i, {\n        content: o,\n        headers: { ...c,\n          ...h.headers\n        },\n        responseType: u,\n        timeout: h.timeout,\n        withCredentials: h.withCredentials\n      });\n      t.log(e.Trace, `(${s} transport) request complete. Response status: ${d.statusCode}.`);\n    }\n\n    class v {\n      constructor(t, e) {\n        this.i = t, this.h = e;\n      }\n\n      dispose() {\n        const t = this.i.observers.indexOf(this.h);\n        t > -1 && this.i.observers.splice(t, 1), 0 === this.i.observers.length && this.i.cancelCallback && this.i.cancelCallback().catch(t => {});\n      }\n\n    }\n\n    class E {\n      constructor(t) {\n        this.l = t, this.out = console;\n      }\n\n      log(t, s) {\n        if (t >= this.l) {\n          const n = `[${new Date().toISOString()}] ${e[t]}: ${s}`;\n\n          switch (t) {\n            case e.Critical:\n            case e.Error:\n              this.out.error(n);\n              break;\n\n            case e.Warning:\n              this.out.warn(n);\n              break;\n\n            case e.Information:\n              this.out.info(n);\n              break;\n\n            default:\n              this.out.log(n);\n          }\n        }\n      }\n\n    }\n\n    function $() {\n      let t = \"X-SignalR-User-Agent\";\n      return g.isNode && (t = \"User-Agent\"), [t, C(p, S(), g.isNode ? \"NodeJS\" : \"Browser\", k())];\n    }\n\n    function C(t, e, s, n) {\n      let i = \"Microsoft SignalR/\";\n      const r = t.split(\".\");\n      return i += `${r[0]}.${r[1]}`, i += ` (${t}; `, i += e && \"\" !== e ? `${e}; ` : \"Unknown OS; \", i += `${s}`, i += n ? `; ${n}` : \"; Unknown Runtime Version\", i += \")\", i;\n    }\n\n    function S() {\n      if (!g.isNode) return \"\";\n\n      switch (process.platform) {\n        case \"win32\":\n          return \"Windows NT\";\n\n        case \"darwin\":\n          return \"macOS\";\n\n        case \"linux\":\n          return \"Linux\";\n\n        default:\n          return process.platform;\n      }\n    }\n\n    function k() {\n      if (g.isNode) return process.versions.node;\n    }\n\n    function P(t) {\n      return t.stack ? t.stack : t.message ? t.message : `${t}`;\n    }\n\n    class T extends d {\n      constructor(e) {\n        if (super(), this.u = e, \"undefined\" == typeof fetch) {\n          const t = undefined;\n          this.p = new (Object(function webpackMissingModule() { var e = new Error(\"Cannot find module 'tough-cookie'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }()).CookieJar)(), this.m = __webpack_require__(Object(function webpackMissingModule() { var e = new Error(\"Cannot find module 'node-fetch'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }())), this.m = __webpack_require__(Object(function webpackMissingModule() { var e = new Error(\"Cannot find module 'fetch-cookie'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }()))(this.m, this.p);\n        } else this.m = fetch.bind(function () {\n          if (\"undefined\" != typeof globalThis) return globalThis;\n          if (\"undefined\" != typeof self) return self;\n          if (\"undefined\" != typeof window) return window;\n          if (void 0 !== t.g) return t.g;\n          throw new Error(\"could not find global\");\n        }());\n\n        if (\"undefined\" == typeof AbortController) {\n          const t = undefined;\n          this.v = __webpack_require__(Object(function webpackMissingModule() { var e = new Error(\"Cannot find module 'abort-controller'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }()));\n        } else this.v = AbortController;\n      }\n\n      async send(t) {\n        if (t.abortSignal && t.abortSignal.aborted) throw new r();\n        if (!t.method) throw new Error(\"No method defined.\");\n        if (!t.url) throw new Error(\"No url defined.\");\n        const s = new this.v();\n        let o;\n        t.abortSignal && (t.abortSignal.onabort = () => {\n          s.abort(), o = new r();\n        });\n        let h,\n            c = null;\n\n        if (t.timeout) {\n          const n = t.timeout;\n          c = setTimeout(() => {\n            s.abort(), this.u.log(e.Warning, \"Timeout from HTTP request.\"), o = new i();\n          }, n);\n        }\n\n        try {\n          h = await this.m(t.url, {\n            body: t.content,\n            cache: \"no-cache\",\n            credentials: !0 === t.withCredentials ? \"include\" : \"same-origin\",\n            headers: {\n              \"Content-Type\": \"text/plain;charset=UTF-8\",\n              \"X-Requested-With\": \"XMLHttpRequest\",\n              ...t.headers\n            },\n            method: t.method,\n            mode: \"cors\",\n            redirect: \"follow\",\n            signal: s.signal\n          });\n        } catch (t) {\n          if (o) throw o;\n          throw this.u.log(e.Warning, `Error from HTTP request. ${t}.`), t;\n        } finally {\n          c && clearTimeout(c), t.abortSignal && (t.abortSignal.onabort = null);\n        }\n\n        if (!h.ok) {\n          const t = await I(h, \"text\");\n          throw new n(t || h.statusText, h.status);\n        }\n\n        const a = I(h, t.responseType),\n              l = await a;\n        return new u(h.status, h.statusText, l);\n      }\n\n      getCookieString(t) {\n        let e = \"\";\n        return g.isNode && this.p && this.p.getCookies(t, (t, s) => e = s.join(\"; \")), e;\n      }\n\n    }\n\n    function I(t, e) {\n      let s;\n\n      switch (e) {\n        case \"arraybuffer\":\n          s = t.arrayBuffer();\n          break;\n\n        case \"text\":\n          s = t.text();\n          break;\n\n        case \"blob\":\n        case \"document\":\n        case \"json\":\n          throw new Error(`${e} is not supported.`);\n\n        default:\n          s = t.text();\n      }\n\n      return s;\n    }\n\n    class _ extends d {\n      constructor(t) {\n        super(), this.u = t;\n      }\n\n      send(t) {\n        return t.abortSignal && t.abortSignal.aborted ? Promise.reject(new r()) : t.method ? t.url ? new Promise((s, o) => {\n          const h = new XMLHttpRequest();\n          h.open(t.method, t.url, !0), h.withCredentials = void 0 === t.withCredentials || t.withCredentials, h.setRequestHeader(\"X-Requested-With\", \"XMLHttpRequest\"), h.setRequestHeader(\"Content-Type\", \"text/plain;charset=UTF-8\");\n          const c = t.headers;\n          c && Object.keys(c).forEach(t => {\n            h.setRequestHeader(t, c[t]);\n          }), t.responseType && (h.responseType = t.responseType), t.abortSignal && (t.abortSignal.onabort = () => {\n            h.abort(), o(new r());\n          }), t.timeout && (h.timeout = t.timeout), h.onload = () => {\n            t.abortSignal && (t.abortSignal.onabort = null), h.status >= 200 && h.status < 300 ? s(new u(h.status, h.statusText, h.response || h.responseText)) : o(new n(h.response || h.responseText || h.statusText, h.status));\n          }, h.onerror = () => {\n            this.u.log(e.Warning, `Error from HTTP request. ${h.status}: ${h.statusText}.`), o(new n(h.statusText, h.status));\n          }, h.ontimeout = () => {\n            this.u.log(e.Warning, \"Timeout from HTTP request.\"), o(new i());\n          }, h.send(t.content || \"\");\n        }) : Promise.reject(new Error(\"No url defined.\")) : Promise.reject(new Error(\"No method defined.\"));\n      }\n\n    }\n\n    class H extends d {\n      constructor(t) {\n        if (super(), \"undefined\" != typeof fetch || g.isNode) this.$ = new T(t);else {\n          if (\"undefined\" == typeof XMLHttpRequest) throw new Error(\"No usable HttpClient found.\");\n          this.$ = new _(t);\n        }\n      }\n\n      send(t) {\n        return t.abortSignal && t.abortSignal.aborted ? Promise.reject(new r()) : t.method ? t.url ? this.$.send(t) : Promise.reject(new Error(\"No url defined.\")) : Promise.reject(new Error(\"No method defined.\"));\n      }\n\n      getCookieString(t) {\n        return this.$.getCookieString(t);\n      }\n\n    }\n\n    class D {\n      static write(t) {\n        return `${t}${D.RecordSeparator}`;\n      }\n\n      static parse(t) {\n        if (t[t.length - 1] !== D.RecordSeparator) throw new Error(\"Message is incomplete.\");\n        const e = t.split(D.RecordSeparator);\n        return e.pop(), e;\n      }\n\n    }\n\n    D.RecordSeparatorCode = 30, D.RecordSeparator = String.fromCharCode(D.RecordSeparatorCode);\n\n    class x {\n      writeHandshakeRequest(t) {\n        return D.write(JSON.stringify(t));\n      }\n\n      parseHandshakeResponse(t) {\n        let e, s;\n\n        if (y(t)) {\n          const n = new Uint8Array(t),\n                i = n.indexOf(D.RecordSeparatorCode);\n          if (-1 === i) throw new Error(\"Message is incomplete.\");\n          const r = i + 1;\n          e = String.fromCharCode.apply(null, Array.prototype.slice.call(n.slice(0, r))), s = n.byteLength > r ? n.slice(r).buffer : null;\n        } else {\n          const n = t,\n                i = n.indexOf(D.RecordSeparator);\n          if (-1 === i) throw new Error(\"Message is incomplete.\");\n          const r = i + 1;\n          e = n.substring(0, r), s = n.length > r ? n.substring(r) : null;\n        }\n\n        const n = D.parse(e),\n              i = JSON.parse(n[0]);\n        if (i.type) throw new Error(\"Expected a handshake response from the server.\");\n        return [s, i];\n      }\n\n    }\n\n    var A, R;\n    !function (t) {\n      t[t.Invocation = 1] = \"Invocation\", t[t.StreamItem = 2] = \"StreamItem\", t[t.Completion = 3] = \"Completion\", t[t.StreamInvocation = 4] = \"StreamInvocation\", t[t.CancelInvocation = 5] = \"CancelInvocation\", t[t.Ping = 6] = \"Ping\", t[t.Close = 7] = \"Close\";\n    }(A || (A = {}));\n\n    class U {\n      constructor() {\n        this.observers = [];\n      }\n\n      next(t) {\n        for (const e of this.observers) e.next(t);\n      }\n\n      error(t) {\n        for (const e of this.observers) e.error && e.error(t);\n      }\n\n      complete() {\n        for (const t of this.observers) t.complete && t.complete();\n      }\n\n      subscribe(t) {\n        return this.observers.push(t), new v(this, t);\n      }\n\n    }\n\n    !function (t) {\n      t.Disconnected = \"Disconnected\", t.Connecting = \"Connecting\", t.Connected = \"Connected\", t.Disconnecting = \"Disconnecting\", t.Reconnecting = \"Reconnecting\";\n    }(R || (R = {}));\n\n    class L {\n      constructor(t, s, n, i) {\n        this.C = 0, this.S = () => {\n          this.u.log(e.Warning, \"The page is being frozen, this will likely lead to the connection being closed and messages being lost. For more information see the docs at https://docs.microsoft.com/aspnet/core/signalr/javascript-client#bsleep\");\n        }, w.isRequired(t, \"connection\"), w.isRequired(s, \"logger\"), w.isRequired(n, \"protocol\"), this.serverTimeoutInMilliseconds = 3e4, this.keepAliveIntervalInMilliseconds = 15e3, this.u = s, this.k = n, this.connection = t, this.P = i, this.T = new x(), this.connection.onreceive = t => this.I(t), this.connection.onclose = t => this._(t), this.H = {}, this.D = {}, this.A = [], this.R = [], this.U = [], this.L = 0, this.N = !1, this.q = R.Disconnected, this.M = !1, this.W = this.k.writeMessage({\n          type: A.Ping\n        });\n      }\n\n      static create(t, e, s, n) {\n        return new L(t, e, s, n);\n      }\n\n      get state() {\n        return this.q;\n      }\n\n      get connectionId() {\n        return this.connection && this.connection.connectionId || null;\n      }\n\n      get baseUrl() {\n        return this.connection.baseUrl || \"\";\n      }\n\n      set baseUrl(t) {\n        if (this.q !== R.Disconnected && this.q !== R.Reconnecting) throw new Error(\"The HubConnection must be in the Disconnected or Reconnecting state to change the url.\");\n        if (!t) throw new Error(\"The HubConnection url must be a valid url.\");\n        this.connection.baseUrl = t;\n      }\n\n      start() {\n        return this.O = this.j(), this.O;\n      }\n\n      async j() {\n        if (this.q !== R.Disconnected) return Promise.reject(new Error(\"Cannot start a HubConnection that is not in the 'Disconnected' state.\"));\n        this.q = R.Connecting, this.u.log(e.Debug, \"Starting HubConnection.\");\n\n        try {\n          await this.F(), g.isBrowser && document && document.addEventListener(\"freeze\", this.S), this.q = R.Connected, this.M = !0, this.u.log(e.Debug, \"HubConnection connected successfully.\");\n        } catch (t) {\n          return this.q = R.Disconnected, this.u.log(e.Debug, `HubConnection failed to start successfully because of error '${t}'.`), Promise.reject(t);\n        }\n      }\n\n      async F() {\n        this.B = void 0, this.N = !1;\n        const t = new Promise((t, e) => {\n          this.X = t, this.J = e;\n        });\n        await this.connection.start(this.k.transferFormat);\n\n        try {\n          const s = {\n            protocol: this.k.name,\n            version: this.k.version\n          };\n          if (this.u.log(e.Debug, \"Sending handshake request.\"), await this.V(this.T.writeHandshakeRequest(s)), this.u.log(e.Information, `Using HubProtocol '${this.k.name}'.`), this.G(), this.K(), this.Y(), await t, this.B) throw this.B;\n        } catch (t) {\n          throw this.u.log(e.Debug, `Hub handshake failed with error '${t}' during start(). Stopping HubConnection.`), this.G(), this.Z(), await this.connection.stop(t), t;\n        }\n      }\n\n      async stop() {\n        const t = this.O;\n        this.tt = this.et(), await this.tt;\n\n        try {\n          await t;\n        } catch (t) {}\n      }\n\n      et(t) {\n        return this.q === R.Disconnected ? (this.u.log(e.Debug, `Call to HubConnection.stop(${t}) ignored because it is already in the disconnected state.`), Promise.resolve()) : this.q === R.Disconnecting ? (this.u.log(e.Debug, `Call to HttpConnection.stop(${t}) ignored because the connection is already in the disconnecting state.`), this.tt) : (this.q = R.Disconnecting, this.u.log(e.Debug, \"Stopping HubConnection.\"), this.st ? (this.u.log(e.Debug, \"Connection stopped during reconnect delay. Done reconnecting.\"), clearTimeout(this.st), this.st = void 0, this.nt(), Promise.resolve()) : (this.G(), this.Z(), this.B = t || new Error(\"The connection was stopped before the hub handshake could complete.\"), this.connection.stop(t)));\n      }\n\n      stream(t, ...e) {\n        const [s, n] = this.it(e),\n              i = this.rt(t, e, n);\n        let r;\n        const o = new U();\n        return o.cancelCallback = () => {\n          const t = this.ot(i.invocationId);\n          return delete this.H[i.invocationId], r.then(() => this.ht(t));\n        }, this.H[i.invocationId] = (t, e) => {\n          e ? o.error(e) : t && (t.type === A.Completion ? t.error ? o.error(new Error(t.error)) : o.complete() : o.next(t.item));\n        }, r = this.ht(i).catch(t => {\n          o.error(t), delete this.H[i.invocationId];\n        }), this.ct(s, r), o;\n      }\n\n      V(t) {\n        return this.Y(), this.connection.send(t);\n      }\n\n      ht(t) {\n        return this.V(this.k.writeMessage(t));\n      }\n\n      send(t, ...e) {\n        const [s, n] = this.it(e),\n              i = this.ht(this.at(t, e, !0, n));\n        return this.ct(s, i), i;\n      }\n\n      invoke(t, ...e) {\n        const [s, n] = this.it(e),\n              i = this.at(t, e, !1, n);\n        return new Promise((t, e) => {\n          this.H[i.invocationId] = (s, n) => {\n            n ? e(n) : s && (s.type === A.Completion ? s.error ? e(new Error(s.error)) : t(s.result) : e(new Error(`Unexpected message type: ${s.type}`)));\n          };\n\n          const n = this.ht(i).catch(t => {\n            e(t), delete this.H[i.invocationId];\n          });\n          this.ct(s, n);\n        });\n      }\n\n      on(t, e) {\n        t && e && (t = t.toLowerCase(), this.D[t] || (this.D[t] = []), -1 === this.D[t].indexOf(e) && this.D[t].push(e));\n      }\n\n      off(t, e) {\n        if (!t) return;\n        t = t.toLowerCase();\n        const s = this.D[t];\n        if (s) if (e) {\n          const n = s.indexOf(e);\n          -1 !== n && (s.splice(n, 1), 0 === s.length && delete this.D[t]);\n        } else delete this.D[t];\n      }\n\n      onclose(t) {\n        t && this.A.push(t);\n      }\n\n      onreconnecting(t) {\n        t && this.R.push(t);\n      }\n\n      onreconnected(t) {\n        t && this.U.push(t);\n      }\n\n      I(t) {\n        if (this.G(), this.N || (t = this.lt(t), this.N = !0), t) {\n          const s = this.k.parseMessages(t, this.u);\n\n          for (const t of s) switch (t.type) {\n            case A.Invocation:\n              this.ut(t);\n              break;\n\n            case A.StreamItem:\n            case A.Completion:\n              {\n                const s = this.H[t.invocationId];\n\n                if (s) {\n                  t.type === A.Completion && delete this.H[t.invocationId];\n\n                  try {\n                    s(t);\n                  } catch (t) {\n                    this.u.log(e.Error, `Stream callback threw error: ${P(t)}`);\n                  }\n                }\n\n                break;\n              }\n\n            case A.Ping:\n              break;\n\n            case A.Close:\n              {\n                this.u.log(e.Information, \"Close message received from server.\");\n                const s = t.error ? new Error(\"Server returned an error on close: \" + t.error) : void 0;\n                !0 === t.allowReconnect ? this.connection.stop(s) : this.tt = this.et(s);\n                break;\n              }\n\n            default:\n              this.u.log(e.Warning, `Invalid message type: ${t.type}.`);\n          }\n        }\n\n        this.K();\n      }\n\n      lt(t) {\n        let s, n;\n\n        try {\n          [n, s] = this.T.parseHandshakeResponse(t);\n        } catch (t) {\n          const s = \"Error parsing handshake response: \" + t;\n          this.u.log(e.Error, s);\n          const n = new Error(s);\n          throw this.J(n), n;\n        }\n\n        if (s.error) {\n          const t = \"Server returned handshake error: \" + s.error;\n          this.u.log(e.Error, t);\n          const n = new Error(t);\n          throw this.J(n), n;\n        }\n\n        return this.u.log(e.Debug, \"Server handshake complete.\"), this.X(), n;\n      }\n\n      Y() {\n        this.connection.features.inherentKeepAlive || (this.C = new Date().getTime() + this.keepAliveIntervalInMilliseconds, this.Z());\n      }\n\n      K() {\n        if (!(this.connection.features && this.connection.features.inherentKeepAlive || (this.dt = setTimeout(() => this.serverTimeout(), this.serverTimeoutInMilliseconds), void 0 !== this.ft))) {\n          let t = this.C - new Date().getTime();\n          t < 0 && (t = 0), this.ft = setTimeout(async () => {\n            if (this.q === R.Connected) try {\n              await this.V(this.W);\n            } catch {\n              this.Z();\n            }\n          }, t);\n        }\n      }\n\n      serverTimeout() {\n        this.connection.stop(new Error(\"Server timeout elapsed without receiving a message from the server.\"));\n      }\n\n      ut(t) {\n        const s = this.D[t.target.toLowerCase()];\n\n        if (s) {\n          try {\n            s.forEach(e => e.apply(this, t.arguments));\n          } catch (s) {\n            this.u.log(e.Error, `A callback for the method ${t.target.toLowerCase()} threw error '${s}'.`);\n          }\n\n          if (t.invocationId) {\n            const t = \"Server requested a response, which is not supported in this version of the client.\";\n            this.u.log(e.Error, t), this.tt = this.et(new Error(t));\n          }\n        } else this.u.log(e.Warning, `No client method with the name '${t.target}' found.`);\n      }\n\n      _(t) {\n        this.u.log(e.Debug, `HubConnection.connectionClosed(${t}) called while in state ${this.q}.`), this.B = this.B || t || new Error(\"The underlying connection was closed before the hub handshake could complete.\"), this.X && this.X(), this.wt(t || new Error(\"Invocation canceled due to the underlying connection being closed.\")), this.G(), this.Z(), this.q === R.Disconnecting ? this.nt(t) : this.q === R.Connected && this.P ? this.gt(t) : this.q === R.Connected && this.nt(t);\n      }\n\n      nt(t) {\n        if (this.M) {\n          this.q = R.Disconnected, this.M = !1, g.isBrowser && document && document.removeEventListener(\"freeze\", this.S);\n\n          try {\n            this.A.forEach(e => e.apply(this, [t]));\n          } catch (s) {\n            this.u.log(e.Error, `An onclose callback called with error '${t}' threw error '${s}'.`);\n          }\n        }\n      }\n\n      async gt(t) {\n        const s = Date.now();\n        let n = 0,\n            i = void 0 !== t ? t : new Error(\"Attempting to reconnect due to a unknown error.\"),\n            r = this.yt(n++, 0, i);\n        if (null === r) return this.u.log(e.Debug, \"Connection not reconnecting because the IRetryPolicy returned null on the first reconnect attempt.\"), void this.nt(t);\n\n        if (this.q = R.Reconnecting, t ? this.u.log(e.Information, `Connection reconnecting because of error '${t}'.`) : this.u.log(e.Information, \"Connection reconnecting.\"), 0 !== this.R.length) {\n          try {\n            this.R.forEach(e => e.apply(this, [t]));\n          } catch (s) {\n            this.u.log(e.Error, `An onreconnecting callback called with error '${t}' threw error '${s}'.`);\n          }\n\n          if (this.q !== R.Reconnecting) return void this.u.log(e.Debug, \"Connection left the reconnecting state in onreconnecting callback. Done reconnecting.\");\n        }\n\n        for (; null !== r;) {\n          if (this.u.log(e.Information, `Reconnect attempt number ${n} will start in ${r} ms.`), await new Promise(t => {\n            this.st = setTimeout(t, r);\n          }), this.st = void 0, this.q !== R.Reconnecting) return void this.u.log(e.Debug, \"Connection left the reconnecting state during reconnect delay. Done reconnecting.\");\n\n          try {\n            if (await this.F(), this.q = R.Connected, this.u.log(e.Information, \"HubConnection reconnected successfully.\"), 0 !== this.U.length) try {\n              this.U.forEach(t => t.apply(this, [this.connection.connectionId]));\n            } catch (t) {\n              this.u.log(e.Error, `An onreconnected callback called with connectionId '${this.connection.connectionId}; threw error '${t}'.`);\n            }\n            return;\n          } catch (t) {\n            if (this.u.log(e.Information, `Reconnect attempt failed because of error '${t}'.`), this.q !== R.Reconnecting) return this.u.log(e.Debug, `Connection moved to the '${this.q}' from the reconnecting state during reconnect attempt. Done reconnecting.`), void (this.q === R.Disconnecting && this.nt());\n            i = t instanceof Error ? t : new Error(t.toString()), r = this.yt(n++, Date.now() - s, i);\n          }\n        }\n\n        this.u.log(e.Information, `Reconnect retries have been exhausted after ${Date.now() - s} ms and ${n} failed attempts. Connection disconnecting.`), this.nt();\n      }\n\n      yt(t, s, n) {\n        try {\n          return this.P.nextRetryDelayInMilliseconds({\n            elapsedMilliseconds: s,\n            previousRetryCount: t,\n            retryReason: n\n          });\n        } catch (n) {\n          return this.u.log(e.Error, `IRetryPolicy.nextRetryDelayInMilliseconds(${t}, ${s}) threw error '${n}'.`), null;\n        }\n      }\n\n      wt(t) {\n        const s = this.H;\n        this.H = {}, Object.keys(s).forEach(n => {\n          const i = s[n];\n\n          try {\n            i(null, t);\n          } catch (s) {\n            this.u.log(e.Error, `Stream 'error' callback called with '${t}' threw error: ${P(s)}`);\n          }\n        });\n      }\n\n      Z() {\n        this.ft && (clearTimeout(this.ft), this.ft = void 0);\n      }\n\n      G() {\n        this.dt && clearTimeout(this.dt);\n      }\n\n      at(t, e, s, n) {\n        if (s) return 0 !== n.length ? {\n          arguments: e,\n          streamIds: n,\n          target: t,\n          type: A.Invocation\n        } : {\n          arguments: e,\n          target: t,\n          type: A.Invocation\n        };\n        {\n          const s = this.L;\n          return this.L++, 0 !== n.length ? {\n            arguments: e,\n            invocationId: s.toString(),\n            streamIds: n,\n            target: t,\n            type: A.Invocation\n          } : {\n            arguments: e,\n            invocationId: s.toString(),\n            target: t,\n            type: A.Invocation\n          };\n        }\n      }\n\n      ct(t, e) {\n        if (0 !== t.length) {\n          e || (e = Promise.resolve());\n\n          for (const s in t) t[s].subscribe({\n            complete: () => {\n              e = e.then(() => this.ht(this.bt(s)));\n            },\n            error: t => {\n              let n;\n              n = t instanceof Error ? t.message : t && t.toString ? t.toString() : \"Unknown error\", e = e.then(() => this.ht(this.bt(s, n)));\n            },\n            next: t => {\n              e = e.then(() => this.ht(this.vt(s, t)));\n            }\n          });\n        }\n      }\n\n      it(t) {\n        const e = [],\n              s = [];\n\n        for (let n = 0; n < t.length; n++) {\n          const i = t[n];\n\n          if (this.Et(i)) {\n            const r = this.L;\n            this.L++, e[r] = i, s.push(r.toString()), t.splice(n, 1);\n          }\n        }\n\n        return [e, s];\n      }\n\n      Et(t) {\n        return t && t.subscribe && \"function\" == typeof t.subscribe;\n      }\n\n      rt(t, e, s) {\n        const n = this.L;\n        return this.L++, 0 !== s.length ? {\n          arguments: e,\n          invocationId: n.toString(),\n          streamIds: s,\n          target: t,\n          type: A.StreamInvocation\n        } : {\n          arguments: e,\n          invocationId: n.toString(),\n          target: t,\n          type: A.StreamInvocation\n        };\n      }\n\n      ot(t) {\n        return {\n          invocationId: t,\n          type: A.CancelInvocation\n        };\n      }\n\n      vt(t, e) {\n        return {\n          invocationId: t,\n          item: e,\n          type: A.StreamItem\n        };\n      }\n\n      bt(t, e, s) {\n        return e ? {\n          error: e,\n          invocationId: t,\n          type: A.Completion\n        } : {\n          invocationId: t,\n          result: s,\n          type: A.Completion\n        };\n      }\n\n    }\n\n    const N = [0, 2e3, 1e4, 3e4, null];\n\n    class q {\n      constructor(t) {\n        this.$t = void 0 !== t ? [...t, null] : N;\n      }\n\n      nextRetryDelayInMilliseconds(t) {\n        return this.$t[t.previousRetryCount];\n      }\n\n    }\n\n    class M {}\n\n    var W, O;\n    M.Authorization = \"Authorization\", M.Cookie = \"Cookie\", function (t) {\n      t[t.None = 0] = \"None\", t[t.WebSockets = 1] = \"WebSockets\", t[t.ServerSentEvents = 2] = \"ServerSentEvents\", t[t.LongPolling = 4] = \"LongPolling\";\n    }(W || (W = {})), function (t) {\n      t[t.Text = 1] = \"Text\", t[t.Binary = 2] = \"Binary\";\n    }(O || (O = {}));\n\n    class j {\n      constructor() {\n        this.Ct = !1, this.onabort = null;\n      }\n\n      abort() {\n        this.Ct || (this.Ct = !0, this.onabort && this.onabort());\n      }\n\n      get signal() {\n        return this;\n      }\n\n      get aborted() {\n        return this.Ct;\n      }\n\n    }\n\n    class F {\n      constructor(t, e, s, n) {\n        this.$ = t, this.St = e, this.u = s, this.kt = new j(), this.Pt = n, this.Tt = !1, this.onreceive = null, this.onclose = null;\n      }\n\n      get pollAborted() {\n        return this.kt.aborted;\n      }\n\n      async connect(t, s) {\n        if (w.isRequired(t, \"url\"), w.isRequired(s, \"transferFormat\"), w.isIn(s, O, \"transferFormat\"), this.It = t, this.u.log(e.Trace, \"(LongPolling transport) Connecting.\"), s === O.Binary && \"undefined\" != typeof XMLHttpRequest && \"string\" != typeof new XMLHttpRequest().responseType) throw new Error(\"Binary protocols over XmlHttpRequest not implementing advanced features are not supported.\");\n        const [i, r] = $(),\n              o = {\n          [i]: r,\n          ...this.Pt.headers\n        },\n              h = {\n          abortSignal: this.kt.signal,\n          headers: o,\n          timeout: 1e5,\n          withCredentials: this.Pt.withCredentials\n        };\n        s === O.Binary && (h.responseType = \"arraybuffer\");\n        const c = await this._t();\n        this.Ht(h, c);\n        const a = `${t}&_=${Date.now()}`;\n        this.u.log(e.Trace, `(LongPolling transport) polling: ${a}.`);\n        const l = await this.$.get(a, h);\n        200 !== l.statusCode ? (this.u.log(e.Error, `(LongPolling transport) Unexpected response code: ${l.statusCode}.`), this.Dt = new n(l.statusText || \"\", l.statusCode), this.Tt = !1) : this.Tt = !0, this.xt = this.At(this.It, h);\n      }\n\n      async _t() {\n        return this.St ? await this.St() : null;\n      }\n\n      Ht(t, e) {\n        t.headers || (t.headers = {}), e ? t.headers[M.Authorization] = `Bearer ${e}` : t.headers[M.Authorization] && delete t.headers[M.Authorization];\n      }\n\n      async At(t, s) {\n        try {\n          for (; this.Tt;) {\n            const r = await this._t();\n            this.Ht(s, r);\n\n            try {\n              const i = `${t}&_=${Date.now()}`;\n              this.u.log(e.Trace, `(LongPolling transport) polling: ${i}.`);\n              const r = await this.$.get(i, s);\n              204 === r.statusCode ? (this.u.log(e.Information, \"(LongPolling transport) Poll terminated by server.\"), this.Tt = !1) : 200 !== r.statusCode ? (this.u.log(e.Error, `(LongPolling transport) Unexpected response code: ${r.statusCode}.`), this.Dt = new n(r.statusText || \"\", r.statusCode), this.Tt = !1) : r.content ? (this.u.log(e.Trace, `(LongPolling transport) data received. ${m(r.content, this.Pt.logMessageContent)}.`), this.onreceive && this.onreceive(r.content)) : this.u.log(e.Trace, \"(LongPolling transport) Poll timed out, reissuing.\");\n            } catch (t) {\n              this.Tt ? t instanceof i ? this.u.log(e.Trace, \"(LongPolling transport) Poll timed out, reissuing.\") : (this.Dt = t, this.Tt = !1) : this.u.log(e.Trace, `(LongPolling transport) Poll errored after shutdown: ${t.message}`);\n            }\n          }\n        } finally {\n          this.u.log(e.Trace, \"(LongPolling transport) Polling complete.\"), this.pollAborted || this.Rt();\n        }\n      }\n\n      async send(t) {\n        return this.Tt ? b(this.u, \"LongPolling\", this.$, this.It, this.St, t, this.Pt) : Promise.reject(new Error(\"Cannot send until the transport is connected\"));\n      }\n\n      async stop() {\n        this.u.log(e.Trace, \"(LongPolling transport) Stopping polling.\"), this.Tt = !1, this.kt.abort();\n\n        try {\n          await this.xt, this.u.log(e.Trace, `(LongPolling transport) sending DELETE request to ${this.It}.`);\n          const t = {},\n                [s, n] = $();\n          t[s] = n;\n          const i = {\n            headers: { ...t,\n              ...this.Pt.headers\n            },\n            timeout: this.Pt.timeout,\n            withCredentials: this.Pt.withCredentials\n          },\n                r = await this._t();\n          this.Ht(i, r), await this.$.delete(this.It, i), this.u.log(e.Trace, \"(LongPolling transport) DELETE request sent.\");\n        } finally {\n          this.u.log(e.Trace, \"(LongPolling transport) Stop finished.\"), this.Rt();\n        }\n      }\n\n      Rt() {\n        if (this.onclose) {\n          let t = \"(LongPolling transport) Firing onclose event.\";\n          this.Dt && (t += \" Error: \" + this.Dt), this.u.log(e.Trace, t), this.onclose(this.Dt);\n        }\n      }\n\n    }\n\n    class B {\n      constructor(t, e, s, n) {\n        this.$ = t, this.St = e, this.u = s, this.Pt = n, this.onreceive = null, this.onclose = null;\n      }\n\n      async connect(t, s) {\n        if (w.isRequired(t, \"url\"), w.isRequired(s, \"transferFormat\"), w.isIn(s, O, \"transferFormat\"), this.u.log(e.Trace, \"(SSE transport) Connecting.\"), this.It = t, this.St) {\n          const e = await this.St();\n          e && (t += (t.indexOf(\"?\") < 0 ? \"?\" : \"&\") + `access_token=${encodeURIComponent(e)}`);\n        }\n\n        return new Promise((n, i) => {\n          let r,\n              o = !1;\n\n          if (s === O.Text) {\n            if (g.isBrowser || g.isWebWorker) r = new this.Pt.EventSource(t, {\n              withCredentials: this.Pt.withCredentials\n            });else {\n              const e = this.$.getCookieString(t),\n                    s = {};\n              s.Cookie = e;\n              const [n, i] = $();\n              s[n] = i, r = new this.Pt.EventSource(t, {\n                withCredentials: this.Pt.withCredentials,\n                headers: { ...s,\n                  ...this.Pt.headers\n                }\n              });\n            }\n\n            try {\n              r.onmessage = t => {\n                if (this.onreceive) try {\n                  this.u.log(e.Trace, `(SSE transport) data received. ${m(t.data, this.Pt.logMessageContent)}.`), this.onreceive(t.data);\n                } catch (t) {\n                  return void this.Ut(t);\n                }\n              }, r.onerror = t => {\n                o ? this.Ut() : i(new Error(\"EventSource failed to connect. The connection could not be found on the server, either the connection ID is not present on the server, or a proxy is refusing/buffering the connection. If you have multiple servers check that sticky sessions are enabled.\"));\n              }, r.onopen = () => {\n                this.u.log(e.Information, `SSE connected to ${this.It}`), this.Lt = r, o = !0, n();\n              };\n            } catch (t) {\n              return void i(t);\n            }\n          } else i(new Error(\"The Server-Sent Events transport only supports the 'Text' transfer format\"));\n        });\n      }\n\n      async send(t) {\n        return this.Lt ? b(this.u, \"SSE\", this.$, this.It, this.St, t, this.Pt) : Promise.reject(new Error(\"Cannot send until the transport is connected\"));\n      }\n\n      stop() {\n        return this.Ut(), Promise.resolve();\n      }\n\n      Ut(t) {\n        this.Lt && (this.Lt.close(), this.Lt = void 0, this.onclose && this.onclose(t));\n      }\n\n    }\n\n    class X {\n      constructor(t, e, s, n, i, r) {\n        this.u = s, this.St = e, this.Nt = n, this.qt = i, this.$ = t, this.onreceive = null, this.onclose = null, this.Mt = r;\n      }\n\n      async connect(t, s) {\n        if (w.isRequired(t, \"url\"), w.isRequired(s, \"transferFormat\"), w.isIn(s, O, \"transferFormat\"), this.u.log(e.Trace, \"(WebSockets transport) Connecting.\"), this.St) {\n          const e = await this.St();\n          e && (t += (t.indexOf(\"?\") < 0 ? \"?\" : \"&\") + `access_token=${encodeURIComponent(e)}`);\n        }\n\n        return new Promise((n, i) => {\n          let r;\n          t = t.replace(/^http/, \"ws\");\n          const o = this.$.getCookieString(t);\n          let h = !1;\n\n          if (g.isNode) {\n            const e = {},\n                  [s, n] = $();\n            e[s] = n, o && (e[M.Cookie] = `${o}`), r = new this.qt(t, void 0, {\n              headers: { ...e,\n                ...this.Mt\n              }\n            });\n          }\n\n          r || (r = new this.qt(t)), s === O.Binary && (r.binaryType = \"arraybuffer\"), r.onopen = s => {\n            this.u.log(e.Information, `WebSocket connected to ${t}.`), this.Wt = r, h = !0, n();\n          }, r.onerror = t => {\n            let s = null;\n            s = \"undefined\" != typeof ErrorEvent && t instanceof ErrorEvent ? t.error : \"There was an error with the transport\", this.u.log(e.Information, `(WebSockets transport) ${s}.`);\n          }, r.onmessage = t => {\n            if (this.u.log(e.Trace, `(WebSockets transport) data received. ${m(t.data, this.Nt)}.`), this.onreceive) try {\n              this.onreceive(t.data);\n            } catch (t) {\n              return void this.Ut(t);\n            }\n          }, r.onclose = t => {\n            if (h) this.Ut(t);else {\n              let e = null;\n              e = \"undefined\" != typeof ErrorEvent && t instanceof ErrorEvent ? t.error : \"WebSocket failed to connect. The connection could not be found on the server, either the endpoint may not be a SignalR endpoint, the connection ID is not present on the server, or there is a proxy blocking WebSockets. If you have multiple servers check that sticky sessions are enabled.\", i(new Error(e));\n            }\n          };\n        });\n      }\n\n      send(t) {\n        return this.Wt && this.Wt.readyState === this.qt.OPEN ? (this.u.log(e.Trace, `(WebSockets transport) sending data. ${m(t, this.Nt)}.`), this.Wt.send(t), Promise.resolve()) : Promise.reject(\"WebSocket is not in the OPEN state\");\n      }\n\n      stop() {\n        return this.Wt && this.Ut(void 0), Promise.resolve();\n      }\n\n      Ut(t) {\n        this.Wt && (this.Wt.onclose = () => {}, this.Wt.onmessage = () => {}, this.Wt.onerror = () => {}, this.Wt.close(), this.Wt = void 0), this.u.log(e.Trace, \"(WebSockets transport) socket closed.\"), this.onclose && (!this.Ot(t) || !1 !== t.wasClean && 1e3 === t.code ? t instanceof Error ? this.onclose(t) : this.onclose() : this.onclose(new Error(`WebSocket closed with status code: ${t.code} (${t.reason || \"no reason given\"}).`)));\n      }\n\n      Ot(t) {\n        return t && \"boolean\" == typeof t.wasClean && \"number\" == typeof t.code;\n      }\n\n    }\n\n    class J {\n      constructor(t, s = {}) {\n        var n;\n        if (this.jt = () => {}, this.features = {}, this.Ft = 1, w.isRequired(t, \"url\"), this.u = void 0 === (n = s.logger) ? new E(e.Information) : null === n ? f.instance : void 0 !== n.log ? n : new E(n), this.baseUrl = this.Bt(t), (s = s || {}).logMessageContent = void 0 !== s.logMessageContent && s.logMessageContent, \"boolean\" != typeof s.withCredentials && void 0 !== s.withCredentials) throw new Error(\"withCredentials option was not a 'boolean' or 'undefined' value\");\n        s.withCredentials = void 0 === s.withCredentials || s.withCredentials, s.timeout = void 0 === s.timeout ? 1e5 : s.timeout;\n        let i = null,\n            r = null;\n\n        if (g.isNode) {\n          const t = undefined;\n          i = __webpack_require__(/*! ws */ \"./node_modules/ws/browser.js\"), r = __webpack_require__(Object(function webpackMissingModule() { var e = new Error(\"Cannot find module 'eventsource'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }()));\n        }\n\n        g.isNode || \"undefined\" == typeof WebSocket || s.WebSocket ? g.isNode && !s.WebSocket && i && (s.WebSocket = i) : s.WebSocket = WebSocket, g.isNode || \"undefined\" == typeof EventSource || s.EventSource ? g.isNode && !s.EventSource && void 0 !== r && (s.EventSource = r) : s.EventSource = EventSource, this.$ = s.httpClient || new H(this.u), this.q = \"Disconnected\", this.M = !1, this.Pt = s, this.onreceive = null, this.onclose = null;\n      }\n\n      async start(t) {\n        if (t = t || O.Binary, w.isIn(t, O, \"transferFormat\"), this.u.log(e.Debug, `Starting connection with transfer format '${O[t]}'.`), \"Disconnected\" !== this.q) return Promise.reject(new Error(\"Cannot start an HttpConnection that is not in the 'Disconnected' state.\"));\n\n        if (this.q = \"Connecting\", this.Xt = this.F(t), await this.Xt, \"Disconnecting\" === this.q) {\n          const t = \"Failed to start the HttpConnection before stop() was called.\";\n          return this.u.log(e.Error, t), await this.tt, Promise.reject(new Error(t));\n        }\n\n        if (\"Connected\" !== this.q) {\n          const t = \"HttpConnection.startInternal completed gracefully but didn't enter the connection into the connected state!\";\n          return this.u.log(e.Error, t), Promise.reject(new Error(t));\n        }\n\n        this.M = !0;\n      }\n\n      send(t) {\n        return \"Connected\" !== this.q ? Promise.reject(new Error(\"Cannot send data if the connection is not in the 'Connected' State.\")) : (this.Jt || (this.Jt = new z(this.transport)), this.Jt.send(t));\n      }\n\n      async stop(t) {\n        return \"Disconnected\" === this.q ? (this.u.log(e.Debug, `Call to HttpConnection.stop(${t}) ignored because the connection is already in the disconnected state.`), Promise.resolve()) : \"Disconnecting\" === this.q ? (this.u.log(e.Debug, `Call to HttpConnection.stop(${t}) ignored because the connection is already in the disconnecting state.`), this.tt) : (this.q = \"Disconnecting\", this.tt = new Promise(t => {\n          this.jt = t;\n        }), await this.et(t), void (await this.tt));\n      }\n\n      async et(t) {\n        this.zt = t;\n\n        try {\n          await this.Xt;\n        } catch (t) {}\n\n        if (this.transport) {\n          try {\n            await this.transport.stop();\n          } catch (t) {\n            this.u.log(e.Error, `HttpConnection.transport.stop() threw error '${t}'.`), this.Vt();\n          }\n\n          this.transport = void 0;\n        } else this.u.log(e.Debug, \"HttpConnection.transport is undefined in HttpConnection.stop() because start() failed.\");\n      }\n\n      async F(t) {\n        let s = this.baseUrl;\n        this.St = this.Pt.accessTokenFactory;\n\n        try {\n          if (this.Pt.skipNegotiation) {\n            if (this.Pt.transport !== W.WebSockets) throw new Error(\"Negotiation can only be skipped when using the WebSocket transport directly.\");\n            this.transport = this.Gt(W.WebSockets), await this.Kt(s, t);\n          } else {\n            let e = null,\n                n = 0;\n\n            do {\n              if (e = await this.Qt(s), \"Disconnecting\" === this.q || \"Disconnected\" === this.q) throw new Error(\"The connection was stopped during negotiation.\");\n              if (e.error) throw new Error(e.error);\n              if (e.ProtocolVersion) throw new Error(\"Detected a connection attempt to an ASP.NET SignalR Server. This client only supports connecting to an ASP.NET Core SignalR Server. See https://aka.ms/signalr-core-differences for details.\");\n\n              if (e.url && (s = e.url), e.accessToken) {\n                const t = e.accessToken;\n\n                this.St = () => t;\n              }\n\n              n++;\n            } while (e.url && n < 100);\n\n            if (100 === n && e.url) throw new Error(\"Negotiate redirection limit exceeded.\");\n            await this.Yt(s, this.Pt.transport, e, t);\n          }\n\n          this.transport instanceof F && (this.features.inherentKeepAlive = !0), \"Connecting\" === this.q && (this.u.log(e.Debug, \"The HttpConnection connected successfully.\"), this.q = \"Connected\");\n        } catch (t) {\n          return this.u.log(e.Error, \"Failed to start the connection: \" + t), this.q = \"Disconnected\", this.transport = void 0, this.jt(), Promise.reject(t);\n        }\n      }\n\n      async Qt(t) {\n        const s = {};\n\n        if (this.St) {\n          const t = await this.St();\n          t && (s[M.Authorization] = `Bearer ${t}`);\n        }\n\n        const [i, r] = $();\n        s[i] = r;\n        const o = this.Zt(t);\n        this.u.log(e.Debug, `Sending negotiation request: ${o}.`);\n\n        try {\n          const t = await this.$.post(o, {\n            content: \"\",\n            headers: { ...s,\n              ...this.Pt.headers\n            },\n            timeout: this.Pt.timeout,\n            withCredentials: this.Pt.withCredentials\n          });\n          if (200 !== t.statusCode) return Promise.reject(new Error(`Unexpected status code returned from negotiate '${t.statusCode}'`));\n          const e = JSON.parse(t.content);\n          return (!e.negotiateVersion || e.negotiateVersion < 1) && (e.connectionToken = e.connectionId), e;\n        } catch (t) {\n          let s = \"Failed to complete negotiation with the server: \" + t;\n          return t instanceof n && 404 === t.statusCode && (s += \" Either this is not a SignalR endpoint or there is a proxy blocking the connection.\"), this.u.log(e.Error, s), Promise.reject(new a(s));\n        }\n      }\n\n      te(t, e) {\n        return e ? t + (-1 === t.indexOf(\"?\") ? \"?\" : \"&\") + `id=${e}` : t;\n      }\n\n      async Yt(t, s, n, i) {\n        let r = this.te(t, n.connectionToken);\n        if (this.ee(s)) return this.u.log(e.Debug, \"Connection was provided an instance of ITransport, using that directly.\"), this.transport = s, await this.Kt(r, i), void (this.connectionId = n.connectionId);\n        const o = [],\n              h = n.availableTransports || [];\n        let a = n;\n\n        for (const n of h) {\n          const h = this.se(n, s, i);\n          if (h instanceof Error) o.push(`${n.transport} failed:`), o.push(h);else if (this.ee(h)) {\n            if (this.transport = h, !a) {\n              try {\n                a = await this.Qt(t);\n              } catch (t) {\n                return Promise.reject(t);\n              }\n\n              r = this.te(t, a.connectionToken);\n            }\n\n            try {\n              return await this.Kt(r, i), void (this.connectionId = a.connectionId);\n            } catch (t) {\n              if (this.u.log(e.Error, `Failed to start the transport '${n.transport}': ${t}`), a = void 0, o.push(new c(`${n.transport} failed: ${t}`, W[n.transport])), \"Connecting\" !== this.q) {\n                const t = \"Failed to select transport before stop() was called.\";\n                return this.u.log(e.Debug, t), Promise.reject(new Error(t));\n              }\n            }\n          }\n        }\n\n        return o.length > 0 ? Promise.reject(new l(`Unable to connect to the server with any of the available transports. ${o.join(\" \")}`, o)) : Promise.reject(new Error(\"None of the transports supported by the client are supported by the server.\"));\n      }\n\n      Gt(t) {\n        switch (t) {\n          case W.WebSockets:\n            if (!this.Pt.WebSocket) throw new Error(\"'WebSocket' is not supported in your environment.\");\n            return new X(this.$, this.St, this.u, this.Pt.logMessageContent, this.Pt.WebSocket, this.Pt.headers || {});\n\n          case W.ServerSentEvents:\n            if (!this.Pt.EventSource) throw new Error(\"'EventSource' is not supported in your environment.\");\n            return new B(this.$, this.St, this.u, this.Pt);\n\n          case W.LongPolling:\n            return new F(this.$, this.St, this.u, this.Pt);\n\n          default:\n            throw new Error(`Unknown transport: ${t}.`);\n        }\n      }\n\n      Kt(t, e) {\n        return this.transport.onreceive = this.onreceive, this.transport.onclose = t => this.Vt(t), this.transport.connect(t, e);\n      }\n\n      se(t, s, n) {\n        const i = W[t.transport];\n        if (null == i) return this.u.log(e.Debug, `Skipping transport '${t.transport}' because it is not supported by this client.`), new Error(`Skipping transport '${t.transport}' because it is not supported by this client.`);\n        if (!function (t, e) {\n          return !t || 0 != (e & t);\n        }(s, i)) return this.u.log(e.Debug, `Skipping transport '${W[i]}' because it was disabled by the client.`), new h(`'${W[i]}' is disabled by the client.`, i);\n        if (!(t.transferFormats.map(t => O[t]).indexOf(n) >= 0)) return this.u.log(e.Debug, `Skipping transport '${W[i]}' because it does not support the requested transfer format '${O[n]}'.`), new Error(`'${W[i]}' does not support ${O[n]}.`);\n        if (i === W.WebSockets && !this.Pt.WebSocket || i === W.ServerSentEvents && !this.Pt.EventSource) return this.u.log(e.Debug, `Skipping transport '${W[i]}' because it is not supported in your environment.'`), new o(`'${W[i]}' is not supported in your environment.`, i);\n        this.u.log(e.Debug, `Selecting transport '${W[i]}'.`);\n\n        try {\n          return this.Gt(i);\n        } catch (t) {\n          return t;\n        }\n      }\n\n      ee(t) {\n        return t && \"object\" == typeof t && \"connect\" in t;\n      }\n\n      Vt(t) {\n        if (this.u.log(e.Debug, `HttpConnection.stopConnection(${t}) called while in state ${this.q}.`), this.transport = void 0, t = this.zt || t, this.zt = void 0, \"Disconnected\" !== this.q) {\n          if (\"Connecting\" === this.q) throw this.u.log(e.Warning, `Call to HttpConnection.stopConnection(${t}) was ignored because the connection is still in the connecting state.`), new Error(`HttpConnection.stopConnection(${t}) was called while the connection is still in the connecting state.`);\n\n          if (\"Disconnecting\" === this.q && this.jt(), t ? this.u.log(e.Error, `Connection disconnected with error '${t}'.`) : this.u.log(e.Information, \"Connection disconnected.\"), this.Jt && (this.Jt.stop().catch(t => {\n            this.u.log(e.Error, `TransportSendQueue.stop() threw error '${t}'.`);\n          }), this.Jt = void 0), this.connectionId = void 0, this.q = \"Disconnected\", this.M) {\n            this.M = !1;\n\n            try {\n              this.onclose && this.onclose(t);\n            } catch (s) {\n              this.u.log(e.Error, `HttpConnection.onclose(${t}) threw error '${s}'.`);\n            }\n          }\n        } else this.u.log(e.Debug, `Call to HttpConnection.stopConnection(${t}) was ignored because the connection is already in the disconnected state.`);\n      }\n\n      Bt(t) {\n        if (0 === t.lastIndexOf(\"https://\", 0) || 0 === t.lastIndexOf(\"http://\", 0)) return t;\n        if (!g.isBrowser || !window.document) throw new Error(`Cannot resolve '${t}'.`);\n        const s = window.document.createElement(\"a\");\n        return s.href = t, this.u.log(e.Information, `Normalizing '${t}' to '${s.href}'.`), s.href;\n      }\n\n      Zt(t) {\n        const e = t.indexOf(\"?\");\n        let s = t.substring(0, -1 === e ? t.length : e);\n        return \"/\" !== s[s.length - 1] && (s += \"/\"), s += \"negotiate\", s += -1 === e ? \"\" : t.substring(e), -1 === s.indexOf(\"negotiateVersion\") && (s += -1 === e ? \"?\" : \"&\", s += \"negotiateVersion=\" + this.Ft), s;\n      }\n\n    }\n\n    class z {\n      constructor(t) {\n        this.ne = t, this.ie = [], this.re = !0, this.oe = new V(), this.he = new V(), this.ce = this.ae();\n      }\n\n      send(t) {\n        return this.le(t), this.he || (this.he = new V()), this.he.promise;\n      }\n\n      stop() {\n        return this.re = !1, this.oe.resolve(), this.ce;\n      }\n\n      le(t) {\n        if (this.ie.length && typeof this.ie[0] != typeof t) throw new Error(`Expected data to be of type ${typeof this.ie} but was of type ${typeof t}`);\n        this.ie.push(t), this.oe.resolve();\n      }\n\n      async ae() {\n        for (;;) {\n          if (await this.oe.promise, !this.re) {\n            this.he && this.he.reject(\"Connection stopped.\");\n            break;\n          }\n\n          this.oe = new V();\n          const t = this.he;\n          this.he = void 0;\n          const e = \"string\" == typeof this.ie[0] ? this.ie.join(\"\") : z.ue(this.ie);\n          this.ie.length = 0;\n\n          try {\n            await this.ne.send(e), t.resolve();\n          } catch (e) {\n            t.reject(e);\n          }\n        }\n      }\n\n      static ue(t) {\n        const e = t.map(t => t.byteLength).reduce((t, e) => t + e),\n              s = new Uint8Array(e);\n        let n = 0;\n\n        for (const e of t) s.set(new Uint8Array(e), n), n += e.byteLength;\n\n        return s.buffer;\n      }\n\n    }\n\n    class V {\n      constructor() {\n        this.promise = new Promise((t, e) => [this.de, this.fe] = [t, e]);\n      }\n\n      resolve() {\n        this.de();\n      }\n\n      reject(t) {\n        this.fe(t);\n      }\n\n    }\n\n    class G {\n      constructor() {\n        this.name = \"json\", this.version = 1, this.transferFormat = O.Text;\n      }\n\n      parseMessages(t, s) {\n        if (\"string\" != typeof t) throw new Error(\"Invalid input for JSON hub protocol. Expected a string.\");\n        if (!t) return [];\n        null === s && (s = f.instance);\n        const n = D.parse(t),\n              i = [];\n\n        for (const t of n) {\n          const n = JSON.parse(t);\n          if (\"number\" != typeof n.type) throw new Error(\"Invalid payload.\");\n\n          switch (n.type) {\n            case A.Invocation:\n              this.pe(n);\n              break;\n\n            case A.StreamItem:\n              this.we(n);\n              break;\n\n            case A.Completion:\n              this.ge(n);\n              break;\n\n            case A.Ping:\n            case A.Close:\n              break;\n\n            default:\n              s.log(e.Information, \"Unknown message type '\" + n.type + \"' ignored.\");\n              continue;\n          }\n\n          i.push(n);\n        }\n\n        return i;\n      }\n\n      writeMessage(t) {\n        return D.write(JSON.stringify(t));\n      }\n\n      pe(t) {\n        this.me(t.target, \"Invalid payload for Invocation message.\"), void 0 !== t.invocationId && this.me(t.invocationId, \"Invalid payload for Invocation message.\");\n      }\n\n      we(t) {\n        if (this.me(t.invocationId, \"Invalid payload for StreamItem message.\"), void 0 === t.item) throw new Error(\"Invalid payload for StreamItem message.\");\n      }\n\n      ge(t) {\n        if (t.result && t.error) throw new Error(\"Invalid payload for Completion message.\");\n        !t.result && t.error && this.me(t.error, \"Invalid payload for Completion message.\"), this.me(t.invocationId, \"Invalid payload for Completion message.\");\n      }\n\n      me(t, e) {\n        if (\"string\" != typeof t || \"\" === t) throw new Error(e);\n      }\n\n    }\n\n    const K = {\n      trace: e.Trace,\n      debug: e.Debug,\n      info: e.Information,\n      information: e.Information,\n      warn: e.Warning,\n      warning: e.Warning,\n      error: e.Error,\n      critical: e.Critical,\n      none: e.None\n    };\n\n    class Q {\n      configureLogging(t) {\n        if (w.isRequired(t, \"logging\"), void 0 !== t.log) this.logger = t;else if (\"string\" == typeof t) {\n          const e = function (t) {\n            const e = K[t.toLowerCase()];\n            if (void 0 !== e) return e;\n            throw new Error(`Unknown log level: ${t}`);\n          }(t);\n\n          this.logger = new E(e);\n        } else this.logger = new E(t);\n        return this;\n      }\n\n      withUrl(t, e) {\n        return w.isRequired(t, \"url\"), w.isNotEmpty(t, \"url\"), this.url = t, this.httpConnectionOptions = \"object\" == typeof e ? { ...this.httpConnectionOptions,\n          ...e\n        } : { ...this.httpConnectionOptions,\n          transport: e\n        }, this;\n      }\n\n      withHubProtocol(t) {\n        return w.isRequired(t, \"protocol\"), this.protocol = t, this;\n      }\n\n      withAutomaticReconnect(t) {\n        if (this.reconnectPolicy) throw new Error(\"A reconnectPolicy has already been set.\");\n        return t ? Array.isArray(t) ? this.reconnectPolicy = new q(t) : this.reconnectPolicy = t : this.reconnectPolicy = new q(), this;\n      }\n\n      build() {\n        const t = this.httpConnectionOptions || {};\n        if (void 0 === t.logger && (t.logger = this.logger), !this.url) throw new Error(\"The 'HubConnectionBuilder.withUrl' method must be called before building the connection.\");\n        const e = new J(this.url, t);\n        return L.create(e, this.logger || f.instance, this.protocol || new G(), this.reconnectPolicy);\n      }\n\n    }\n\n    return Uint8Array.prototype.indexOf || Object.defineProperty(Uint8Array.prototype, \"indexOf\", {\n      value: Array.prototype.indexOf,\n      writable: !0\n    }), Uint8Array.prototype.slice || Object.defineProperty(Uint8Array.prototype, \"slice\", {\n      value: function (t, e) {\n        return new Uint8Array(Array.prototype.slice.call(this, t, e));\n      },\n      writable: !0\n    }), Uint8Array.prototype.forEach || Object.defineProperty(Uint8Array.prototype, \"forEach\", {\n      value: Array.prototype.forEach,\n      writable: !0\n    }), s;\n  })();\n},  true ? module.exports = e() : 0;\n\n//# sourceURL=webpack://vngageStreamLib/./node_modules/@microsoft/signalr/dist/browser/signalr.js?");

/***/ }),

/***/ "./node_modules/ws/browser.js":
/*!************************************!*\
  !*** ./node_modules/ws/browser.js ***!
  \************************************/
/***/ (function(module) {

"use strict";
eval("\n\nmodule.exports = function () {\n  throw new Error(\n    'ws does not work in the browser. Browser clients must use the native ' +\n      'WebSocket object'\n  );\n};\n\n\n//# sourceURL=webpack://vngageStreamLib/./node_modules/ws/browser.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/VngageStream.js");
/******/ 	
/******/ 	return __webpack_exports__;
/******/ })()
;
});