/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define("vngageStreamLib", [], factory);
	else if(typeof exports === 'object')
		exports["vngageStreamLib"] = factory();
	else
		root["vngageStreamLib"] = factory();
})(this, function() {
return /******/ (function() { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./src/StreamConnector.js":
/*!********************************!*\
  !*** ./src/StreamConnector.js ***!
  \********************************/
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__], __WEBPACK_AMD_DEFINE_RESULT__ = (function (require) {\n  'use strict';\n\n  var signalr = __webpack_require__(/*! @microsoft/signalr/dist/browser/signalr */ \"./node_modules/@microsoft/signalr/dist/browser/signalr.js\"),\n      StreamErrors = __webpack_require__(/*! ./StreamErrors */ \"./src/StreamErrors.js\"),\n      StreamUtils = __webpack_require__(/*! ./StreamUtils */ \"./src/StreamUtils.js\"),\n      StreamEventTypes = __webpack_require__(/*! ./StreamEventTypes */ \"./src/StreamEventTypes.js\");\n\n  var machina = null;\n  var reconnectRetryDelay = 3;\n  var resubscribeDelay = 1;\n  var reconnectMaxRetries = 60; // 60 = 3 minutes if reconnectRetryDelay == 3\n\n  var topicStartId = 1;\n\n  var noop = function noop() {};\n\n  var noDebug = {\n    log: noop,\n    warn: noop,\n    error: noop,\n    info: noop\n  };\n  var debug = noDebug;\n  var options = {\n    brokerUrl: null,\n    brokerTransport: 'WebSockets',\n    brokerLogLevel: 'none'\n  };\n  var brokerEventCallbacks = {};\n  var subscriptions = {};\n  var lastSubscribeInvocationId = 0;\n  var brokerConnection = null;\n\n  function initBrokerConnectionFsm(machina) {\n    /*******************************************************************************************\r\n     ** brokerConnection state machine\r\n     * Should probably be broken out from this module...\r\n     *******************************************************************************************/\n    brokerConnection = new machina.Fsm({\n      initialize: function initialize() {\n        this.connection = null;\n        this.reconnectCounter = 0;\n      },\n      initialState: 'disconnected',\n      states: {\n        disconnected: {\n          _onEnter: function _onEnter() {\n            debug.log('FSM: disconnected._onEnter()');\n            this.connection = null;\n          },\n          connect: function connect() {\n            this.transition('connecting');\n          }\n        },\n        connecting: {\n          _onEnter: function _onEnter() {\n            debug.log('FSM: connecting._onEnter()');\n\n            _connect();\n          },\n          connection_ok: function connection_ok(connection) {\n            this.connection = connection;\n            this.transition('connected');\n          },\n          connection_failed: function connection_failed(err) {\n            this.transition('disconnected');\n          },\n          disconnect: function disconnect() {\n            this.transition('disconnecting');\n          }\n        },\n        connected: {\n          _onEnter: function _onEnter() {\n            debug.log('FSM: connected._onEnter()');\n          },\n          connection_failed: function connection_failed() {\n            // Broker connection closed in \"connected\"-state - try to auto-reconnect to broker...\n            if (brokerEventCallbacks && typeof brokerEventCallbacks.onConnectionFailed === 'function') {\n              brokerEventCallbacks.onConnectionFailed('connection failed');\n            }\n\n            this.connection = null;\n            this.reconnectCounter = 0;\n            this.transition('reconnect_wait');\n          },\n          disconnect: function disconnect() {\n            this.transition('disconnecting');\n          }\n        },\n        reconnect_wait: {\n          _onEnter: function _onEnter() {\n            debug.log('FSM: reconnect_wait._onEnter()');\n\n            if (this.reconnectCounter < reconnectMaxRetries) {\n              this.handle('schedule_reconnect');\n            } else {\n              // i.e. don't try to reconnect even once if reconnectMaxRetries <= 0\n              this.handle('reconnection_failed');\n            }\n          },\n          schedule_reconnect: function schedule_reconnect() {\n            debug.log('FSM reconnect_wait.schedule_reconnect(): Reconnecting to broker in ' + reconnectRetryDelay + ' sec...');\n            clearTimeout(this.reconnectTimer); // Just make sure no other reconnects are already scheduled (should not happen, but maybe SignalR's connection.onclose() *could* be fired twice in that case we'd end up here twice before handling the 'reconnect'-action...)\n\n            this.reconnectTimer = setTimeout(function () {\n              this.handle('connect');\n            }.bind(this), reconnectRetryDelay * 1000);\n          },\n          connect: function connect() {\n            this.transition('reconnecting');\n          },\n          disconnect: function disconnect() {\n            this.transition('disconnecting');\n          },\n          reconnection_failed: function reconnection_failed() {\n            this.transition('disconnected');\n          },\n          _onExit: function _onExit() {\n            clearTimeout(this.reconnectTimer);\n          }\n        },\n        reconnecting: {\n          _onEnter: function _onEnter() {\n            debug.log('FSM: reconnecting._onEnter()');\n            this.reconnectCounter++;\n\n            _connect();\n          },\n          connection_ok: function connection_ok(connection) {\n            this.connection = connection;\n            this.transition('connected');\n            reSubscribeAll(); // After successful re-connect, also re-subscribe to all topics! (i.e. different from \"connection_ok\" in the state \"connecting\")\n          },\n          connection_failed: function connection_failed(err) {\n            if (brokerEventCallbacks && typeof brokerEventCallbacks.onConnectionFailed === 'function') {\n              brokerEventCallbacks.onConnectionFailed(err);\n            }\n\n            this.transition('reconnect_wait');\n          },\n          disconnect: function disconnect() {\n            this.transition('disconnecting');\n          }\n        },\n        disconnecting: {\n          _onEnter: function _onEnter() {\n            debug.log('FSM: disconnecting._onEnter()');\n            unSubscribeAll();\n\n            if (!this.connection) {\n              // No connection to stop - fire \"disconnect_ok\"-action at once\n              this.handle('disconnect_ok');\n            } else {\n              this.connection.stop()[\"catch\"](function () {})[\"finally\"](function () {\n                debug.log('connection stopped');\n                this.handle('disconnect_ok');\n              }.bind(this));\n            }\n          },\n          disconnect_ok: function disconnect_ok() {\n            this.transition('disconnected');\n          }\n        }\n      }\n    });\n  }\n  /*******************************************************************************************\r\n   ** Function for connecting (and maintaining connection) to broker\r\n   *******************************************************************************************/\n\n\n  function _connect() {\n    debug.log('_connect: Connecting to broker url: ' + options.brokerUrl);\n    var brokerConnectionOptions;\n\n    switch (options.brokerTransport) {\n      case 'None':\n      case 'Negotiate':\n        brokerConnectionOptions = null;\n        break;\n\n      case 'LongPolling':\n        brokerConnectionOptions = {\n          transport: signalr.HttpTransportType.LongPolling\n        };\n        break;\n\n      case 'ServerSentEvents':\n        brokerConnectionOptions = {\n          transport: signalr.HttpTransportType.ServerSentEvents\n        };\n        break;\n\n      default:\n        // Use WebSockets without negotiation by default... Is this ok? Do we ever want WebSockets *WITH* negotiation?\n        brokerConnectionOptions = {\n          skipNegotiation: true,\n          transport: signalr.HttpTransportType.WebSockets\n        };\n    }\n\n    var hubConnectionBuilder = new signalr.HubConnectionBuilder().withUrl(options.brokerUrl, brokerConnectionOptions).configureLogging(options.brokerLogLevel).withAutomaticReconnect([0, 500, 3000, 5000, 10000]);\n    var connection = hubConnectionBuilder.build();\n    connection.onreconnecting(function (err) {\n      debug.warn('_connect: Broker connection onreconnecting:', err, connection.connectionState, connection.receivedHandshakeResponse);\n      unSubscribeAll();\n    });\n    connection.onreconnected(function () {\n      debug.warn('_connect: Broker connection onreconnected:', connection.connectionState, connection.receivedHandshakeResponse);\n      reSubscribeAll();\n    });\n    connection.onclose(function (err) {\n      debug.log('_connect: Broker connection closed:', err, connection.connectionState, connection.receivedHandshakeResponse);\n      brokerConnection.handle('connection_failed');\n    }); // Start the connection...\n\n    connection.start().then(function () {\n      debug.log('_connect: Broker connection.start() successful:', connection, connection.connectionState, connection.receivedHandshakeResponse);\n\n      if (brokerEventCallbacks && typeof brokerEventCallbacks.onConnectionStarted === 'function') {\n        brokerEventCallbacks.onConnectionStarted(connection);\n      }\n\n      brokerConnection.handle('connection_ok', connection);\n      /*\t\t\tsetTimeout(function() {\r\n      \t\t\t\t// Due to SignalR-lib stupidity: Do not try to handle \"connection_ok\" immediately, but in a setTimeout() (in antoher thread)\r\n      \t\t\t\t// The broker will accept the connection but immediately disconnect on e.g. an invalid session\r\n      \t\t\t\t// If we handle \"connection_ok\" immediately, the brokerConnection-FSM will think we're properly connected...\r\n      \t\t\t\t// But if brokerConnection.handle('connection_ok', connection) is called in a setTimeout(), the connection.onclose()-handler will be called first.\r\n      \t\t\t\t// CAN WE RELY ON THIS?!?\r\n      \t\t\t\tbrokerConnection.handle('connection_ok', connection);\r\n      \t\t\t}, 0);*/\n    }, function (err) {\n      debug.log('_connect: Broker connection.start() error: ', err, connection, connection.connectionState);\n      brokerConnection.handle('connection_failed', err);\n    });\n  }\n\n  function isConnected() {\n    return brokerConnection.state === 'connected';\n  }\n\n  function isDisconnected() {\n    return brokerConnection.state === 'disconnected';\n  }\n\n  function connectToBroker() {\n    return new Promise(function (resolve, reject) {\n      if (isConnected()) {\n        // Already connected. Resolve with brokerConnection.connection\n        resolve(brokerConnection.connection);\n      } else {\n        // Not connected. Hook up a state transition-listener to monitor brokerConnection state changes...\n        var transitionListener = brokerConnection.on('transition', function (data) {\n          if (data.toState === 'connected') {\n            // Succesfully connected: Resolve and stop listening\n            resolve(brokerConnection.connection);\n            transitionListener.off();\n          } else if (data.toState === 'disconnected' || data.toState === 'reconnect_wait') {\n            // Transitioned to \"disconnected\": Reject and stop listening\n            reject();\n            transitionListener.off();\n          }\n        }); // Try to connect...\n        // Note: The \"connect\"-action will only be effective in states \"disconnected\" and \"reconnect_wait\".\n        // In all other states, we should soon end up in either \"connected\", \"disconnected\" or \"reconnect_wait\" very soon anyway\n\n        brokerConnection.handle('connect');\n      }\n    });\n  }\n\n  function disconnectFromBroker() {\n    return new Promise(function (resolve, reject) {\n      if (brokerConnection.state === 'disconnected') {\n        // Already disconnected. Resolve\n        resolve();\n      } // Not disconnected. Hook up a state transition-listener to monitor brokerConnection state changes...\n\n\n      var disconnectedTransitionListener = brokerConnection.on('transition', function (data) {\n        if (data.toState === 'disconnected') {\n          // Succesfully disconnected: Resolve and stop listening\n          resolve();\n          disconnectedTransitionListener.off();\n        }\n      }); // Try to disconnect...\n\n      brokerConnection.handle('disconnect');\n    });\n  }\n\n  function reConnectToBroker() {\n    return disconnectFromBroker().then(function () {\n      return connectToBroker().then(function (connection) {\n        reSubscribeAll().then(function (subscriptions) {\n          // Don't care about the result of this...\n          debug.log('reConnectToBroker: all topics re-subscribed:', subscriptions);\n        });\n        return Promise.resolve(connection); // Resolve with connection (reSubscribeAll() resolves with subscriptions, and that's probably not what the caller of reConnectToBroker() expects)\n      });\n    });\n  }\n\n  function getConnection() {\n    // Todo: Do we need more checks that connection is in the right state?\n    return connectToBroker();\n  }\n  /*******************************************************************************************\r\n   ** Functions for addig and remoing topic subscriptions\r\n   *******************************************************************************************/\n\n\n  function addSubscription(subscription, timeout) {\n    debug.log('addSubscription:', subscription, timeout);\n    unsubscribeToTopic(subscription.topic);\n    subscriptions[subscription.topic] = subscription; // Subscribe to topic, skip retrying on failures (better to reject and let caller handle it)...\n    // If a \"timeout\" is specified, reject if it's taking too long...\n\n    if (timeout) {\n      return StreamUtils.promiseTimeout(getAndSubscribeToTopic(subscription.topic), timeout);\n    } else {\n      return getAndSubscribeToTopic(subscription.topic);\n    }\n  }\n\n  function removeTopicSubscription(topic) {\n    debug.log('removeTopicSubscription:', topic);\n\n    if (subscriptions[topic]) {\n      unsubscribeToTopic(topic);\n      delete subscriptions[topic];\n    }\n\n    if (StreamUtils.isEmpty(subscriptions)) {\n      // No more active subscriptions - disconnect from broker\n      debug.log('No more subscriptions - disconnecting from broker');\n      disconnectFromBroker();\n    }\n  }\n\n  function reSubscribeAll() {\n    var subscribePromises = [];\n    Object.keys(subscriptions).forEach(function (topic) {\n      debug.log('reSubscribeAll: Re-subscribing to topic: ', topic);\n      subscribePromises.push(getAndSubscribeToTopic(topic, true)[\"catch\"](function (err) {\n        // Catch any errors from _getAndSubscribeToTopic() to prevent Promise.all() below to \"fail-fast\" on errors...\n        debug.warn('reSubscribeAll: Error re-subscribing to topic: \"' + topic + '\"', err);\n      }));\n    });\n    return Promise.all(subscribePromises);\n  }\n\n  function unSubscribeAll() {\n    // Unsubscribe any active subscription...\n    Object.keys(subscriptions).forEach(function (topic) {\n      unsubscribeToTopic(topic);\n    });\n  }\n  /*******************************************************************************************\r\n   ** Functions for getting and subscribing/unsubscribing to any topic\r\n   *******************************************************************************************/\n\n\n  function getTopic(connection, topic, fromId) {\n    // debug.log('getTopic:', topic, 'from:', fromId);\n    var resultArray = [];\n    return new Promise(function (resolve, reject) {\n      connection.stream('Get', topic, fromId).subscribe({\n        next: function next(event) {\n          // debug.log('getTopic Get stream next:', event);\n          resultArray.push(event);\n        },\n        complete: function complete() {\n          // debug.log('getTopic Get stream complete:', resultArray);\n          resolve(resultArray);\n        },\n        error: function error(err) {\n          debug.error('getTopic(): Get stream error:', err);\n\n          if (err && typeof err.message === 'string' && err.message.indexOf('HubException: Unauthorized') !== -1) {\n            // Unathorized: Nothing to do but to reject...\n            reject(err);\n          } else {\n            // Other error from hub, try to \"connection.invoke()\" instead of \"connection.stream()\" for backwards compatibility with legacy CommSrv (.NET Core 2)\n            debug.log('getTopic(): Retrying with connection.invoke(\\'Get\\', topic, fromId)');\n            connection.invoke('Get', topic, fromId).then(resolve, reject);\n          }\n        }\n      });\n    });\n  }\n\n  function getAndSubscribeToTopic(topic, keepRetrying) {\n    if (keepRetrying) {\n      return StreamUtils.retryPromiseFunc(_getAndSubscribeToTopic.bind(null, topic), resubscribeDelay * 1000, reconnectMaxRetries, 'abort');\n    } else {\n      return _getAndSubscribeToTopic(topic);\n    }\n  }\n\n  function _getAndSubscribeToTopic(topic) {\n    debug.log('_getAndSubscribeToTopic:', topic);\n    return new Promise(function (resolve, reject) {\n      // Unsubscribe if already subscribing...\n      unsubscribeToTopic(topic);\n      var subscription = subscriptions[topic];\n\n      if (!subscription) {\n        return reject('abort'); // Reject with reason 'abort' to skip retrying...\n      } // Track invocations to _getAndSubscribeToTopic() by subscription.subscribeInvocationId\n\n\n      var currentSubscribeInvocationId = ++lastSubscribeInvocationId;\n      subscription.subscribeInvocationId = currentSubscribeInvocationId;\n      debug.log('_getAndSubscribeToTopic currentSubscribeInvocationId:', currentSubscribeInvocationId);\n      getConnection().then(function (connection) {\n        debug.log('_getAndSubscribeToTopic: gotConnection:', connection); // Important: Look up the subscription for this topic again - it may have changed while waiting for connection!\n\n        subscription = subscriptions[topic];\n\n        if (subscription.subscribeInvocationId !== currentSubscribeInvocationId) {\n          debug.log('_getAndSubscribeToTopic: A newer subscription to this topic has been invoked while waiting for connection - abort this one...');\n          return reject('abort'); // Reject with reason 'abort' to skip retrying...\n        }\n\n        if (subscription.subscriberRef) {\n          // Stop any existing subscription on this topic if exists (should not happen, as we have already called unsubscribeToTopic() before connecting, and if we get here we should be in the same invocation)\n          unsubscribeToTopic(topic);\n        }\n\n        var getFullTopicState = subscription.lastReceivedEventId < 0 && (typeof subscription.fromEventId !== 'number' || subscription.fromEventId === topicStartId); // No events received yet, and no \"fromEventId\" specified (different from \"topicStartId\") => We want the full topic state!\n\n        var fromEventId = getFullTopicState ? topicStartId : subscription.lastReceivedEventId >= 0 ? subscription.lastReceivedEventId + 1 : subscription.fromEventId;\n        var getTopicPromise;\n\n        if (options.streamingSubscribeOnly) {\n          getTopicPromise = Promise.resolve([]);\n        } else {\n          debug.log('_getAndSubscribeToTopic: \\'Get\\' topic: ', topic, ' from: ', fromEventId, 'invocationId:', currentSubscribeInvocationId);\n          getTopicPromise = getTopic(connection, subscription.topic, fromEventId);\n        }\n\n        getTopicPromise.then(function (eventsArray) {\n          // Important: Look up the subscription for this topic again - it may have changed while waiting for connection!\n          subscription = subscriptions[topic];\n\n          if (subscription.subscribeInvocationId !== currentSubscribeInvocationId) {\n            debug.log('_getAndSubscribeToTopic: A newer subscription to this topic has been invoked while waiting for getTopic() - abort this one...');\n            return reject('abort'); // Reject with reason 'abort' to skip retrying...\n          }\n\n          if (eventsArray && Array.isArray(eventsArray) && eventsArray.length) {\n            // Handle events from broker 'Get' (if any exists)\n            debug.log('_getAndSubscribeToTopic: Got topic eventsArray:', eventsArray, 'invocationId:', currentSubscribeInvocationId);\n\n            try {\n              // Filter eventsArray to remove duplicates (which is a recoverable error condition)\n              // Or throw a StreamErrors.TOPIC_STREAM_OUT_OF_ORDER if expected event(s) are missing (which is an unrecoverable error)\n              eventsArray = eventsArray.filter(function (event) {\n                if (event.id < subscription.lastReceivedEventId + 1) {\n                  debug.error('Error: Broker event id in response-array from \\'Get\\' out of order (old event received). Expected ' + (subscription.lastReceivedEventId + 1) + ', received ' + event.id, event, 'invocationId:', currentSubscribeInvocationId);\n                  debug.log('Skipping event...');\n                  return false; // return false to skip by filter\n                } else if (subscription.lastReceivedEventId != -1 && event.id > subscription.lastReceivedEventId + 1) {\n                  debug.error('Error: Broker event id in response-array from \\'Get\\' out of order (gap - event(s) missing). Expected ' + (subscription.lastReceivedEventId + 1) + ', received ' + event.id, event, 'invocationId:', currentSubscribeInvocationId);\n                  throw StreamErrors.TOPIC_STREAM_OUT_OF_ORDER; // throw exception to abort (unrecoverable error)\n                }\n\n                subscription.lastReceivedEventId = event.id;\n                return true; // All ok, return true to include event\n              });\n              var receivedAs = getFullTopicState ? StreamEventTypes.STATE : StreamEventTypes.STREAMED_CHUNK;\n\n              var preparedEventsData = _prepareEventsData(eventsArray, receivedAs, 'invocationId: ' + currentSubscribeInvocationId);\n\n              subscription.onDataReceived(preparedEventsData.eventsArray, preparedEventsData.receivedAs);\n            } catch (e) {\n              if (e === StreamErrors.TOPIC_STREAM_OUT_OF_ORDER) {\n                debug.log('Unrecoverable error: Re-subscribing to topic...');\n              } else {\n                debug.log('Unknown error:', e);\n              }\n\n              getAndSubscribeToTopic(topic).then(resolve, reject); // Try to resubscribe, but skip retrying on failures...\n\n              return;\n            }\n\n            fromEventId = subscription.lastReceivedEventId + 1;\n          }\n\n          try {\n            debug.log('_getAndSubscribeToTopic: \\'Subscribe\\' to topic: ', topic, ' from id: ', fromEventId, 'invocationId:', currentSubscribeInvocationId);\n            subscription.subscriberRef = connection.stream('Subscribe', topic, fromEventId) // subscription.subscriberRef = connection.stream('Subscribe', '1'+topic, fromEventId) // Test invalid topic\n            .subscribe({\n              next: function next(event) {\n                // Handle events from broker 'Subscribe'\n                if (event.id < subscription.lastReceivedEventId + 1) {\n                  debug.error('Error: Broker event id in \\'Subscribe\\'-stream out of order (old event received). Expected ' + (subscription.lastReceivedEventId + 1) + ', received ' + event.id, event, 'invocationId:', currentSubscribeInvocationId);\n                  debug.log('Skipping event...');\n                  return;\n                } else if (subscription.lastReceivedEventId != -1 && event.id > subscription.lastReceivedEventId + 1) {\n                  debug.error('Error: Broker event id in \\'Subscribe\\'-stream out of order: (gap - event(s) missing). Expected ' + (subscription.lastReceivedEventId + 1) + ', received ' + event.id, event, 'invocationId:', currentSubscribeInvocationId);\n                  debug.log('Re-subscribing to topic...');\n                  getAndSubscribeToTopic(topic, true)[\"catch\"](function (err) {\n                    debug.log('Error resubscribing to topic (subscribe, stream out of order, gap)', err);\n                  });\n                  return;\n                }\n\n                var preparedEventsData = _prepareEventsData(event, StreamEventTypes.STREAM, 'invocationId: ' + currentSubscribeInvocationId);\n\n                subscription.onDataReceived(preparedEventsData.eventsArray, preparedEventsData.receivedAs);\n                subscription.lastReceivedEventId = event.id;\n              },\n              complete: function complete() {\n                debug.log('Stream completed on topic \"' + topic + '\"', 'invocationId:', currentSubscribeInvocationId);\n              },\n              error: function error(err) {\n                debug.error('Stream error on topic \"' + topic + '\":', err, connection, connection.connectionState, 'invocationId:', currentSubscribeInvocationId);\n                /*\r\n                \t\t\t\t\t\t\t\t\tif (useSignalRv3) {\r\n                \t\t\t\t\t\t\t\t\t\t// SignalRv3 detected: Do nothing (let auto-reconnect take care of the business)\r\n                \t\t\t\t\t\t\t\t\t\t// TODO: SOME stream errors should be handled here on signalr v3, e.g. \"slow consumer\", etc\r\n                */\n\n                debug.log('SignalR v3: Do nothing (let auto-reconnect take care of business)');\n                /*\r\n                \t\t\t\t\t\t\t\t\t\treturn;\r\n                \t\t\t\t\t\t\t\t\t}\r\n                \t\t\t\t\t\t\t\t\tdebug.log('Re-subscribing...');\r\n                \t\t\t\t\t\t\t\t\tsetTimeout(function() {\r\n                \t\t\t\t\t\t\t\t\t\tgetAndSubscribeToTopic(topic, true).catch(function (err) {\r\n                \t\t\t\t\t\t\t\t\t\t\tdebug.log('Error resubscribing to topic (subscribe, error)', err, connection, connection.connectionState);\r\n                \t\t\t\t\t\t\t\t\t\t});\r\n                \t\t\t\t\t\t\t\t\t}, resubscribeDelay * 1000);\r\n                */\n              }\n            }); // After successful subscription: Call onSubscriptionStart()-hook in the subscription, if it exists\n\n            if (subscription.onSubscriptionStart) {\n              subscription.onSubscriptionStart();\n            }\n\n            resolve(subscription.subscriberRef);\n          } catch (err) {\n            debug.error('Exception subscribing to topic \"' + topic + '\":', err, 'invocationId:', currentSubscribeInvocationId, connection, connection.connectionState);\n            reject({\n              errorCode: StreamErrors.TOPIC_SUBSCRIBE_ERROR,\n              errorMessage: 'Error subscribing to topic: ' + topic,\n              err: err\n            });\n          }\n        })[\"catch\"](function (err) {\n          // getTopic() rejected or unrecoverable reSubscribe from eventsArray array out of order\n          debug.error('_getAndSubscribeToTopic: Exception from getTopic(\"' + subscription.topic + '\"):', err, 'invocationId:', currentSubscribeInvocationId, connection, connection.connectionState);\n          reject({\n            errorCode: StreamErrors.TOPIC_GET_ERROR,\n            errorMessage: 'Error getting topic: ' + subscription.topic,\n            err: err\n          });\n        });\n      }, function (err) {\n        debug.error('_getAndSubscribeToTopic: Exception from getConnection(\"' + subscription.topic + '\"):', err, 'invocationId:', currentSubscribeInvocationId);\n        reject({\n          errorCode: StreamErrors.BROKER_CONNECT_ERROR,\n          errorMessage: 'Could not connect to broker (from _getAndSubscribeToTopic)',\n          err: err\n        });\n      });\n    });\n  }\n\n  function unsubscribeToTopic(topic) {\n    var subscription = subscriptions[topic];\n\n    if (subscription) {\n      if (subscription.subscriberRef) {\n        debug.log('unsubscribeToTopic:', topic); // Before unsubscribing an active subscription: Call onSubscriptionEnd()-hooks in the subscription, if it exists\n\n        if (subscription.onSubscriptionEnd) {\n          subscription.onSubscriptionEnd();\n        }\n\n        try {\n          subscription.subscriberRef.dispose();\n          debug.log('topic subscriber disposed');\n        } catch (e) {\n          debug.log('Exception disposing topic subscriber:', e);\n        }\n\n        subscription.subscriberRef = null;\n      }\n    }\n  }\n\n  function publishTopicWhenConnected(topic, data) {\n    return getConnection().then(function (connection) {\n      try {\n        return connection.invoke('Publish', topic, data);\n      } catch (e) {\n        debug.log('Exception in publishTopic: ', e);\n        return Promise.reject(e);\n      }\n    });\n  }\n\n  function publishTopicIfConnected(topic, data) {\n    if (!isConnected()) {\n      return Promise.reject('Not connetced');\n    }\n\n    return publishTopicWhenConnected(topic, data);\n  }\n\n  function getSubscriptions() {\n    return subscriptions;\n  }\n  /*******************************************************************************************\r\n   ** Util-function to prepare the received events before calling the subscription.onDataReceived() hook\r\n   *******************************************************************************************/\n\n\n  function _prepareEventsData(events, receivedAs, extraLoggingArg) {\n    // Incoming data from broker\n    // \"events\" contains the actual event data\n    // \t\tIt can be an array (from 'Get' topic, together with \"receivedAs\" = StreamEventTypes.STATE or StreamEventTypes.STREAMED_CHUNK)\n    // \t\tor a single event object (together with \"receivedAs\" = StreamEventTypes.STREAM)\n    // \"receivedAs\" can be StreamEventTypes.STATE, StreamEventTypes.STREAM or StreamEventTypes.STREAMED_CHUNK depending on how the data was received\n    //\t\tStreamEventTypes.STATE means than \"events\" contains the full topic state as an array\n    // \t\tStreamEventTypes.STREAMED_CHUNK means than \"events\" contains an events-array, but it does not begin with topic start, so it's not a full state (but rather a \"chunk\" of streamed data in the middle of the topic)\n    // \t\tStreamEventTypes.STREAM means than \"events\" contains a single, streamed event object (from connection.stream('Subscribe', ...)\n    // \"extraLoggingArg\" (optional) will be added to the debug log\n    // Assemble debug data...\n    var debugData = [];\n\n    if (receivedAs === StreamEventTypes.STREAM) {\n      debugData.push('conversationData STREAM-event:', events.data.type + (events.data.type === 'conversationMessage' ? ' (' + events.data.messageType + ')' : ''));\n    } else if (receivedAs === StreamEventTypes.STREAMED_CHUNK) {\n      debugData.push('conversationData STREAMED_CHUNK-array:');\n    } else if (receivedAs === StreamEventTypes.STATE) {\n      debugData.push('conversationData STATE-array:');\n    } else {\n      debugData.push('conversationData (receivedAs = unknown)):');\n    }\n\n    debugData.push(events, extraLoggingArg);\n    debug.log.apply(null, debugData);\n    return {\n      eventsArray: receivedAs === StreamEventTypes.STREAM ? [events] : events,\n      receivedAs: receivedAs\n    };\n  }\n  /*******************************************************************************************\r\n   ** Init function to configure the StreamConnector\r\n   *\r\n   *   brokerUrl \t\t= URL to CommSrv broker endpoint\r\n   *   \tNote: It should include sessionId as query parameter (will probably be re-designed in the future)\r\n   *\r\n   *   streamOptions\t= Config object for signalR and related behavior\r\n   *    \tstreamOptions.brokerTransport (optional, default 'WebSockets'):\r\n   *      \tOne of: 'None' | 'Negotiate' | 'WebSockets' | 'LongPolling' | 'ServerSentEvents'\r\n   *      streamOptions.brokerLogLevel (optional, default 'none'):\r\n   *        \tOne of: 'trace' | 'debug' | 'info' | 'warn' | 'error' | 'critical' | 'none'\r\n   *      streamOptions.streamingSubscribeOnly (optional, default false):\r\n   *      \tIf true, topic history/state is not fetched using 'Get' (i.e. everything is streamed using 'Subscribe' only)\r\n   *\r\n   *   eventHandlers\t= Object containing (optional) event handler hook functions, e.g.\r\n   *    \t{\r\n   *    \t\tonConnectionStarted = function (connection) { // Do something on broker connection started...  },\r\n   *    \t\tonConnectionFailed = function (connection) { // Do something on broker connection failed... },\r\n   *\t\t}\r\n   *\r\n   *\t dependencyLibs\t= Object containing dependency libraries (for now, only 'machina')\r\n   *\t \tThe \"machina\" library needs to be injected at runtime (Visitor already uses it, so we don't want to bundle it twice)\r\n   *\t\t{\r\n   * \t\t\tmachina: <required \"machina\" npm-module>\r\n   * \t\t}\r\n   *\r\n   *\t initDebug\t\t= Optional object containing debug functions (default will be noop()), e.g.:\r\n   *\t \t{\r\n   * \t\t\tlog: function () { ... },\r\n   * \t\t\twarn: function () { ... },\r\n   * \t\t\terror: function () { ... },\r\n   * \t\t\tinfo: function () { ... },\r\n   *\t \t}\r\n   *******************************************************************************************/\n\n\n  var init = function init(brokerUrl, streamOptions, eventHandlers, dependencyLibs, initDebug) {\n    if (!machina) {\n      machina = dependencyLibs.machina;\n      initBrokerConnectionFsm(machina);\n    }\n\n    streamOptions = streamOptions || {};\n    initDebug = initDebug || noDebug;\n    streamOptions.brokerTransport = streamOptions.brokerTransport || 'WebSockets';\n    streamOptions.brokerLogLevel = streamOptions.brokerLogLevel || 'none';\n    streamOptions.streamingSubscribeOnly = streamOptions.streamingSubscribeOnly || false;\n\n    if (brokerUrl && brokerUrl !== options.brokerUrl || streamOptions.brokerTransport !== options.brokerTransport || streamOptions.brokerLogLevel !== options.brokerLogLevel) {\n      debug = initDebug;\n      options.brokerUrl = brokerUrl;\n      options.brokerTransport = streamOptions.brokerTransport;\n      options.brokerLogLevel = streamOptions.brokerLogLevel;\n      options.streamingSubscribeOnly = streamOptions.streamingSubscribeOnly;\n      brokerEventCallbacks = eventHandlers;\n      debug.log('Initializing StreamConnector');\n      debug.log('SignalR client lib version:', signalr.VERSION);\n\n      if (!isDisconnected()) {\n        // If we have an active connection: Re-connect to broker with the new brokerUrl...\n        reConnectToBroker().then(function (connection) {\n          debug.log('StreamConnector: broker config changed: Successfully re-connected to broker', connection);\n        }, function (err) {\n          debug.error('StreamConnector: broker config changed: Error re-connecting to broker', err);\n        });\n      }\n    }\n  };\n\n  return {\n    _signalr: signalr,\n    // Expose the signalr lib  - mainly for debugging...\n    init: init,\n    getSubscriptions: getSubscriptions,\n    addSubscription: addSubscription,\n    removeTopicSubscription: removeTopicSubscription,\n    publishTopicIfConnected: publishTopicIfConnected\n  };\n}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n//# sourceURL=webpack://vngageStreamLib/./src/StreamConnector.js?");

/***/ }),

/***/ "./src/StreamConnector_deps.js":
/*!*************************************!*\
  !*** ./src/StreamConnector_deps.js ***!
  \*************************************/
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__], __WEBPACK_AMD_DEFINE_RESULT__ = (function (require) {\n  var StreamConnector = __webpack_require__(/*! ./StreamConnector */ \"./src/StreamConnector.js\");\n\n  return {\n    _signalr: StreamConnector._signalr,\n    // Expose the signalr lib  - mainly for debugging...\n    init: StreamConnector.init,\n    getSubscriptions: StreamConnector.getSubscriptions,\n    addSubscription: StreamConnector.addSubscription,\n    removeTopicSubscription: StreamConnector.removeTopicSubscription,\n    publishTopicIfConnected: StreamConnector.publishTopicIfConnected\n  };\n}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n//# sourceURL=webpack://vngageStreamLib/./src/StreamConnector_deps.js?");

/***/ }),

/***/ "./src/StreamErrors.js":
/*!*****************************!*\
  !*** ./src/StreamErrors.js ***!
  \*****************************/
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_RESULT__ = (function () {\n  'use strict';\n\n  return {\n    BROKER_DISCONNECTED: 0,\n    BROKER_CONNECT_ERROR: 1,\n    BROKER_RECONNECT_ATTEMPT_ERROR: 2,\n    BROKER_RECONNECT_FATAL_ERROR: 3,\n    BROKER_INVALID_CONNECTION_ERROR: 4,\n    TOPIC_GET_ERROR: 5,\n    TOPIC_SUBSCRIBE_ERROR: 6,\n    TOPIC_STREAM_OUT_OF_ORDER: 7\n  };\n}).call(exports, __webpack_require__, exports, module),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n//# sourceURL=webpack://vngageStreamLib/./src/StreamErrors.js?");

/***/ }),

/***/ "./src/StreamEventTypes.js":
/*!*********************************!*\
  !*** ./src/StreamEventTypes.js ***!
  \*********************************/
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_RESULT__ = (function () {\n  'use strict';\n\n  return {\n    STATE: 'state',\n    STREAM: 'stream',\n    STREAMED_CHUNK: 'chunk'\n  };\n}).call(exports, __webpack_require__, exports, module),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n//# sourceURL=webpack://vngageStreamLib/./src/StreamEventTypes.js?");

/***/ }),

/***/ "./src/StreamUtils.js":
/*!****************************!*\
  !*** ./src/StreamUtils.js ***!
  \****************************/
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_RESULT__ = (function (require) {\n  'use strict';\n\n  function wait(ms) {\n    return new Promise(function (r) {\n      return setTimeout(r, ms);\n    });\n  }\n\n  function retryPromiseFunc(promisedFunction, delay, maxRetries, abortReason) {\n    // This function retries \"promisedFunction\" (a function which is expected to return a Promise) until it's reloved, or until retried \"maxRetries\" number of times or until rejected with reason == \"abortReason\"...\n    return new Promise(function (resolve, reject) {\n      return promisedFunction().then(resolve)[\"catch\"](function (reason) {\n        if (maxRetries - 1 > 0 && reason !== abortReason) {\n          return wait(delay).then(retryPromiseFunc.bind(null, promisedFunction, delay, maxRetries - 1, abortReason)).then(resolve)[\"catch\"](reject);\n        }\n\n        return reject(reason);\n      });\n    });\n  }\n\n  function promiseTimeout(promise, ms) {\n    // Create a promise that rejects in <ms> milliseconds\n    // Returns a race between our timeout and the passed in promise\n    return Promise.race([promise, new Promise(function (resolve, reject) {\n      wait(ms).then(reject.bind(null, 'timeout'));\n    })]);\n  }\n\n  function isEmpty(obj) {\n    for (var prop in obj) {\n      if (obj.hasOwnProperty(prop)) return false;\n    }\n\n    return true;\n  } // From: https://gomakethings.com/merging-objects-with-vanilla-javascript/\n\n\n  var extend = function extend() {\n    // Variables\n    var extended = {};\n    var deep = false;\n    var i = 0; // Check if a deep merge\n\n    if (typeof arguments[0] === 'boolean') {\n      deep = arguments[0];\n      i++;\n    } // Merge the object into the extended object\n\n\n    var merge = function merge(obj) {\n      for (var prop in obj) {\n        if (obj.hasOwnProperty(prop)) {\n          if (deep && Object.prototype.toString.call(obj[prop]) === '[object Object]') {\n            // If we're doing a deep merge and the property is an object\n            extended[prop] = extend(true, extended[prop], obj[prop]);\n          } else {\n            // Otherwise, do a regular merge\n            extended[prop] = obj[prop];\n          }\n        }\n      }\n    }; // Loop through each object and conduct a merge\n\n\n    for (; i < arguments.length; i++) {\n      merge(arguments[i]);\n    }\n\n    return extended;\n  };\n\n  return {\n    retryPromiseFunc: retryPromiseFunc,\n    promiseTimeout: promiseTimeout,\n    isEmpty: isEmpty,\n    extend: extend\n  };\n}).call(exports, __webpack_require__, exports, module),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n//# sourceURL=webpack://vngageStreamLib/./src/StreamUtils.js?");

/***/ }),

/***/ "./src/Subscription.js":
/*!*****************************!*\
  !*** ./src/Subscription.js ***!
  \*****************************/
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_RESULT__;// Simple module to create a new \"subscription\"-object to subscribe to events from streaming broker (via SignalR)\n// It will add and init correct default properties for usage by StreamConnector\n// Add overridden and/or custom props as the arg to extend()\n!(__WEBPACK_AMD_DEFINE_RESULT__ = (function (require) {\n  'use strict';\n\n  var StreamUtils = __webpack_require__(/*! ./StreamUtils */ \"./src/StreamUtils.js\");\n\n  var defaultSubscriptionProps = {\n    topic: '',\n    fromEventId: null,\n    subscribeInvocationId: -1,\n    subscriberRef: null,\n    lastReceivedEventId: -1,\n    onDataReceived: function onDataReceived() {},\n    onSubscriptionStart: null,\n    onSubscriptionEnd: null\n  };\n  return {\n    extend: function extend(props) {\n      return StreamUtils.extend({}, defaultSubscriptionProps, props);\n    }\n  };\n}).call(exports, __webpack_require__, exports, module),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n//# sourceURL=webpack://vngageStreamLib/./src/Subscription.js?");

/***/ }),

/***/ "./src/VngageStream_deps.js":
/*!**********************************!*\
  !*** ./src/VngageStream_deps.js ***!
  \**********************************/
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_RESULT__ = (function (require) {\n  'use strict';\n\n  var StreamEventTypes = __webpack_require__(/*! ./StreamEventTypes */ \"./src/StreamEventTypes.js\"),\n      StreamErrors = __webpack_require__(/*! ./StreamErrors */ \"./src/StreamErrors.js\"),\n      StreamConnector = __webpack_require__(/*! ./StreamConnector_deps */ \"./src/StreamConnector_deps.js\"),\n      Subscription = __webpack_require__(/*! ./Subscription */ \"./src/Subscription.js\");\n\n  return {\n    StreamEventTypes: StreamEventTypes,\n    // Is this needed? Or could it be required/imported directly?\n    StreamErrors: StreamErrors,\n    // Is this needed? Or could it be required/imported directly?\n    StreamConnector: StreamConnector,\n    Subscription: Subscription\n  };\n}).call(exports, __webpack_require__, exports, module),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n//# sourceURL=webpack://vngageStreamLib/./src/VngageStream_deps.js?");

/***/ }),

/***/ "./node_modules/@microsoft/signalr/dist/browser/signalr.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@microsoft/signalr/dist/browser/signalr.js ***!
  \*****************************************************************/
/***/ (function(module, exports, __webpack_require__) {

eval("/* module decorator */ module = __webpack_require__.nmd(module);\nvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }\n\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _iterableToArray(iter) { if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter); }\n\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }\n\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\n\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== \"undefined\" && arr[Symbol.iterator] || arr[\"@@iterator\"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e13) { throw _e13; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e14) { didErr = true; err = _e14; }, f: function f() { try { if (!normalCompletion && it[\"return\"] != null) it[\"return\"](); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }\n\nfunction _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err); } _next(undefined); }); }; }\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, \"prototype\", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } else if (call !== void 0) { throw new TypeError(\"Derived constructors may only return object or undefined\"); } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _wrapNativeSuper(Class) { var _cache = typeof Map === \"function\" ? new Map() : undefined; _wrapNativeSuper = function _wrapNativeSuper(Class) { if (Class === null || !_isNativeFunction(Class)) return Class; if (typeof Class !== \"function\") { throw new TypeError(\"Super expression must either be null or a function\"); } if (typeof _cache !== \"undefined\") { if (_cache.has(Class)) return _cache.get(Class); _cache.set(Class, Wrapper); } function Wrapper() { return _construct(Class, arguments, _getPrototypeOf(this).constructor); } Wrapper.prototype = Object.create(Class.prototype, { constructor: { value: Wrapper, enumerable: false, writable: true, configurable: true } }); return _setPrototypeOf(Wrapper, Class); }; return _wrapNativeSuper(Class); }\n\nfunction _construct(Parent, args, Class) { if (_isNativeReflectConstruct()) { _construct = Reflect.construct; } else { _construct = function _construct(Parent, args, Class) { var a = [null]; a.push.apply(a, args); var Constructor = Function.bind.apply(Parent, a); var instance = new Constructor(); if (Class) _setPrototypeOf(instance, Class.prototype); return instance; }; } return _construct.apply(null, arguments); }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _isNativeFunction(fn) { return Function.toString.call(fn).indexOf(\"[native code]\") !== -1; }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, _typeof(obj); }\n\nvar t, e;\nt = self, e = function e() {\n  return function () {\n    var t = {\n      d: function d(e, s) {\n        for (var n in s) {\n          t.o(s, n) && !t.o(e, n) && Object.defineProperty(e, n, {\n            enumerable: !0,\n            get: s[n]\n          });\n        }\n      }\n    };\n    t.g = function () {\n      if (\"object\" == (typeof globalThis === \"undefined\" ? \"undefined\" : _typeof(globalThis))) return globalThis;\n\n      try {\n        return this || new Function(\"return this\")();\n      } catch (t) {\n        if (\"object\" == (typeof window === \"undefined\" ? \"undefined\" : _typeof(window))) return window;\n      }\n    }(), t.o = function (t, e) {\n      return Object.prototype.hasOwnProperty.call(t, e);\n    }, t.r = function (t) {\n      \"undefined\" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(t, Symbol.toStringTag, {\n        value: \"Module\"\n      }), Object.defineProperty(t, \"t\", {\n        value: !0\n      });\n    };\n    var e,\n        s = {};\n    t.r(s), t.d(s, {\n      AbortError: function AbortError() {\n        return r;\n      },\n      DefaultHttpClient: function DefaultHttpClient() {\n        return H;\n      },\n      HttpClient: function HttpClient() {\n        return d;\n      },\n      HttpError: function HttpError() {\n        return n;\n      },\n      HttpResponse: function HttpResponse() {\n        return u;\n      },\n      HttpTransportType: function HttpTransportType() {\n        return W;\n      },\n      HubConnection: function HubConnection() {\n        return L;\n      },\n      HubConnectionBuilder: function HubConnectionBuilder() {\n        return Q;\n      },\n      HubConnectionState: function HubConnectionState() {\n        return R;\n      },\n      JsonHubProtocol: function JsonHubProtocol() {\n        return G;\n      },\n      LogLevel: function LogLevel() {\n        return e;\n      },\n      MessageType: function MessageType() {\n        return A;\n      },\n      NullLogger: function NullLogger() {\n        return f;\n      },\n      Subject: function Subject() {\n        return U;\n      },\n      TimeoutError: function TimeoutError() {\n        return i;\n      },\n      TransferFormat: function TransferFormat() {\n        return O;\n      },\n      VERSION: function VERSION() {\n        return p;\n      }\n    });\n\n    var n = /*#__PURE__*/function (_Error) {\n      _inherits(n, _Error);\n\n      var _super = _createSuper(n);\n\n      function n(t, e) {\n        var _this;\n\n        _classCallCheck(this, n);\n\n        var s = (this instanceof n ? this.constructor : void 0).prototype;\n        _this = _super.call(this, \"\".concat(t, \": Status code '\").concat(e, \"'\")), _this.statusCode = e, _this.__proto__ = s;\n        return _this;\n      }\n\n      return _createClass(n);\n    }( /*#__PURE__*/_wrapNativeSuper(Error));\n\n    var i = /*#__PURE__*/function (_Error2) {\n      _inherits(i, _Error2);\n\n      var _super2 = _createSuper(i);\n\n      function i() {\n        var _this2;\n\n        var t = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"A timeout occurred.\";\n\n        _classCallCheck(this, i);\n\n        var e = (this instanceof i ? this.constructor : void 0).prototype;\n        _this2 = _super2.call(this, t), _this2.__proto__ = e;\n        return _this2;\n      }\n\n      return _createClass(i);\n    }( /*#__PURE__*/_wrapNativeSuper(Error));\n\n    var r = /*#__PURE__*/function (_Error3) {\n      _inherits(r, _Error3);\n\n      var _super3 = _createSuper(r);\n\n      function r() {\n        var _this3;\n\n        var t = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"An abort occurred.\";\n\n        _classCallCheck(this, r);\n\n        var e = (this instanceof r ? this.constructor : void 0).prototype;\n        _this3 = _super3.call(this, t), _this3.__proto__ = e;\n        return _this3;\n      }\n\n      return _createClass(r);\n    }( /*#__PURE__*/_wrapNativeSuper(Error));\n\n    var o = /*#__PURE__*/function (_Error4) {\n      _inherits(o, _Error4);\n\n      var _super4 = _createSuper(o);\n\n      function o(t, e) {\n        var _this4;\n\n        _classCallCheck(this, o);\n\n        var s = (this instanceof o ? this.constructor : void 0).prototype;\n        _this4 = _super4.call(this, t), _this4.transport = e, _this4.errorType = \"UnsupportedTransportError\", _this4.__proto__ = s;\n        return _this4;\n      }\n\n      return _createClass(o);\n    }( /*#__PURE__*/_wrapNativeSuper(Error));\n\n    var h = /*#__PURE__*/function (_Error5) {\n      _inherits(h, _Error5);\n\n      var _super5 = _createSuper(h);\n\n      function h(t, e) {\n        var _this5;\n\n        _classCallCheck(this, h);\n\n        var s = (this instanceof h ? this.constructor : void 0).prototype;\n        _this5 = _super5.call(this, t), _this5.transport = e, _this5.errorType = \"DisabledTransportError\", _this5.__proto__ = s;\n        return _this5;\n      }\n\n      return _createClass(h);\n    }( /*#__PURE__*/_wrapNativeSuper(Error));\n\n    var c = /*#__PURE__*/function (_Error6) {\n      _inherits(c, _Error6);\n\n      var _super6 = _createSuper(c);\n\n      function c(t, e) {\n        var _this6;\n\n        _classCallCheck(this, c);\n\n        var s = (this instanceof c ? this.constructor : void 0).prototype;\n        _this6 = _super6.call(this, t), _this6.transport = e, _this6.errorType = \"FailedToStartTransportError\", _this6.__proto__ = s;\n        return _this6;\n      }\n\n      return _createClass(c);\n    }( /*#__PURE__*/_wrapNativeSuper(Error));\n\n    var a = /*#__PURE__*/function (_Error7) {\n      _inherits(a, _Error7);\n\n      var _super7 = _createSuper(a);\n\n      function a(t) {\n        var _this7;\n\n        _classCallCheck(this, a);\n\n        var e = (this instanceof a ? this.constructor : void 0).prototype;\n        _this7 = _super7.call(this, t), _this7.errorType = \"FailedToNegotiateWithServerError\", _this7.__proto__ = e;\n        return _this7;\n      }\n\n      return _createClass(a);\n    }( /*#__PURE__*/_wrapNativeSuper(Error));\n\n    var l = /*#__PURE__*/function (_Error8) {\n      _inherits(l, _Error8);\n\n      var _super8 = _createSuper(l);\n\n      function l(t, e) {\n        var _this8;\n\n        _classCallCheck(this, l);\n\n        var s = (this instanceof l ? this.constructor : void 0).prototype;\n        _this8 = _super8.call(this, t), _this8.innerErrors = e, _this8.__proto__ = s;\n        return _this8;\n      }\n\n      return _createClass(l);\n    }( /*#__PURE__*/_wrapNativeSuper(Error));\n\n    var u = /*#__PURE__*/_createClass(function u(t, e, s) {\n      _classCallCheck(this, u);\n\n      this.statusCode = t, this.statusText = e, this.content = s;\n    });\n\n    var d = /*#__PURE__*/function () {\n      function d() {\n        _classCallCheck(this, d);\n      }\n\n      _createClass(d, [{\n        key: \"get\",\n        value: function get(t, e) {\n          return this.send(_objectSpread(_objectSpread({}, e), {}, {\n            method: \"GET\",\n            url: t\n          }));\n        }\n      }, {\n        key: \"post\",\n        value: function post(t, e) {\n          return this.send(_objectSpread(_objectSpread({}, e), {}, {\n            method: \"POST\",\n            url: t\n          }));\n        }\n      }, {\n        key: \"delete\",\n        value: function _delete(t, e) {\n          return this.send(_objectSpread(_objectSpread({}, e), {}, {\n            method: \"DELETE\",\n            url: t\n          }));\n        }\n      }, {\n        key: \"getCookieString\",\n        value: function getCookieString(t) {\n          return \"\";\n        }\n      }]);\n\n      return d;\n    }();\n\n    !function (t) {\n      t[t.Trace = 0] = \"Trace\", t[t.Debug = 1] = \"Debug\", t[t.Information = 2] = \"Information\", t[t.Warning = 3] = \"Warning\", t[t.Error = 4] = \"Error\", t[t.Critical = 5] = \"Critical\", t[t.None = 6] = \"None\";\n    }(e || (e = {}));\n\n    var f = /*#__PURE__*/function () {\n      function f() {\n        _classCallCheck(this, f);\n      }\n\n      _createClass(f, [{\n        key: \"log\",\n        value: function log(t, e) {}\n      }]);\n\n      return f;\n    }();\n\n    f.instance = new f();\n    var p = \"6.0.1\";\n\n    var w = /*#__PURE__*/function () {\n      function w() {\n        _classCallCheck(this, w);\n      }\n\n      _createClass(w, null, [{\n        key: \"isRequired\",\n        value: function isRequired(t, e) {\n          if (null == t) throw new Error(\"The '\".concat(e, \"' argument is required.\"));\n        }\n      }, {\n        key: \"isNotEmpty\",\n        value: function isNotEmpty(t, e) {\n          if (!t || t.match(/^\\s*$/)) throw new Error(\"The '\".concat(e, \"' argument should not be empty.\"));\n        }\n      }, {\n        key: \"isIn\",\n        value: function isIn(t, e, s) {\n          if (!(t in e)) throw new Error(\"Unknown \".concat(s, \" value: \").concat(t, \".\"));\n        }\n      }]);\n\n      return w;\n    }();\n\n    var g = /*#__PURE__*/function () {\n      function g() {\n        _classCallCheck(this, g);\n      }\n\n      _createClass(g, null, [{\n        key: \"isBrowser\",\n        get: function get() {\n          return \"object\" == (typeof window === \"undefined\" ? \"undefined\" : _typeof(window));\n        }\n      }, {\n        key: \"isWebWorker\",\n        get: function get() {\n          return \"object\" == (typeof self === \"undefined\" ? \"undefined\" : _typeof(self)) && \"importScripts\" in self;\n        }\n      }, {\n        key: \"isNode\",\n        get: function get() {\n          return !this.isBrowser && !this.isWebWorker;\n        }\n      }]);\n\n      return g;\n    }();\n\n    function m(t, e) {\n      var s = \"\";\n      return y(t) ? (s = \"Binary data of length \".concat(t.byteLength), e && (s += \". Content: '\".concat(function (t) {\n        var e = new Uint8Array(t);\n        var s = \"\";\n        return e.forEach(function (t) {\n          s += \"0x\".concat(t < 16 ? \"0\" : \"\").concat(t.toString(16), \" \");\n        }), s.substr(0, s.length - 1);\n      }(t), \"'\"))) : \"string\" == typeof t && (s = \"String data of length \".concat(t.length), e && (s += \". Content: '\".concat(t, \"'\"))), s;\n    }\n\n    function y(t) {\n      return t && \"undefined\" != typeof ArrayBuffer && (t instanceof ArrayBuffer || t.constructor && \"ArrayBuffer\" === t.constructor.name);\n    }\n\n    function b(_x, _x2, _x3, _x4, _x5, _x6, _x7) {\n      return _b.apply(this, arguments);\n    }\n\n    function _b() {\n      _b = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee22(t, s, n, i, r, o, h) {\n        var c, _t20, _$11, _$12, a, l, u, d;\n\n        return regeneratorRuntime.wrap(function _callee22$(_context22) {\n          while (1) {\n            switch (_context22.prev = _context22.next) {\n              case 0:\n                c = {};\n\n                if (!r) {\n                  _context22.next = 6;\n                  break;\n                }\n\n                _context22.next = 4;\n                return r();\n\n              case 4:\n                _t20 = _context22.sent;\n                _t20 && (c = {\n                  Authorization: \"Bearer \".concat(_t20)\n                });\n\n              case 6:\n                _$11 = $(), _$12 = _slicedToArray(_$11, 2), a = _$12[0], l = _$12[1];\n                c[a] = l, t.log(e.Trace, \"(\".concat(s, \" transport) sending data. \").concat(m(o, h.logMessageContent), \".\"));\n                u = y(o) ? \"arraybuffer\" : \"text\";\n                _context22.next = 11;\n                return n.post(i, {\n                  content: o,\n                  headers: _objectSpread(_objectSpread({}, c), h.headers),\n                  responseType: u,\n                  timeout: h.timeout,\n                  withCredentials: h.withCredentials\n                });\n\n              case 11:\n                d = _context22.sent;\n                t.log(e.Trace, \"(\".concat(s, \" transport) request complete. Response status: \").concat(d.statusCode, \".\"));\n\n              case 13:\n              case \"end\":\n                return _context22.stop();\n            }\n          }\n        }, _callee22);\n      }));\n      return _b.apply(this, arguments);\n    }\n\n    var v = /*#__PURE__*/function () {\n      function v(t, e) {\n        _classCallCheck(this, v);\n\n        this.i = t, this.h = e;\n      }\n\n      _createClass(v, [{\n        key: \"dispose\",\n        value: function dispose() {\n          var t = this.i.observers.indexOf(this.h);\n          t > -1 && this.i.observers.splice(t, 1), 0 === this.i.observers.length && this.i.cancelCallback && this.i.cancelCallback()[\"catch\"](function (t) {});\n        }\n      }]);\n\n      return v;\n    }();\n\n    var E = /*#__PURE__*/function () {\n      function E(t) {\n        _classCallCheck(this, E);\n\n        this.l = t, this.out = console;\n      }\n\n      _createClass(E, [{\n        key: \"log\",\n        value: function log(t, s) {\n          if (t >= this.l) {\n            var _n = \"[\".concat(new Date().toISOString(), \"] \").concat(e[t], \": \").concat(s);\n\n            switch (t) {\n              case e.Critical:\n              case e.Error:\n                this.out.error(_n);\n                break;\n\n              case e.Warning:\n                this.out.warn(_n);\n                break;\n\n              case e.Information:\n                this.out.info(_n);\n                break;\n\n              default:\n                this.out.log(_n);\n            }\n          }\n        }\n      }]);\n\n      return E;\n    }();\n\n    function $() {\n      var t = \"X-SignalR-User-Agent\";\n      return g.isNode && (t = \"User-Agent\"), [t, C(p, S(), g.isNode ? \"NodeJS\" : \"Browser\", k())];\n    }\n\n    function C(t, e, s, n) {\n      var i = \"Microsoft SignalR/\";\n      var r = t.split(\".\");\n      return i += \"\".concat(r[0], \".\").concat(r[1]), i += \" (\".concat(t, \"; \"), i += e && \"\" !== e ? \"\".concat(e, \"; \") : \"Unknown OS; \", i += \"\".concat(s), i += n ? \"; \".concat(n) : \"; Unknown Runtime Version\", i += \")\", i;\n    }\n\n    function S() {\n      if (!g.isNode) return \"\";\n\n      switch (process.platform) {\n        case \"win32\":\n          return \"Windows NT\";\n\n        case \"darwin\":\n          return \"macOS\";\n\n        case \"linux\":\n          return \"Linux\";\n\n        default:\n          return process.platform;\n      }\n    }\n\n    function k() {\n      if (g.isNode) return process.versions.node;\n    }\n\n    function P(t) {\n      return t.stack ? t.stack : t.message ? t.message : \"\".concat(t);\n    }\n\n    var T = /*#__PURE__*/function (_d) {\n      _inherits(T, _d);\n\n      var _super9 = _createSuper(T);\n\n      function T(e) {\n        var _this9;\n\n        _classCallCheck(this, T);\n\n        if (_this9 = _super9.call(this), _this9.u = e, \"undefined\" == typeof fetch) {\n          var _t = undefined;\n          _this9.p = new (Object(function webpackMissingModule() { var e = new Error(\"Cannot find module 'tough-cookie'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }()).CookieJar)(), _this9.m = __webpack_require__(Object(function webpackMissingModule() { var e = new Error(\"Cannot find module 'node-fetch'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }())), _this9.m = __webpack_require__(Object(function webpackMissingModule() { var e = new Error(\"Cannot find module 'fetch-cookie'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }()))(_this9.m, _this9.p);\n        } else _this9.m = fetch.bind(function () {\n          if (\"undefined\" != typeof globalThis) return globalThis;\n          if (\"undefined\" != typeof self) return self;\n          if (\"undefined\" != typeof window) return window;\n          if (void 0 !== t.g) return t.g;\n          throw new Error(\"could not find global\");\n        }());\n\n        if (\"undefined\" == typeof AbortController) {\n          var _t2 = undefined;\n          _this9.v = __webpack_require__(Object(function webpackMissingModule() { var e = new Error(\"Cannot find module 'abort-controller'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }()));\n        } else _this9.v = AbortController;\n\n        return _possibleConstructorReturn(_this9);\n      }\n\n      _createClass(T, [{\n        key: \"send\",\n        value: function () {\n          var _send = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(t) {\n            var _this10 = this;\n\n            var s, o, h, c, _n2, _t3, a, l;\n\n            return regeneratorRuntime.wrap(function _callee$(_context) {\n              while (1) {\n                switch (_context.prev = _context.next) {\n                  case 0:\n                    if (!(t.abortSignal && t.abortSignal.aborted)) {\n                      _context.next = 2;\n                      break;\n                    }\n\n                    throw new r();\n\n                  case 2:\n                    if (t.method) {\n                      _context.next = 4;\n                      break;\n                    }\n\n                    throw new Error(\"No method defined.\");\n\n                  case 4:\n                    if (t.url) {\n                      _context.next = 6;\n                      break;\n                    }\n\n                    throw new Error(\"No url defined.\");\n\n                  case 6:\n                    s = new this.v();\n                    t.abortSignal && (t.abortSignal.onabort = function () {\n                      s.abort(), o = new r();\n                    });\n                    c = null;\n\n                    if (t.timeout) {\n                      _n2 = t.timeout;\n                      c = setTimeout(function () {\n                        s.abort(), _this10.u.log(e.Warning, \"Timeout from HTTP request.\"), o = new i();\n                      }, _n2);\n                    }\n\n                    _context.prev = 10;\n                    _context.next = 13;\n                    return this.m(t.url, {\n                      body: t.content,\n                      cache: \"no-cache\",\n                      credentials: !0 === t.withCredentials ? \"include\" : \"same-origin\",\n                      headers: _objectSpread({\n                        \"Content-Type\": \"text/plain;charset=UTF-8\",\n                        \"X-Requested-With\": \"XMLHttpRequest\"\n                      }, t.headers),\n                      method: t.method,\n                      mode: \"cors\",\n                      redirect: \"follow\",\n                      signal: s.signal\n                    });\n\n                  case 13:\n                    h = _context.sent;\n                    _context.next = 21;\n                    break;\n\n                  case 16:\n                    _context.prev = 16;\n                    _context.t0 = _context[\"catch\"](10);\n\n                    if (!o) {\n                      _context.next = 20;\n                      break;\n                    }\n\n                    throw o;\n\n                  case 20:\n                    throw this.u.log(e.Warning, \"Error from HTTP request. \".concat(_context.t0, \".\")), _context.t0;\n\n                  case 21:\n                    _context.prev = 21;\n                    c && clearTimeout(c), t.abortSignal && (t.abortSignal.onabort = null);\n                    return _context.finish(21);\n\n                  case 24:\n                    if (h.ok) {\n                      _context.next = 29;\n                      break;\n                    }\n\n                    _context.next = 27;\n                    return I(h, \"text\");\n\n                  case 27:\n                    _t3 = _context.sent;\n                    throw new n(_t3 || h.statusText, h.status);\n\n                  case 29:\n                    a = I(h, t.responseType);\n                    _context.next = 32;\n                    return a;\n\n                  case 32:\n                    l = _context.sent;\n                    return _context.abrupt(\"return\", new u(h.status, h.statusText, l));\n\n                  case 34:\n                  case \"end\":\n                    return _context.stop();\n                }\n              }\n            }, _callee, this, [[10, 16, 21, 24]]);\n          }));\n\n          function send(_x8) {\n            return _send.apply(this, arguments);\n          }\n\n          return send;\n        }()\n      }, {\n        key: \"getCookieString\",\n        value: function getCookieString(t) {\n          var e = \"\";\n          return g.isNode && this.p && this.p.getCookies(t, function (t, s) {\n            return e = s.join(\"; \");\n          }), e;\n        }\n      }]);\n\n      return T;\n    }(d);\n\n    function I(t, e) {\n      var s;\n\n      switch (e) {\n        case \"arraybuffer\":\n          s = t.arrayBuffer();\n          break;\n\n        case \"text\":\n          s = t.text();\n          break;\n\n        case \"blob\":\n        case \"document\":\n        case \"json\":\n          throw new Error(\"\".concat(e, \" is not supported.\"));\n\n        default:\n          s = t.text();\n      }\n\n      return s;\n    }\n\n    var _ = /*#__PURE__*/function (_d2) {\n      _inherits(_, _d2);\n\n      var _super10 = _createSuper(_);\n\n      function _(t) {\n        var _this11;\n\n        _classCallCheck(this, _);\n\n        _this11 = _super10.call(this), _this11.u = t;\n        return _this11;\n      }\n\n      _createClass(_, [{\n        key: \"send\",\n        value: function send(t) {\n          var _this12 = this;\n\n          return t.abortSignal && t.abortSignal.aborted ? Promise.reject(new r()) : t.method ? t.url ? new Promise(function (s, o) {\n            var h = new XMLHttpRequest();\n            h.open(t.method, t.url, !0), h.withCredentials = void 0 === t.withCredentials || t.withCredentials, h.setRequestHeader(\"X-Requested-With\", \"XMLHttpRequest\"), h.setRequestHeader(\"Content-Type\", \"text/plain;charset=UTF-8\");\n            var c = t.headers;\n            c && Object.keys(c).forEach(function (t) {\n              h.setRequestHeader(t, c[t]);\n            }), t.responseType && (h.responseType = t.responseType), t.abortSignal && (t.abortSignal.onabort = function () {\n              h.abort(), o(new r());\n            }), t.timeout && (h.timeout = t.timeout), h.onload = function () {\n              t.abortSignal && (t.abortSignal.onabort = null), h.status >= 200 && h.status < 300 ? s(new u(h.status, h.statusText, h.response || h.responseText)) : o(new n(h.response || h.responseText || h.statusText, h.status));\n            }, h.onerror = function () {\n              _this12.u.log(e.Warning, \"Error from HTTP request. \".concat(h.status, \": \").concat(h.statusText, \".\")), o(new n(h.statusText, h.status));\n            }, h.ontimeout = function () {\n              _this12.u.log(e.Warning, \"Timeout from HTTP request.\"), o(new i());\n            }, h.send(t.content || \"\");\n          }) : Promise.reject(new Error(\"No url defined.\")) : Promise.reject(new Error(\"No method defined.\"));\n        }\n      }]);\n\n      return _;\n    }(d);\n\n    var H = /*#__PURE__*/function (_d3) {\n      _inherits(H, _d3);\n\n      var _super11 = _createSuper(H);\n\n      function H(t) {\n        var _this13;\n\n        _classCallCheck(this, H);\n\n        if (_this13 = _super11.call(this), \"undefined\" != typeof fetch || g.isNode) _this13.$ = new T(t);else {\n          if (\"undefined\" == typeof XMLHttpRequest) throw new Error(\"No usable HttpClient found.\");\n          _this13.$ = new _(t);\n        }\n        return _possibleConstructorReturn(_this13);\n      }\n\n      _createClass(H, [{\n        key: \"send\",\n        value: function send(t) {\n          return t.abortSignal && t.abortSignal.aborted ? Promise.reject(new r()) : t.method ? t.url ? this.$.send(t) : Promise.reject(new Error(\"No url defined.\")) : Promise.reject(new Error(\"No method defined.\"));\n        }\n      }, {\n        key: \"getCookieString\",\n        value: function getCookieString(t) {\n          return this.$.getCookieString(t);\n        }\n      }]);\n\n      return H;\n    }(d);\n\n    var D = /*#__PURE__*/function () {\n      function D() {\n        _classCallCheck(this, D);\n      }\n\n      _createClass(D, null, [{\n        key: \"write\",\n        value: function write(t) {\n          return \"\".concat(t).concat(D.RecordSeparator);\n        }\n      }, {\n        key: \"parse\",\n        value: function parse(t) {\n          if (t[t.length - 1] !== D.RecordSeparator) throw new Error(\"Message is incomplete.\");\n          var e = t.split(D.RecordSeparator);\n          return e.pop(), e;\n        }\n      }]);\n\n      return D;\n    }();\n\n    D.RecordSeparatorCode = 30, D.RecordSeparator = String.fromCharCode(D.RecordSeparatorCode);\n\n    var x = /*#__PURE__*/function () {\n      function x() {\n        _classCallCheck(this, x);\n      }\n\n      _createClass(x, [{\n        key: \"writeHandshakeRequest\",\n        value: function writeHandshakeRequest(t) {\n          return D.write(JSON.stringify(t));\n        }\n      }, {\n        key: \"parseHandshakeResponse\",\n        value: function parseHandshakeResponse(t) {\n          var e, s;\n\n          if (y(t)) {\n            var _n3 = new Uint8Array(t),\n                _i = _n3.indexOf(D.RecordSeparatorCode);\n\n            if (-1 === _i) throw new Error(\"Message is incomplete.\");\n\n            var _r = _i + 1;\n\n            e = String.fromCharCode.apply(null, Array.prototype.slice.call(_n3.slice(0, _r))), s = _n3.byteLength > _r ? _n3.slice(_r).buffer : null;\n          } else {\n            var _n4 = t,\n                _i2 = _n4.indexOf(D.RecordSeparator);\n\n            if (-1 === _i2) throw new Error(\"Message is incomplete.\");\n\n            var _r2 = _i2 + 1;\n\n            e = _n4.substring(0, _r2), s = _n4.length > _r2 ? _n4.substring(_r2) : null;\n          }\n\n          var n = D.parse(e),\n              i = JSON.parse(n[0]);\n          if (i.type) throw new Error(\"Expected a handshake response from the server.\");\n          return [s, i];\n        }\n      }]);\n\n      return x;\n    }();\n\n    var A, R;\n    !function (t) {\n      t[t.Invocation = 1] = \"Invocation\", t[t.StreamItem = 2] = \"StreamItem\", t[t.Completion = 3] = \"Completion\", t[t.StreamInvocation = 4] = \"StreamInvocation\", t[t.CancelInvocation = 5] = \"CancelInvocation\", t[t.Ping = 6] = \"Ping\", t[t.Close = 7] = \"Close\";\n    }(A || (A = {}));\n\n    var U = /*#__PURE__*/function () {\n      function U() {\n        _classCallCheck(this, U);\n\n        this.observers = [];\n      }\n\n      _createClass(U, [{\n        key: \"next\",\n        value: function next(t) {\n          var _iterator = _createForOfIteratorHelper(this.observers),\n              _step;\n\n          try {\n            for (_iterator.s(); !(_step = _iterator.n()).done;) {\n              var _e = _step.value;\n\n              _e.next(t);\n            }\n          } catch (err) {\n            _iterator.e(err);\n          } finally {\n            _iterator.f();\n          }\n        }\n      }, {\n        key: \"error\",\n        value: function error(t) {\n          var _iterator2 = _createForOfIteratorHelper(this.observers),\n              _step2;\n\n          try {\n            for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n              var _e2 = _step2.value;\n              _e2.error && _e2.error(t);\n            }\n          } catch (err) {\n            _iterator2.e(err);\n          } finally {\n            _iterator2.f();\n          }\n        }\n      }, {\n        key: \"complete\",\n        value: function complete() {\n          var _iterator3 = _createForOfIteratorHelper(this.observers),\n              _step3;\n\n          try {\n            for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n              var _t4 = _step3.value;\n              _t4.complete && _t4.complete();\n            }\n          } catch (err) {\n            _iterator3.e(err);\n          } finally {\n            _iterator3.f();\n          }\n        }\n      }, {\n        key: \"subscribe\",\n        value: function subscribe(t) {\n          return this.observers.push(t), new v(this, t);\n        }\n      }]);\n\n      return U;\n    }();\n\n    !function (t) {\n      t.Disconnected = \"Disconnected\", t.Connecting = \"Connecting\", t.Connected = \"Connected\", t.Disconnecting = \"Disconnecting\", t.Reconnecting = \"Reconnecting\";\n    }(R || (R = {}));\n\n    var L = /*#__PURE__*/function () {\n      function L(t, s, n, i) {\n        var _this14 = this;\n\n        _classCallCheck(this, L);\n\n        this.C = 0, this.S = function () {\n          _this14.u.log(e.Warning, \"The page is being frozen, this will likely lead to the connection being closed and messages being lost. For more information see the docs at https://docs.microsoft.com/aspnet/core/signalr/javascript-client#bsleep\");\n        }, w.isRequired(t, \"connection\"), w.isRequired(s, \"logger\"), w.isRequired(n, \"protocol\"), this.serverTimeoutInMilliseconds = 3e4, this.keepAliveIntervalInMilliseconds = 15e3, this.u = s, this.k = n, this.connection = t, this.P = i, this.T = new x(), this.connection.onreceive = function (t) {\n          return _this14.I(t);\n        }, this.connection.onclose = function (t) {\n          return _this14._(t);\n        }, this.H = {}, this.D = {}, this.A = [], this.R = [], this.U = [], this.L = 0, this.N = !1, this.q = R.Disconnected, this.M = !1, this.W = this.k.writeMessage({\n          type: A.Ping\n        });\n      }\n\n      _createClass(L, [{\n        key: \"state\",\n        get: function get() {\n          return this.q;\n        }\n      }, {\n        key: \"connectionId\",\n        get: function get() {\n          return this.connection && this.connection.connectionId || null;\n        }\n      }, {\n        key: \"baseUrl\",\n        get: function get() {\n          return this.connection.baseUrl || \"\";\n        },\n        set: function set(t) {\n          if (this.q !== R.Disconnected && this.q !== R.Reconnecting) throw new Error(\"The HubConnection must be in the Disconnected or Reconnecting state to change the url.\");\n          if (!t) throw new Error(\"The HubConnection url must be a valid url.\");\n          this.connection.baseUrl = t;\n        }\n      }, {\n        key: \"start\",\n        value: function start() {\n          return this.O = this.j(), this.O;\n        }\n      }, {\n        key: \"j\",\n        value: function () {\n          var _j = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2() {\n            return regeneratorRuntime.wrap(function _callee2$(_context2) {\n              while (1) {\n                switch (_context2.prev = _context2.next) {\n                  case 0:\n                    if (!(this.q !== R.Disconnected)) {\n                      _context2.next = 2;\n                      break;\n                    }\n\n                    return _context2.abrupt(\"return\", Promise.reject(new Error(\"Cannot start a HubConnection that is not in the 'Disconnected' state.\")));\n\n                  case 2:\n                    this.q = R.Connecting, this.u.log(e.Debug, \"Starting HubConnection.\");\n                    _context2.prev = 3;\n                    _context2.next = 6;\n                    return this.F();\n\n                  case 6:\n                    g.isBrowser && document && document.addEventListener(\"freeze\", this.S);\n                    this.q = R.Connected;\n                    this.M = !0;\n                    this.u.log(e.Debug, \"HubConnection connected successfully.\");\n                    _context2.next = 15;\n                    break;\n\n                  case 12:\n                    _context2.prev = 12;\n                    _context2.t0 = _context2[\"catch\"](3);\n                    return _context2.abrupt(\"return\", (this.q = R.Disconnected, this.u.log(e.Debug, \"HubConnection failed to start successfully because of error '\".concat(_context2.t0, \"'.\")), Promise.reject(_context2.t0)));\n\n                  case 15:\n                  case \"end\":\n                    return _context2.stop();\n                }\n              }\n            }, _callee2, this, [[3, 12]]);\n          }));\n\n          function j() {\n            return _j.apply(this, arguments);\n          }\n\n          return j;\n        }()\n      }, {\n        key: \"F\",\n        value: function () {\n          var _F = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3() {\n            var _this15 = this;\n\n            var t, _s;\n\n            return regeneratorRuntime.wrap(function _callee3$(_context3) {\n              while (1) {\n                switch (_context3.prev = _context3.next) {\n                  case 0:\n                    this.B = void 0, this.N = !1;\n                    t = new Promise(function (t, e) {\n                      _this15.X = t, _this15.J = e;\n                    });\n                    _context3.next = 4;\n                    return this.connection.start(this.k.transferFormat);\n\n                  case 4:\n                    _context3.prev = 4;\n                    _s = {\n                      protocol: this.k.name,\n                      version: this.k.version\n                    };\n                    this.u.log(e.Debug, \"Sending handshake request.\");\n                    _context3.next = 9;\n                    return this.V(this.T.writeHandshakeRequest(_s));\n\n                  case 9:\n                    this.u.log(e.Information, \"Using HubProtocol '\".concat(this.k.name, \"'.\"));\n                    this.G();\n                    this.K();\n                    this.Y();\n                    _context3.next = 15;\n                    return t;\n\n                  case 15:\n                    if (!this.B) {\n                      _context3.next = 17;\n                      break;\n                    }\n\n                    throw this.B;\n\n                  case 17:\n                    _context3.next = 27;\n                    break;\n\n                  case 19:\n                    _context3.prev = 19;\n                    _context3.t0 = _context3[\"catch\"](4);\n                    this.u.log(e.Debug, \"Hub handshake failed with error '\".concat(_context3.t0, \"' during start(). Stopping HubConnection.\"));\n                    this.G();\n                    this.Z();\n                    _context3.next = 26;\n                    return this.connection.stop(_context3.t0);\n\n                  case 26:\n                    throw _context3.t0;\n\n                  case 27:\n                  case \"end\":\n                    return _context3.stop();\n                }\n              }\n            }, _callee3, this, [[4, 19]]);\n          }));\n\n          function F() {\n            return _F.apply(this, arguments);\n          }\n\n          return F;\n        }()\n      }, {\n        key: \"stop\",\n        value: function () {\n          var _stop = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4() {\n            var t;\n            return regeneratorRuntime.wrap(function _callee4$(_context4) {\n              while (1) {\n                switch (_context4.prev = _context4.next) {\n                  case 0:\n                    t = this.O;\n                    this.tt = this.et();\n                    _context4.next = 4;\n                    return this.tt;\n\n                  case 4:\n                    _context4.prev = 4;\n                    _context4.next = 7;\n                    return t;\n\n                  case 7:\n                    _context4.next = 11;\n                    break;\n\n                  case 9:\n                    _context4.prev = 9;\n                    _context4.t0 = _context4[\"catch\"](4);\n\n                  case 11:\n                  case \"end\":\n                    return _context4.stop();\n                }\n              }\n            }, _callee4, this, [[4, 9]]);\n          }));\n\n          function stop() {\n            return _stop.apply(this, arguments);\n          }\n\n          return stop;\n        }()\n      }, {\n        key: \"et\",\n        value: function et(t) {\n          return this.q === R.Disconnected ? (this.u.log(e.Debug, \"Call to HubConnection.stop(\".concat(t, \") ignored because it is already in the disconnected state.\")), Promise.resolve()) : this.q === R.Disconnecting ? (this.u.log(e.Debug, \"Call to HttpConnection.stop(\".concat(t, \") ignored because the connection is already in the disconnecting state.\")), this.tt) : (this.q = R.Disconnecting, this.u.log(e.Debug, \"Stopping HubConnection.\"), this.st ? (this.u.log(e.Debug, \"Connection stopped during reconnect delay. Done reconnecting.\"), clearTimeout(this.st), this.st = void 0, this.nt(), Promise.resolve()) : (this.G(), this.Z(), this.B = t || new Error(\"The connection was stopped before the hub handshake could complete.\"), this.connection.stop(t)));\n        }\n      }, {\n        key: \"stream\",\n        value: function stream(t) {\n          var _this16 = this;\n\n          for (var _len = arguments.length, e = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n            e[_key - 1] = arguments[_key];\n          }\n\n          var _this$it = this.it(e),\n              _this$it2 = _slicedToArray(_this$it, 2),\n              s = _this$it2[0],\n              n = _this$it2[1],\n              i = this.rt(t, e, n);\n\n          var r;\n          var o = new U();\n          return o.cancelCallback = function () {\n            var t = _this16.ot(i.invocationId);\n\n            return delete _this16.H[i.invocationId], r.then(function () {\n              return _this16.ht(t);\n            });\n          }, this.H[i.invocationId] = function (t, e) {\n            e ? o.error(e) : t && (t.type === A.Completion ? t.error ? o.error(new Error(t.error)) : o.complete() : o.next(t.item));\n          }, r = this.ht(i)[\"catch\"](function (t) {\n            o.error(t), delete _this16.H[i.invocationId];\n          }), this.ct(s, r), o;\n        }\n      }, {\n        key: \"V\",\n        value: function V(t) {\n          return this.Y(), this.connection.send(t);\n        }\n      }, {\n        key: \"ht\",\n        value: function ht(t) {\n          return this.V(this.k.writeMessage(t));\n        }\n      }, {\n        key: \"send\",\n        value: function send(t) {\n          for (var _len2 = arguments.length, e = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n            e[_key2 - 1] = arguments[_key2];\n          }\n\n          var _this$it3 = this.it(e),\n              _this$it4 = _slicedToArray(_this$it3, 2),\n              s = _this$it4[0],\n              n = _this$it4[1],\n              i = this.ht(this.at(t, e, !0, n));\n\n          return this.ct(s, i), i;\n        }\n      }, {\n        key: \"invoke\",\n        value: function invoke(t) {\n          var _this17 = this;\n\n          for (var _len3 = arguments.length, e = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {\n            e[_key3 - 1] = arguments[_key3];\n          }\n\n          var _this$it5 = this.it(e),\n              _this$it6 = _slicedToArray(_this$it5, 2),\n              s = _this$it6[0],\n              n = _this$it6[1],\n              i = this.at(t, e, !1, n);\n\n          return new Promise(function (t, e) {\n            _this17.H[i.invocationId] = function (s, n) {\n              n ? e(n) : s && (s.type === A.Completion ? s.error ? e(new Error(s.error)) : t(s.result) : e(new Error(\"Unexpected message type: \".concat(s.type))));\n            };\n\n            var n = _this17.ht(i)[\"catch\"](function (t) {\n              e(t), delete _this17.H[i.invocationId];\n            });\n\n            _this17.ct(s, n);\n          });\n        }\n      }, {\n        key: \"on\",\n        value: function on(t, e) {\n          t && e && (t = t.toLowerCase(), this.D[t] || (this.D[t] = []), -1 === this.D[t].indexOf(e) && this.D[t].push(e));\n        }\n      }, {\n        key: \"off\",\n        value: function off(t, e) {\n          if (!t) return;\n          t = t.toLowerCase();\n          var s = this.D[t];\n          if (s) if (e) {\n            var _n5 = s.indexOf(e);\n\n            -1 !== _n5 && (s.splice(_n5, 1), 0 === s.length && delete this.D[t]);\n          } else delete this.D[t];\n        }\n      }, {\n        key: \"onclose\",\n        value: function onclose(t) {\n          t && this.A.push(t);\n        }\n      }, {\n        key: \"onreconnecting\",\n        value: function onreconnecting(t) {\n          t && this.R.push(t);\n        }\n      }, {\n        key: \"onreconnected\",\n        value: function onreconnected(t) {\n          t && this.U.push(t);\n        }\n      }, {\n        key: \"I\",\n        value: function I(t) {\n          if (this.G(), this.N || (t = this.lt(t), this.N = !0), t) {\n            var _s2 = this.k.parseMessages(t, this.u);\n\n            var _iterator4 = _createForOfIteratorHelper(_s2),\n                _step4;\n\n            try {\n              for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n                var _t5 = _step4.value;\n\n                switch (_t5.type) {\n                  case A.Invocation:\n                    this.ut(_t5);\n                    break;\n\n                  case A.StreamItem:\n                  case A.Completion:\n                    {\n                      var _s3 = this.H[_t5.invocationId];\n\n                      if (_s3) {\n                        _t5.type === A.Completion && delete this.H[_t5.invocationId];\n\n                        try {\n                          _s3(_t5);\n                        } catch (t) {\n                          this.u.log(e.Error, \"Stream callback threw error: \".concat(P(t)));\n                        }\n                      }\n\n                      break;\n                    }\n\n                  case A.Ping:\n                    break;\n\n                  case A.Close:\n                    {\n                      this.u.log(e.Information, \"Close message received from server.\");\n\n                      var _s4 = _t5.error ? new Error(\"Server returned an error on close: \" + _t5.error) : void 0;\n\n                      !0 === _t5.allowReconnect ? this.connection.stop(_s4) : this.tt = this.et(_s4);\n                      break;\n                    }\n\n                  default:\n                    this.u.log(e.Warning, \"Invalid message type: \".concat(_t5.type, \".\"));\n                }\n              }\n            } catch (err) {\n              _iterator4.e(err);\n            } finally {\n              _iterator4.f();\n            }\n          }\n\n          this.K();\n        }\n      }, {\n        key: \"lt\",\n        value: function lt(t) {\n          var s, n;\n\n          try {\n            var _this$T$parseHandshak = this.T.parseHandshakeResponse(t);\n\n            var _this$T$parseHandshak2 = _slicedToArray(_this$T$parseHandshak, 2);\n\n            n = _this$T$parseHandshak2[0];\n            s = _this$T$parseHandshak2[1];\n          } catch (t) {\n            var _s5 = \"Error parsing handshake response: \" + t;\n\n            this.u.log(e.Error, _s5);\n\n            var _n6 = new Error(_s5);\n\n            throw this.J(_n6), _n6;\n          }\n\n          if (s.error) {\n            var _t6 = \"Server returned handshake error: \" + s.error;\n\n            this.u.log(e.Error, _t6);\n\n            var _n7 = new Error(_t6);\n\n            throw this.J(_n7), _n7;\n          }\n\n          return this.u.log(e.Debug, \"Server handshake complete.\"), this.X(), n;\n        }\n      }, {\n        key: \"Y\",\n        value: function Y() {\n          this.connection.features.inherentKeepAlive || (this.C = new Date().getTime() + this.keepAliveIntervalInMilliseconds, this.Z());\n        }\n      }, {\n        key: \"K\",\n        value: function K() {\n          var _this18 = this;\n\n          if (!(this.connection.features && this.connection.features.inherentKeepAlive || (this.dt = setTimeout(function () {\n            return _this18.serverTimeout();\n          }, this.serverTimeoutInMilliseconds), void 0 !== this.ft))) {\n            var _t7 = this.C - new Date().getTime();\n\n            _t7 < 0 && (_t7 = 0), this.ft = setTimeout( /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee5() {\n              return regeneratorRuntime.wrap(function _callee5$(_context5) {\n                while (1) {\n                  switch (_context5.prev = _context5.next) {\n                    case 0:\n                      if (!(_this18.q === R.Connected)) {\n                        _context5.next = 9;\n                        break;\n                      }\n\n                      _context5.prev = 1;\n                      _context5.next = 4;\n                      return _this18.V(_this18.W);\n\n                    case 4:\n                      _context5.next = 9;\n                      break;\n\n                    case 6:\n                      _context5.prev = 6;\n                      _context5.t0 = _context5[\"catch\"](1);\n\n                      _this18.Z();\n\n                    case 9:\n                    case \"end\":\n                      return _context5.stop();\n                  }\n                }\n              }, _callee5, null, [[1, 6]]);\n            })), _t7);\n          }\n        }\n      }, {\n        key: \"serverTimeout\",\n        value: function serverTimeout() {\n          this.connection.stop(new Error(\"Server timeout elapsed without receiving a message from the server.\"));\n        }\n      }, {\n        key: \"ut\",\n        value: function ut(t) {\n          var _this19 = this;\n\n          var s = this.D[t.target.toLowerCase()];\n\n          if (s) {\n            try {\n              s.forEach(function (e) {\n                return e.apply(_this19, t.arguments);\n              });\n            } catch (s) {\n              this.u.log(e.Error, \"A callback for the method \".concat(t.target.toLowerCase(), \" threw error '\").concat(s, \"'.\"));\n            }\n\n            if (t.invocationId) {\n              var _t8 = \"Server requested a response, which is not supported in this version of the client.\";\n              this.u.log(e.Error, _t8), this.tt = this.et(new Error(_t8));\n            }\n          } else this.u.log(e.Warning, \"No client method with the name '\".concat(t.target, \"' found.\"));\n        }\n      }, {\n        key: \"_\",\n        value: function _(t) {\n          this.u.log(e.Debug, \"HubConnection.connectionClosed(\".concat(t, \") called while in state \").concat(this.q, \".\")), this.B = this.B || t || new Error(\"The underlying connection was closed before the hub handshake could complete.\"), this.X && this.X(), this.wt(t || new Error(\"Invocation canceled due to the underlying connection being closed.\")), this.G(), this.Z(), this.q === R.Disconnecting ? this.nt(t) : this.q === R.Connected && this.P ? this.gt(t) : this.q === R.Connected && this.nt(t);\n        }\n      }, {\n        key: \"nt\",\n        value: function nt(t) {\n          var _this20 = this;\n\n          if (this.M) {\n            this.q = R.Disconnected, this.M = !1, g.isBrowser && document && document.removeEventListener(\"freeze\", this.S);\n\n            try {\n              this.A.forEach(function (e) {\n                return e.apply(_this20, [t]);\n              });\n            } catch (s) {\n              this.u.log(e.Error, \"An onclose callback called with error '\".concat(t, \"' threw error '\").concat(s, \"'.\"));\n            }\n          }\n        }\n      }, {\n        key: \"gt\",\n        value: function () {\n          var _gt = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee6(t) {\n            var _this21 = this;\n\n            var s, n, i, r;\n            return regeneratorRuntime.wrap(function _callee6$(_context6) {\n              while (1) {\n                switch (_context6.prev = _context6.next) {\n                  case 0:\n                    s = Date.now();\n                    n = 0, i = void 0 !== t ? t : new Error(\"Attempting to reconnect due to a unknown error.\"), r = this.yt(n++, 0, i);\n\n                    if (!(null === r)) {\n                      _context6.next = 4;\n                      break;\n                    }\n\n                    return _context6.abrupt(\"return\", (this.u.log(e.Debug, \"Connection not reconnecting because the IRetryPolicy returned null on the first reconnect attempt.\"), void this.nt(t)));\n\n                  case 4:\n                    if (!(this.q = R.Reconnecting, t ? this.u.log(e.Information, \"Connection reconnecting because of error '\".concat(t, \"'.\")) : this.u.log(e.Information, \"Connection reconnecting.\"), 0 !== this.R.length)) {\n                      _context6.next = 8;\n                      break;\n                    }\n\n                    try {\n                      this.R.forEach(function (e) {\n                        return e.apply(_this21, [t]);\n                      });\n                    } catch (s) {\n                      this.u.log(e.Error, \"An onreconnecting callback called with error '\".concat(t, \"' threw error '\").concat(s, \"'.\"));\n                    }\n\n                    if (!(this.q !== R.Reconnecting)) {\n                      _context6.next = 8;\n                      break;\n                    }\n\n                    return _context6.abrupt(\"return\", void this.u.log(e.Debug, \"Connection left the reconnecting state in onreconnecting callback. Done reconnecting.\"));\n\n                  case 8:\n                    if (!(null !== r)) {\n                      _context6.next = 32;\n                      break;\n                    }\n\n                    this.u.log(e.Information, \"Reconnect attempt number \".concat(n, \" will start in \").concat(r, \" ms.\"));\n                    _context6.next = 12;\n                    return new Promise(function (t) {\n                      _this21.st = setTimeout(t, r);\n                    });\n\n                  case 12:\n                    this.st = void 0;\n\n                    if (!(this.q !== R.Reconnecting)) {\n                      _context6.next = 15;\n                      break;\n                    }\n\n                    return _context6.abrupt(\"return\", void this.u.log(e.Debug, \"Connection left the reconnecting state during reconnect delay. Done reconnecting.\"));\n\n                  case 15:\n                    _context6.prev = 15;\n                    _context6.next = 18;\n                    return this.F();\n\n                  case 18:\n                    this.q = R.Connected;\n                    this.u.log(e.Information, \"HubConnection reconnected successfully.\");\n\n                    if (!(0 !== this.U.length)) {\n                      _context6.next = 22;\n                      break;\n                    }\n\n                    try {\n                      this.U.forEach(function (t) {\n                        return t.apply(_this21, [_this21.connection.connectionId]);\n                      });\n                    } catch (t) {\n                      this.u.log(e.Error, \"An onreconnected callback called with connectionId '\".concat(this.connection.connectionId, \"; threw error '\").concat(t, \"'.\"));\n                    }\n\n                  case 22:\n                    return _context6.abrupt(\"return\");\n\n                  case 25:\n                    _context6.prev = 25;\n                    _context6.t0 = _context6[\"catch\"](15);\n\n                    if (!(this.u.log(e.Information, \"Reconnect attempt failed because of error '\".concat(_context6.t0, \"'.\")), this.q !== R.Reconnecting)) {\n                      _context6.next = 29;\n                      break;\n                    }\n\n                    return _context6.abrupt(\"return\", (this.u.log(e.Debug, \"Connection moved to the '\".concat(this.q, \"' from the reconnecting state during reconnect attempt. Done reconnecting.\")), void (this.q === R.Disconnecting && this.nt())));\n\n                  case 29:\n                    i = _context6.t0 instanceof Error ? _context6.t0 : new Error(_context6.t0.toString()), r = this.yt(n++, Date.now() - s, i);\n\n                  case 30:\n                    _context6.next = 8;\n                    break;\n\n                  case 32:\n                    this.u.log(e.Information, \"Reconnect retries have been exhausted after \".concat(Date.now() - s, \" ms and \").concat(n, \" failed attempts. Connection disconnecting.\")), this.nt();\n\n                  case 33:\n                  case \"end\":\n                    return _context6.stop();\n                }\n              }\n            }, _callee6, this, [[15, 25]]);\n          }));\n\n          function gt(_x9) {\n            return _gt.apply(this, arguments);\n          }\n\n          return gt;\n        }()\n      }, {\n        key: \"yt\",\n        value: function yt(t, s, n) {\n          try {\n            return this.P.nextRetryDelayInMilliseconds({\n              elapsedMilliseconds: s,\n              previousRetryCount: t,\n              retryReason: n\n            });\n          } catch (n) {\n            return this.u.log(e.Error, \"IRetryPolicy.nextRetryDelayInMilliseconds(\".concat(t, \", \").concat(s, \") threw error '\").concat(n, \"'.\")), null;\n          }\n        }\n      }, {\n        key: \"wt\",\n        value: function wt(t) {\n          var _this22 = this;\n\n          var s = this.H;\n          this.H = {}, Object.keys(s).forEach(function (n) {\n            var i = s[n];\n\n            try {\n              i(null, t);\n            } catch (s) {\n              _this22.u.log(e.Error, \"Stream 'error' callback called with '\".concat(t, \"' threw error: \").concat(P(s)));\n            }\n          });\n        }\n      }, {\n        key: \"Z\",\n        value: function Z() {\n          this.ft && (clearTimeout(this.ft), this.ft = void 0);\n        }\n      }, {\n        key: \"G\",\n        value: function G() {\n          this.dt && clearTimeout(this.dt);\n        }\n      }, {\n        key: \"at\",\n        value: function at(t, e, s, n) {\n          if (s) return 0 !== n.length ? {\n            arguments: e,\n            streamIds: n,\n            target: t,\n            type: A.Invocation\n          } : {\n            arguments: e,\n            target: t,\n            type: A.Invocation\n          };\n          {\n            var _s6 = this.L;\n            return this.L++, 0 !== n.length ? {\n              arguments: e,\n              invocationId: _s6.toString(),\n              streamIds: n,\n              target: t,\n              type: A.Invocation\n            } : {\n              arguments: e,\n              invocationId: _s6.toString(),\n              target: t,\n              type: A.Invocation\n            };\n          }\n        }\n      }, {\n        key: \"ct\",\n        value: function ct(t, e) {\n          var _this23 = this;\n\n          if (0 !== t.length) {\n            e || (e = Promise.resolve());\n\n            var _loop = function _loop(_s7) {\n              t[_s7].subscribe({\n                complete: function complete() {\n                  e = e.then(function () {\n                    return _this23.ht(_this23.bt(_s7));\n                  });\n                },\n                error: function error(t) {\n                  var n;\n                  n = t instanceof Error ? t.message : t && t.toString ? t.toString() : \"Unknown error\", e = e.then(function () {\n                    return _this23.ht(_this23.bt(_s7, n));\n                  });\n                },\n                next: function next(t) {\n                  e = e.then(function () {\n                    return _this23.ht(_this23.vt(_s7, t));\n                  });\n                }\n              });\n            };\n\n            for (var _s7 in t) {\n              _loop(_s7);\n            }\n          }\n        }\n      }, {\n        key: \"it\",\n        value: function it(t) {\n          var e = [],\n              s = [];\n\n          for (var _n8 = 0; _n8 < t.length; _n8++) {\n            var _i3 = t[_n8];\n\n            if (this.Et(_i3)) {\n              var _r3 = this.L;\n              this.L++, e[_r3] = _i3, s.push(_r3.toString()), t.splice(_n8, 1);\n            }\n          }\n\n          return [e, s];\n        }\n      }, {\n        key: \"Et\",\n        value: function Et(t) {\n          return t && t.subscribe && \"function\" == typeof t.subscribe;\n        }\n      }, {\n        key: \"rt\",\n        value: function rt(t, e, s) {\n          var n = this.L;\n          return this.L++, 0 !== s.length ? {\n            arguments: e,\n            invocationId: n.toString(),\n            streamIds: s,\n            target: t,\n            type: A.StreamInvocation\n          } : {\n            arguments: e,\n            invocationId: n.toString(),\n            target: t,\n            type: A.StreamInvocation\n          };\n        }\n      }, {\n        key: \"ot\",\n        value: function ot(t) {\n          return {\n            invocationId: t,\n            type: A.CancelInvocation\n          };\n        }\n      }, {\n        key: \"vt\",\n        value: function vt(t, e) {\n          return {\n            invocationId: t,\n            item: e,\n            type: A.StreamItem\n          };\n        }\n      }, {\n        key: \"bt\",\n        value: function bt(t, e, s) {\n          return e ? {\n            error: e,\n            invocationId: t,\n            type: A.Completion\n          } : {\n            invocationId: t,\n            result: s,\n            type: A.Completion\n          };\n        }\n      }], [{\n        key: \"create\",\n        value: function create(t, e, s, n) {\n          return new L(t, e, s, n);\n        }\n      }]);\n\n      return L;\n    }();\n\n    var N = [0, 2e3, 1e4, 3e4, null];\n\n    var q = /*#__PURE__*/function () {\n      function q(t) {\n        _classCallCheck(this, q);\n\n        this.$t = void 0 !== t ? [].concat(_toConsumableArray(t), [null]) : N;\n      }\n\n      _createClass(q, [{\n        key: \"nextRetryDelayInMilliseconds\",\n        value: function nextRetryDelayInMilliseconds(t) {\n          return this.$t[t.previousRetryCount];\n        }\n      }]);\n\n      return q;\n    }();\n\n    var M = /*#__PURE__*/_createClass(function M() {\n      _classCallCheck(this, M);\n    });\n\n    var W, O;\n    M.Authorization = \"Authorization\", M.Cookie = \"Cookie\", function (t) {\n      t[t.None = 0] = \"None\", t[t.WebSockets = 1] = \"WebSockets\", t[t.ServerSentEvents = 2] = \"ServerSentEvents\", t[t.LongPolling = 4] = \"LongPolling\";\n    }(W || (W = {})), function (t) {\n      t[t.Text = 1] = \"Text\", t[t.Binary = 2] = \"Binary\";\n    }(O || (O = {}));\n\n    var j = /*#__PURE__*/function () {\n      function j() {\n        _classCallCheck(this, j);\n\n        this.Ct = !1, this.onabort = null;\n      }\n\n      _createClass(j, [{\n        key: \"abort\",\n        value: function abort() {\n          this.Ct || (this.Ct = !0, this.onabort && this.onabort());\n        }\n      }, {\n        key: \"signal\",\n        get: function get() {\n          return this;\n        }\n      }, {\n        key: \"aborted\",\n        get: function get() {\n          return this.Ct;\n        }\n      }]);\n\n      return j;\n    }();\n\n    var _F2 = /*#__PURE__*/function () {\n      function F(t, e, s, n) {\n        _classCallCheck(this, F);\n\n        this.$ = t, this.St = e, this.u = s, this.kt = new j(), this.Pt = n, this.Tt = !1, this.onreceive = null, this.onclose = null;\n      }\n\n      _createClass(F, [{\n        key: \"pollAborted\",\n        get: function get() {\n          return this.kt.aborted;\n        }\n      }, {\n        key: \"connect\",\n        value: function () {\n          var _connect = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee7(t, s) {\n            var _$, _$2, i, r, o, h, c, a, l;\n\n            return regeneratorRuntime.wrap(function _callee7$(_context7) {\n              while (1) {\n                switch (_context7.prev = _context7.next) {\n                  case 0:\n                    if (!(w.isRequired(t, \"url\"), w.isRequired(s, \"transferFormat\"), w.isIn(s, O, \"transferFormat\"), this.It = t, this.u.log(e.Trace, \"(LongPolling transport) Connecting.\"), s === O.Binary && \"undefined\" != typeof XMLHttpRequest && \"string\" != typeof new XMLHttpRequest().responseType)) {\n                      _context7.next = 2;\n                      break;\n                    }\n\n                    throw new Error(\"Binary protocols over XmlHttpRequest not implementing advanced features are not supported.\");\n\n                  case 2:\n                    _$ = $(), _$2 = _slicedToArray(_$, 2), i = _$2[0], r = _$2[1], o = _objectSpread(_defineProperty({}, i, r), this.Pt.headers), h = {\n                      abortSignal: this.kt.signal,\n                      headers: o,\n                      timeout: 1e5,\n                      withCredentials: this.Pt.withCredentials\n                    };\n                    s === O.Binary && (h.responseType = \"arraybuffer\");\n                    _context7.next = 6;\n                    return this._t();\n\n                  case 6:\n                    c = _context7.sent;\n                    this.Ht(h, c);\n                    a = \"\".concat(t, \"&_=\").concat(Date.now());\n                    this.u.log(e.Trace, \"(LongPolling transport) polling: \".concat(a, \".\"));\n                    _context7.next = 12;\n                    return this.$.get(a, h);\n\n                  case 12:\n                    l = _context7.sent;\n                    200 !== l.statusCode ? (this.u.log(e.Error, \"(LongPolling transport) Unexpected response code: \".concat(l.statusCode, \".\")), this.Dt = new n(l.statusText || \"\", l.statusCode), this.Tt = !1) : this.Tt = !0, this.xt = this.At(this.It, h);\n\n                  case 14:\n                  case \"end\":\n                    return _context7.stop();\n                }\n              }\n            }, _callee7, this);\n          }));\n\n          function connect(_x10, _x11) {\n            return _connect.apply(this, arguments);\n          }\n\n          return connect;\n        }()\n      }, {\n        key: \"_t\",\n        value: function () {\n          var _t9 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee8() {\n            return regeneratorRuntime.wrap(function _callee8$(_context8) {\n              while (1) {\n                switch (_context8.prev = _context8.next) {\n                  case 0:\n                    if (!this.St) {\n                      _context8.next = 6;\n                      break;\n                    }\n\n                    _context8.next = 3;\n                    return this.St();\n\n                  case 3:\n                    _context8.t0 = _context8.sent;\n                    _context8.next = 7;\n                    break;\n\n                  case 6:\n                    _context8.t0 = null;\n\n                  case 7:\n                    return _context8.abrupt(\"return\", _context8.t0);\n\n                  case 8:\n                  case \"end\":\n                    return _context8.stop();\n                }\n              }\n            }, _callee8, this);\n          }));\n\n          function _t() {\n            return _t9.apply(this, arguments);\n          }\n\n          return _t;\n        }()\n      }, {\n        key: \"Ht\",\n        value: function Ht(t, e) {\n          t.headers || (t.headers = {}), e ? t.headers[M.Authorization] = \"Bearer \".concat(e) : t.headers[M.Authorization] && delete t.headers[M.Authorization];\n        }\n      }, {\n        key: \"At\",\n        value: function () {\n          var _At = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee9(t, s) {\n            var _r4, _i4, _r5;\n\n            return regeneratorRuntime.wrap(function _callee9$(_context9) {\n              while (1) {\n                switch (_context9.prev = _context9.next) {\n                  case 0:\n                    _context9.prev = 0;\n\n                  case 1:\n                    if (!this.Tt) {\n                      _context9.next = 20;\n                      break;\n                    }\n\n                    _context9.next = 4;\n                    return this._t();\n\n                  case 4:\n                    _r4 = _context9.sent;\n                    this.Ht(s, _r4);\n                    _context9.prev = 6;\n                    _i4 = \"\".concat(t, \"&_=\").concat(Date.now());\n                    this.u.log(e.Trace, \"(LongPolling transport) polling: \".concat(_i4, \".\"));\n                    _context9.next = 11;\n                    return this.$.get(_i4, s);\n\n                  case 11:\n                    _r5 = _context9.sent;\n                    204 === _r5.statusCode ? (this.u.log(e.Information, \"(LongPolling transport) Poll terminated by server.\"), this.Tt = !1) : 200 !== _r5.statusCode ? (this.u.log(e.Error, \"(LongPolling transport) Unexpected response code: \".concat(_r5.statusCode, \".\")), this.Dt = new n(_r5.statusText || \"\", _r5.statusCode), this.Tt = !1) : _r5.content ? (this.u.log(e.Trace, \"(LongPolling transport) data received. \".concat(m(_r5.content, this.Pt.logMessageContent), \".\")), this.onreceive && this.onreceive(_r5.content)) : this.u.log(e.Trace, \"(LongPolling transport) Poll timed out, reissuing.\");\n                    _context9.next = 18;\n                    break;\n\n                  case 15:\n                    _context9.prev = 15;\n                    _context9.t0 = _context9[\"catch\"](6);\n                    this.Tt ? _context9.t0 instanceof i ? this.u.log(e.Trace, \"(LongPolling transport) Poll timed out, reissuing.\") : (this.Dt = _context9.t0, this.Tt = !1) : this.u.log(e.Trace, \"(LongPolling transport) Poll errored after shutdown: \".concat(_context9.t0.message));\n\n                  case 18:\n                    _context9.next = 1;\n                    break;\n\n                  case 20:\n                    _context9.prev = 20;\n                    this.u.log(e.Trace, \"(LongPolling transport) Polling complete.\"), this.pollAborted || this.Rt();\n                    return _context9.finish(20);\n\n                  case 23:\n                  case \"end\":\n                    return _context9.stop();\n                }\n              }\n            }, _callee9, this, [[0,, 20, 23], [6, 15]]);\n          }));\n\n          function At(_x12, _x13) {\n            return _At.apply(this, arguments);\n          }\n\n          return At;\n        }()\n      }, {\n        key: \"send\",\n        value: function () {\n          var _send2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee10(t) {\n            return regeneratorRuntime.wrap(function _callee10$(_context10) {\n              while (1) {\n                switch (_context10.prev = _context10.next) {\n                  case 0:\n                    return _context10.abrupt(\"return\", this.Tt ? b(this.u, \"LongPolling\", this.$, this.It, this.St, t, this.Pt) : Promise.reject(new Error(\"Cannot send until the transport is connected\")));\n\n                  case 1:\n                  case \"end\":\n                    return _context10.stop();\n                }\n              }\n            }, _callee10, this);\n          }));\n\n          function send(_x14) {\n            return _send2.apply(this, arguments);\n          }\n\n          return send;\n        }()\n      }, {\n        key: \"stop\",\n        value: function () {\n          var _stop2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee11() {\n            var _t10, _$3, _$4, _s8, _n9, _i5, _r6;\n\n            return regeneratorRuntime.wrap(function _callee11$(_context11) {\n              while (1) {\n                switch (_context11.prev = _context11.next) {\n                  case 0:\n                    this.u.log(e.Trace, \"(LongPolling transport) Stopping polling.\"), this.Tt = !1, this.kt.abort();\n                    _context11.prev = 1;\n                    _context11.next = 4;\n                    return this.xt;\n\n                  case 4:\n                    this.u.log(e.Trace, \"(LongPolling transport) sending DELETE request to \".concat(this.It, \".\"));\n                    _t10 = {}, _$3 = $(), _$4 = _slicedToArray(_$3, 2), _s8 = _$4[0], _n9 = _$4[1];\n                    _t10[_s8] = _n9;\n                    _i5 = {\n                      headers: _objectSpread(_objectSpread({}, _t10), this.Pt.headers),\n                      timeout: this.Pt.timeout,\n                      withCredentials: this.Pt.withCredentials\n                    };\n                    _context11.next = 10;\n                    return this._t();\n\n                  case 10:\n                    _r6 = _context11.sent;\n                    this.Ht(_i5, _r6);\n                    _context11.next = 14;\n                    return this.$[\"delete\"](this.It, _i5);\n\n                  case 14:\n                    this.u.log(e.Trace, \"(LongPolling transport) DELETE request sent.\");\n\n                  case 15:\n                    _context11.prev = 15;\n                    this.u.log(e.Trace, \"(LongPolling transport) Stop finished.\"), this.Rt();\n                    return _context11.finish(15);\n\n                  case 18:\n                  case \"end\":\n                    return _context11.stop();\n                }\n              }\n            }, _callee11, this, [[1,, 15, 18]]);\n          }));\n\n          function stop() {\n            return _stop2.apply(this, arguments);\n          }\n\n          return stop;\n        }()\n      }, {\n        key: \"Rt\",\n        value: function Rt() {\n          if (this.onclose) {\n            var _t11 = \"(LongPolling transport) Firing onclose event.\";\n            this.Dt && (_t11 += \" Error: \" + this.Dt), this.u.log(e.Trace, _t11), this.onclose(this.Dt);\n          }\n        }\n      }]);\n\n      return F;\n    }();\n\n    var B = /*#__PURE__*/function () {\n      function B(t, e, s, n) {\n        _classCallCheck(this, B);\n\n        this.$ = t, this.St = e, this.u = s, this.Pt = n, this.onreceive = null, this.onclose = null;\n      }\n\n      _createClass(B, [{\n        key: \"connect\",\n        value: function () {\n          var _connect2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee12(t, s) {\n            var _this24 = this;\n\n            var _e3;\n\n            return regeneratorRuntime.wrap(function _callee12$(_context12) {\n              while (1) {\n                switch (_context12.prev = _context12.next) {\n                  case 0:\n                    if (!(w.isRequired(t, \"url\"), w.isRequired(s, \"transferFormat\"), w.isIn(s, O, \"transferFormat\"), this.u.log(e.Trace, \"(SSE transport) Connecting.\"), this.It = t, this.St)) {\n                      _context12.next = 5;\n                      break;\n                    }\n\n                    _context12.next = 3;\n                    return this.St();\n\n                  case 3:\n                    _e3 = _context12.sent;\n                    _e3 && (t += (t.indexOf(\"?\") < 0 ? \"?\" : \"&\") + \"access_token=\".concat(encodeURIComponent(_e3)));\n\n                  case 5:\n                    return _context12.abrupt(\"return\", new Promise(function (n, i) {\n                      var r,\n                          o = !1;\n\n                      if (s === O.Text) {\n                        if (g.isBrowser || g.isWebWorker) r = new _this24.Pt.EventSource(t, {\n                          withCredentials: _this24.Pt.withCredentials\n                        });else {\n                          var _e4 = _this24.$.getCookieString(t),\n                              _s9 = {};\n\n                          _s9.Cookie = _e4;\n\n                          var _$5 = $(),\n                              _$6 = _slicedToArray(_$5, 2),\n                              _n10 = _$6[0],\n                              _i6 = _$6[1];\n\n                          _s9[_n10] = _i6, r = new _this24.Pt.EventSource(t, {\n                            withCredentials: _this24.Pt.withCredentials,\n                            headers: _objectSpread(_objectSpread({}, _s9), _this24.Pt.headers)\n                          });\n                        }\n\n                        try {\n                          r.onmessage = function (t) {\n                            if (_this24.onreceive) try {\n                              _this24.u.log(e.Trace, \"(SSE transport) data received. \".concat(m(t.data, _this24.Pt.logMessageContent), \".\")), _this24.onreceive(t.data);\n                            } catch (t) {\n                              return void _this24.Ut(t);\n                            }\n                          }, r.onerror = function (t) {\n                            o ? _this24.Ut() : i(new Error(\"EventSource failed to connect. The connection could not be found on the server, either the connection ID is not present on the server, or a proxy is refusing/buffering the connection. If you have multiple servers check that sticky sessions are enabled.\"));\n                          }, r.onopen = function () {\n                            _this24.u.log(e.Information, \"SSE connected to \".concat(_this24.It)), _this24.Lt = r, o = !0, n();\n                          };\n                        } catch (t) {\n                          return void i(t);\n                        }\n                      } else i(new Error(\"The Server-Sent Events transport only supports the 'Text' transfer format\"));\n                    }));\n\n                  case 6:\n                  case \"end\":\n                    return _context12.stop();\n                }\n              }\n            }, _callee12, this);\n          }));\n\n          function connect(_x15, _x16) {\n            return _connect2.apply(this, arguments);\n          }\n\n          return connect;\n        }()\n      }, {\n        key: \"send\",\n        value: function () {\n          var _send3 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee13(t) {\n            return regeneratorRuntime.wrap(function _callee13$(_context13) {\n              while (1) {\n                switch (_context13.prev = _context13.next) {\n                  case 0:\n                    return _context13.abrupt(\"return\", this.Lt ? b(this.u, \"SSE\", this.$, this.It, this.St, t, this.Pt) : Promise.reject(new Error(\"Cannot send until the transport is connected\")));\n\n                  case 1:\n                  case \"end\":\n                    return _context13.stop();\n                }\n              }\n            }, _callee13, this);\n          }));\n\n          function send(_x17) {\n            return _send3.apply(this, arguments);\n          }\n\n          return send;\n        }()\n      }, {\n        key: \"stop\",\n        value: function stop() {\n          return this.Ut(), Promise.resolve();\n        }\n      }, {\n        key: \"Ut\",\n        value: function Ut(t) {\n          this.Lt && (this.Lt.close(), this.Lt = void 0, this.onclose && this.onclose(t));\n        }\n      }]);\n\n      return B;\n    }();\n\n    var X = /*#__PURE__*/function () {\n      function X(t, e, s, n, i, r) {\n        _classCallCheck(this, X);\n\n        this.u = s, this.St = e, this.Nt = n, this.qt = i, this.$ = t, this.onreceive = null, this.onclose = null, this.Mt = r;\n      }\n\n      _createClass(X, [{\n        key: \"connect\",\n        value: function () {\n          var _connect3 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee14(t, s) {\n            var _this25 = this;\n\n            var _e5;\n\n            return regeneratorRuntime.wrap(function _callee14$(_context14) {\n              while (1) {\n                switch (_context14.prev = _context14.next) {\n                  case 0:\n                    if (!(w.isRequired(t, \"url\"), w.isRequired(s, \"transferFormat\"), w.isIn(s, O, \"transferFormat\"), this.u.log(e.Trace, \"(WebSockets transport) Connecting.\"), this.St)) {\n                      _context14.next = 5;\n                      break;\n                    }\n\n                    _context14.next = 3;\n                    return this.St();\n\n                  case 3:\n                    _e5 = _context14.sent;\n                    _e5 && (t += (t.indexOf(\"?\") < 0 ? \"?\" : \"&\") + \"access_token=\".concat(encodeURIComponent(_e5)));\n\n                  case 5:\n                    return _context14.abrupt(\"return\", new Promise(function (n, i) {\n                      var r;\n                      t = t.replace(/^http/, \"ws\");\n\n                      var o = _this25.$.getCookieString(t);\n\n                      var h = !1;\n\n                      if (g.isNode) {\n                        var _e6 = {},\n                            _$7 = $(),\n                            _$8 = _slicedToArray(_$7, 2),\n                            _s10 = _$8[0],\n                            _n11 = _$8[1];\n\n                        _e6[_s10] = _n11, o && (_e6[M.Cookie] = \"\".concat(o)), r = new _this25.qt(t, void 0, {\n                          headers: _objectSpread(_objectSpread({}, _e6), _this25.Mt)\n                        });\n                      }\n\n                      r || (r = new _this25.qt(t)), s === O.Binary && (r.binaryType = \"arraybuffer\"), r.onopen = function (s) {\n                        _this25.u.log(e.Information, \"WebSocket connected to \".concat(t, \".\")), _this25.Wt = r, h = !0, n();\n                      }, r.onerror = function (t) {\n                        var s = null;\n                        s = \"undefined\" != typeof ErrorEvent && t instanceof ErrorEvent ? t.error : \"There was an error with the transport\", _this25.u.log(e.Information, \"(WebSockets transport) \".concat(s, \".\"));\n                      }, r.onmessage = function (t) {\n                        if (_this25.u.log(e.Trace, \"(WebSockets transport) data received. \".concat(m(t.data, _this25.Nt), \".\")), _this25.onreceive) try {\n                          _this25.onreceive(t.data);\n                        } catch (t) {\n                          return void _this25.Ut(t);\n                        }\n                      }, r.onclose = function (t) {\n                        if (h) _this25.Ut(t);else {\n                          var _e7 = null;\n                          _e7 = \"undefined\" != typeof ErrorEvent && t instanceof ErrorEvent ? t.error : \"WebSocket failed to connect. The connection could not be found on the server, either the endpoint may not be a SignalR endpoint, the connection ID is not present on the server, or there is a proxy blocking WebSockets. If you have multiple servers check that sticky sessions are enabled.\", i(new Error(_e7));\n                        }\n                      };\n                    }));\n\n                  case 6:\n                  case \"end\":\n                    return _context14.stop();\n                }\n              }\n            }, _callee14, this);\n          }));\n\n          function connect(_x18, _x19) {\n            return _connect3.apply(this, arguments);\n          }\n\n          return connect;\n        }()\n      }, {\n        key: \"send\",\n        value: function send(t) {\n          return this.Wt && this.Wt.readyState === this.qt.OPEN ? (this.u.log(e.Trace, \"(WebSockets transport) sending data. \".concat(m(t, this.Nt), \".\")), this.Wt.send(t), Promise.resolve()) : Promise.reject(\"WebSocket is not in the OPEN state\");\n        }\n      }, {\n        key: \"stop\",\n        value: function stop() {\n          return this.Wt && this.Ut(void 0), Promise.resolve();\n        }\n      }, {\n        key: \"Ut\",\n        value: function Ut(t) {\n          this.Wt && (this.Wt.onclose = function () {}, this.Wt.onmessage = function () {}, this.Wt.onerror = function () {}, this.Wt.close(), this.Wt = void 0), this.u.log(e.Trace, \"(WebSockets transport) socket closed.\"), this.onclose && (!this.Ot(t) || !1 !== t.wasClean && 1e3 === t.code ? t instanceof Error ? this.onclose(t) : this.onclose() : this.onclose(new Error(\"WebSocket closed with status code: \".concat(t.code, \" (\").concat(t.reason || \"no reason given\", \").\"))));\n        }\n      }, {\n        key: \"Ot\",\n        value: function Ot(t) {\n          return t && \"boolean\" == typeof t.wasClean && \"number\" == typeof t.code;\n        }\n      }]);\n\n      return X;\n    }();\n\n    var J = /*#__PURE__*/function () {\n      function J(t) {\n        var s = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n        _classCallCheck(this, J);\n\n        var n;\n        if (this.jt = function () {}, this.features = {}, this.Ft = 1, w.isRequired(t, \"url\"), this.u = void 0 === (n = s.logger) ? new E(e.Information) : null === n ? f.instance : void 0 !== n.log ? n : new E(n), this.baseUrl = this.Bt(t), (s = s || {}).logMessageContent = void 0 !== s.logMessageContent && s.logMessageContent, \"boolean\" != typeof s.withCredentials && void 0 !== s.withCredentials) throw new Error(\"withCredentials option was not a 'boolean' or 'undefined' value\");\n        s.withCredentials = void 0 === s.withCredentials || s.withCredentials, s.timeout = void 0 === s.timeout ? 1e5 : s.timeout;\n        var i = null,\n            r = null;\n\n        if (g.isNode) {\n          var _t12 = undefined;\n          i = __webpack_require__(/*! ws */ \"./node_modules/ws/browser.js\"), r = __webpack_require__(Object(function webpackMissingModule() { var e = new Error(\"Cannot find module 'eventsource'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }()));\n        }\n\n        g.isNode || \"undefined\" == typeof WebSocket || s.WebSocket ? g.isNode && !s.WebSocket && i && (s.WebSocket = i) : s.WebSocket = WebSocket, g.isNode || \"undefined\" == typeof EventSource || s.EventSource ? g.isNode && !s.EventSource && void 0 !== r && (s.EventSource = r) : s.EventSource = EventSource, this.$ = s.httpClient || new H(this.u), this.q = \"Disconnected\", this.M = !1, this.Pt = s, this.onreceive = null, this.onclose = null;\n      }\n\n      _createClass(J, [{\n        key: \"start\",\n        value: function () {\n          var _start = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee15(t) {\n            var _t13, _t14;\n\n            return regeneratorRuntime.wrap(function _callee15$(_context15) {\n              while (1) {\n                switch (_context15.prev = _context15.next) {\n                  case 0:\n                    if (!(t = t || O.Binary, w.isIn(t, O, \"transferFormat\"), this.u.log(e.Debug, \"Starting connection with transfer format '\".concat(O[t], \"'.\")), \"Disconnected\" !== this.q)) {\n                      _context15.next = 2;\n                      break;\n                    }\n\n                    return _context15.abrupt(\"return\", Promise.reject(new Error(\"Cannot start an HttpConnection that is not in the 'Disconnected' state.\")));\n\n                  case 2:\n                    this.q = \"Connecting\";\n                    this.Xt = this.F(t);\n                    _context15.next = 6;\n                    return this.Xt;\n\n                  case 6:\n                    if (!(\"Disconnecting\" === this.q)) {\n                      _context15.next = 12;\n                      break;\n                    }\n\n                    _t13 = \"Failed to start the HttpConnection before stop() was called.\";\n                    this.u.log(e.Error, _t13);\n                    _context15.next = 11;\n                    return this.tt;\n\n                  case 11:\n                    return _context15.abrupt(\"return\", Promise.reject(new Error(_t13)));\n\n                  case 12:\n                    if (!(\"Connected\" !== this.q)) {\n                      _context15.next = 15;\n                      break;\n                    }\n\n                    _t14 = \"HttpConnection.startInternal completed gracefully but didn't enter the connection into the connected state!\";\n                    return _context15.abrupt(\"return\", (this.u.log(e.Error, _t14), Promise.reject(new Error(_t14))));\n\n                  case 15:\n                    this.M = !0;\n\n                  case 16:\n                  case \"end\":\n                    return _context15.stop();\n                }\n              }\n            }, _callee15, this);\n          }));\n\n          function start(_x20) {\n            return _start.apply(this, arguments);\n          }\n\n          return start;\n        }()\n      }, {\n        key: \"send\",\n        value: function send(t) {\n          return \"Connected\" !== this.q ? Promise.reject(new Error(\"Cannot send data if the connection is not in the 'Connected' State.\")) : (this.Jt || (this.Jt = new z(this.transport)), this.Jt.send(t));\n        }\n      }, {\n        key: \"stop\",\n        value: function () {\n          var _stop3 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee16(t) {\n            var _this26 = this;\n\n            return regeneratorRuntime.wrap(function _callee16$(_context16) {\n              while (1) {\n                switch (_context16.prev = _context16.next) {\n                  case 0:\n                    if (!(\"Disconnected\" === this.q)) {\n                      _context16.next = 4;\n                      break;\n                    }\n\n                    _context16.t0 = (this.u.log(e.Debug, \"Call to HttpConnection.stop(\".concat(t, \") ignored because the connection is already in the disconnected state.\")), Promise.resolve());\n                    _context16.next = 16;\n                    break;\n\n                  case 4:\n                    if (!(\"Disconnecting\" === this.q)) {\n                      _context16.next = 8;\n                      break;\n                    }\n\n                    _context16.t1 = (this.u.log(e.Debug, \"Call to HttpConnection.stop(\".concat(t, \") ignored because the connection is already in the disconnecting state.\")), this.tt);\n                    _context16.next = 15;\n                    break;\n\n                  case 8:\n                    this.q = \"Disconnecting\";\n                    this.tt = new Promise(function (t) {\n                      _this26.jt = t;\n                    });\n                    _context16.next = 12;\n                    return this.et(t);\n\n                  case 12:\n                    _context16.next = 14;\n                    return this.tt;\n\n                  case 14:\n                    _context16.t1 = void _context16.sent;\n\n                  case 15:\n                    _context16.t0 = _context16.t1;\n\n                  case 16:\n                    return _context16.abrupt(\"return\", _context16.t0);\n\n                  case 17:\n                  case \"end\":\n                    return _context16.stop();\n                }\n              }\n            }, _callee16, this);\n          }));\n\n          function stop(_x21) {\n            return _stop3.apply(this, arguments);\n          }\n\n          return stop;\n        }()\n      }, {\n        key: \"et\",\n        value: function () {\n          var _et = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee17(t) {\n            return regeneratorRuntime.wrap(function _callee17$(_context17) {\n              while (1) {\n                switch (_context17.prev = _context17.next) {\n                  case 0:\n                    this.zt = t;\n                    _context17.prev = 1;\n                    _context17.next = 4;\n                    return this.Xt;\n\n                  case 4:\n                    _context17.next = 8;\n                    break;\n\n                  case 6:\n                    _context17.prev = 6;\n                    _context17.t0 = _context17[\"catch\"](1);\n\n                  case 8:\n                    if (!this.transport) {\n                      _context17.next = 20;\n                      break;\n                    }\n\n                    _context17.prev = 9;\n                    _context17.next = 12;\n                    return this.transport.stop();\n\n                  case 12:\n                    _context17.next = 17;\n                    break;\n\n                  case 14:\n                    _context17.prev = 14;\n                    _context17.t1 = _context17[\"catch\"](9);\n                    this.u.log(e.Error, \"HttpConnection.transport.stop() threw error '\".concat(_context17.t1, \"'.\")), this.Vt();\n\n                  case 17:\n                    this.transport = void 0;\n                    _context17.next = 21;\n                    break;\n\n                  case 20:\n                    this.u.log(e.Debug, \"HttpConnection.transport is undefined in HttpConnection.stop() because start() failed.\");\n\n                  case 21:\n                  case \"end\":\n                    return _context17.stop();\n                }\n              }\n            }, _callee17, this, [[1, 6], [9, 14]]);\n          }));\n\n          function et(_x22) {\n            return _et.apply(this, arguments);\n          }\n\n          return et;\n        }()\n      }, {\n        key: \"F\",\n        value: function () {\n          var _F3 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee18(t) {\n            var _this27 = this;\n\n            var s, _e8, _n12;\n\n            return regeneratorRuntime.wrap(function _callee18$(_context18) {\n              while (1) {\n                switch (_context18.prev = _context18.next) {\n                  case 0:\n                    s = this.baseUrl;\n                    this.St = this.Pt.accessTokenFactory;\n                    _context18.prev = 2;\n\n                    if (!this.Pt.skipNegotiation) {\n                      _context18.next = 11;\n                      break;\n                    }\n\n                    if (!(this.Pt.transport !== W.WebSockets)) {\n                      _context18.next = 6;\n                      break;\n                    }\n\n                    throw new Error(\"Negotiation can only be skipped when using the WebSocket transport directly.\");\n\n                  case 6:\n                    this.transport = this.Gt(W.WebSockets);\n                    _context18.next = 9;\n                    return this.Kt(s, t);\n\n                  case 9:\n                    _context18.next = 28;\n                    break;\n\n                  case 11:\n                    _e8 = null, _n12 = 0;\n\n                  case 12:\n                    _context18.next = 14;\n                    return this.Qt(s);\n\n                  case 14:\n                    _e8 = _context18.sent;\n\n                    if (!(\"Disconnecting\" === this.q || \"Disconnected\" === this.q)) {\n                      _context18.next = 17;\n                      break;\n                    }\n\n                    throw new Error(\"The connection was stopped during negotiation.\");\n\n                  case 17:\n                    if (!_e8.error) {\n                      _context18.next = 19;\n                      break;\n                    }\n\n                    throw new Error(_e8.error);\n\n                  case 19:\n                    if (!_e8.ProtocolVersion) {\n                      _context18.next = 21;\n                      break;\n                    }\n\n                    throw new Error(\"Detected a connection attempt to an ASP.NET SignalR Server. This client only supports connecting to an ASP.NET Core SignalR Server. See https://aka.ms/signalr-core-differences for details.\");\n\n                  case 21:\n                    if (_e8.url && (s = _e8.url), _e8.accessToken) {\n                      (function () {\n                        var t = _e8.accessToken;\n\n                        _this27.St = function () {\n                          return t;\n                        };\n                      })();\n                    }\n\n                    _n12++;\n\n                  case 23:\n                    if (_e8.url && _n12 < 100) {\n                      _context18.next = 12;\n                      break;\n                    }\n\n                  case 24:\n                    if (!(100 === _n12 && _e8.url)) {\n                      _context18.next = 26;\n                      break;\n                    }\n\n                    throw new Error(\"Negotiate redirection limit exceeded.\");\n\n                  case 26:\n                    _context18.next = 28;\n                    return this.Yt(s, this.Pt.transport, _e8, t);\n\n                  case 28:\n                    this.transport instanceof _F2 && (this.features.inherentKeepAlive = !0), \"Connecting\" === this.q && (this.u.log(e.Debug, \"The HttpConnection connected successfully.\"), this.q = \"Connected\");\n                    _context18.next = 34;\n                    break;\n\n                  case 31:\n                    _context18.prev = 31;\n                    _context18.t0 = _context18[\"catch\"](2);\n                    return _context18.abrupt(\"return\", (this.u.log(e.Error, \"Failed to start the connection: \" + _context18.t0), this.q = \"Disconnected\", this.transport = void 0, this.jt(), Promise.reject(_context18.t0)));\n\n                  case 34:\n                  case \"end\":\n                    return _context18.stop();\n                }\n              }\n            }, _callee18, this, [[2, 31]]);\n          }));\n\n          function F(_x23) {\n            return _F3.apply(this, arguments);\n          }\n\n          return F;\n        }()\n      }, {\n        key: \"Qt\",\n        value: function () {\n          var _Qt = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee19(t) {\n            var s, _t15, _$9, _$10, i, r, o, _t16, _e9, _s11;\n\n            return regeneratorRuntime.wrap(function _callee19$(_context19) {\n              while (1) {\n                switch (_context19.prev = _context19.next) {\n                  case 0:\n                    s = {};\n\n                    if (!this.St) {\n                      _context19.next = 6;\n                      break;\n                    }\n\n                    _context19.next = 4;\n                    return this.St();\n\n                  case 4:\n                    _t15 = _context19.sent;\n                    _t15 && (s[M.Authorization] = \"Bearer \".concat(_t15));\n\n                  case 6:\n                    _$9 = $(), _$10 = _slicedToArray(_$9, 2), i = _$10[0], r = _$10[1];\n                    s[i] = r;\n                    o = this.Zt(t);\n                    this.u.log(e.Debug, \"Sending negotiation request: \".concat(o, \".\"));\n                    _context19.prev = 10;\n                    _context19.next = 13;\n                    return this.$.post(o, {\n                      content: \"\",\n                      headers: _objectSpread(_objectSpread({}, s), this.Pt.headers),\n                      timeout: this.Pt.timeout,\n                      withCredentials: this.Pt.withCredentials\n                    });\n\n                  case 13:\n                    _t16 = _context19.sent;\n\n                    if (!(200 !== _t16.statusCode)) {\n                      _context19.next = 16;\n                      break;\n                    }\n\n                    return _context19.abrupt(\"return\", Promise.reject(new Error(\"Unexpected status code returned from negotiate '\".concat(_t16.statusCode, \"'\"))));\n\n                  case 16:\n                    _e9 = JSON.parse(_t16.content);\n                    return _context19.abrupt(\"return\", ((!_e9.negotiateVersion || _e9.negotiateVersion < 1) && (_e9.connectionToken = _e9.connectionId), _e9));\n\n                  case 20:\n                    _context19.prev = 20;\n                    _context19.t0 = _context19[\"catch\"](10);\n                    _s11 = \"Failed to complete negotiation with the server: \" + _context19.t0;\n                    return _context19.abrupt(\"return\", (_context19.t0 instanceof n && 404 === _context19.t0.statusCode && (_s11 += \" Either this is not a SignalR endpoint or there is a proxy blocking the connection.\"), this.u.log(e.Error, _s11), Promise.reject(new a(_s11))));\n\n                  case 24:\n                  case \"end\":\n                    return _context19.stop();\n                }\n              }\n            }, _callee19, this, [[10, 20]]);\n          }));\n\n          function Qt(_x24) {\n            return _Qt.apply(this, arguments);\n          }\n\n          return Qt;\n        }()\n      }, {\n        key: \"te\",\n        value: function te(t, e) {\n          return e ? t + (-1 === t.indexOf(\"?\") ? \"?\" : \"&\") + \"id=\".concat(e) : t;\n        }\n      }, {\n        key: \"Yt\",\n        value: function () {\n          var _Yt = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee20(t, s, n, i) {\n            var r, o, h, a, _iterator5, _step5, _n13, _h, _t17;\n\n            return regeneratorRuntime.wrap(function _callee20$(_context20) {\n              while (1) {\n                switch (_context20.prev = _context20.next) {\n                  case 0:\n                    r = this.te(t, n.connectionToken);\n\n                    if (!this.ee(s)) {\n                      _context20.next = 7;\n                      break;\n                    }\n\n                    this.u.log(e.Debug, \"Connection was provided an instance of ITransport, using that directly.\");\n                    this.transport = s;\n                    _context20.next = 6;\n                    return this.Kt(r, i);\n\n                  case 6:\n                    return _context20.abrupt(\"return\", void (this.connectionId = n.connectionId));\n\n                  case 7:\n                    o = [], h = n.availableTransports || [];\n                    a = n;\n                    _iterator5 = _createForOfIteratorHelper(h);\n                    _context20.prev = 10;\n\n                    _iterator5.s();\n\n                  case 12:\n                    if ((_step5 = _iterator5.n()).done) {\n                      _context20.next = 44;\n                      break;\n                    }\n\n                    _n13 = _step5.value;\n                    _h = this.se(_n13, s, i);\n\n                    if (!(_h instanceof Error)) {\n                      _context20.next = 19;\n                      break;\n                    }\n\n                    o.push(\"\".concat(_n13.transport, \" failed:\")), o.push(_h);\n                    _context20.next = 42;\n                    break;\n\n                  case 19:\n                    if (!this.ee(_h)) {\n                      _context20.next = 42;\n                      break;\n                    }\n\n                    if (!(this.transport = _h, !a)) {\n                      _context20.next = 31;\n                      break;\n                    }\n\n                    _context20.prev = 21;\n                    _context20.next = 24;\n                    return this.Qt(t);\n\n                  case 24:\n                    a = _context20.sent;\n                    _context20.next = 30;\n                    break;\n\n                  case 27:\n                    _context20.prev = 27;\n                    _context20.t0 = _context20[\"catch\"](21);\n                    return _context20.abrupt(\"return\", Promise.reject(_context20.t0));\n\n                  case 30:\n                    r = this.te(t, a.connectionToken);\n\n                  case 31:\n                    _context20.prev = 31;\n                    _context20.next = 34;\n                    return this.Kt(r, i);\n\n                  case 34:\n                    return _context20.abrupt(\"return\", void (this.connectionId = a.connectionId));\n\n                  case 37:\n                    _context20.prev = 37;\n                    _context20.t1 = _context20[\"catch\"](31);\n\n                    if (!(this.u.log(e.Error, \"Failed to start the transport '\".concat(_n13.transport, \"': \").concat(_context20.t1)), a = void 0, o.push(new c(\"\".concat(_n13.transport, \" failed: \").concat(_context20.t1), W[_n13.transport])), \"Connecting\" !== this.q)) {\n                      _context20.next = 42;\n                      break;\n                    }\n\n                    _t17 = \"Failed to select transport before stop() was called.\";\n                    return _context20.abrupt(\"return\", (this.u.log(e.Debug, _t17), Promise.reject(new Error(_t17))));\n\n                  case 42:\n                    _context20.next = 12;\n                    break;\n\n                  case 44:\n                    _context20.next = 49;\n                    break;\n\n                  case 46:\n                    _context20.prev = 46;\n                    _context20.t2 = _context20[\"catch\"](10);\n\n                    _iterator5.e(_context20.t2);\n\n                  case 49:\n                    _context20.prev = 49;\n\n                    _iterator5.f();\n\n                    return _context20.finish(49);\n\n                  case 52:\n                    return _context20.abrupt(\"return\", o.length > 0 ? Promise.reject(new l(\"Unable to connect to the server with any of the available transports. \".concat(o.join(\" \")), o)) : Promise.reject(new Error(\"None of the transports supported by the client are supported by the server.\")));\n\n                  case 53:\n                  case \"end\":\n                    return _context20.stop();\n                }\n              }\n            }, _callee20, this, [[10, 46, 49, 52], [21, 27], [31, 37]]);\n          }));\n\n          function Yt(_x25, _x26, _x27, _x28) {\n            return _Yt.apply(this, arguments);\n          }\n\n          return Yt;\n        }()\n      }, {\n        key: \"Gt\",\n        value: function Gt(t) {\n          switch (t) {\n            case W.WebSockets:\n              if (!this.Pt.WebSocket) throw new Error(\"'WebSocket' is not supported in your environment.\");\n              return new X(this.$, this.St, this.u, this.Pt.logMessageContent, this.Pt.WebSocket, this.Pt.headers || {});\n\n            case W.ServerSentEvents:\n              if (!this.Pt.EventSource) throw new Error(\"'EventSource' is not supported in your environment.\");\n              return new B(this.$, this.St, this.u, this.Pt);\n\n            case W.LongPolling:\n              return new _F2(this.$, this.St, this.u, this.Pt);\n\n            default:\n              throw new Error(\"Unknown transport: \".concat(t, \".\"));\n          }\n        }\n      }, {\n        key: \"Kt\",\n        value: function Kt(t, e) {\n          var _this28 = this;\n\n          return this.transport.onreceive = this.onreceive, this.transport.onclose = function (t) {\n            return _this28.Vt(t);\n          }, this.transport.connect(t, e);\n        }\n      }, {\n        key: \"se\",\n        value: function se(t, s, n) {\n          var i = W[t.transport];\n          if (null == i) return this.u.log(e.Debug, \"Skipping transport '\".concat(t.transport, \"' because it is not supported by this client.\")), new Error(\"Skipping transport '\".concat(t.transport, \"' because it is not supported by this client.\"));\n          if (!function (t, e) {\n            return !t || 0 != (e & t);\n          }(s, i)) return this.u.log(e.Debug, \"Skipping transport '\".concat(W[i], \"' because it was disabled by the client.\")), new h(\"'\".concat(W[i], \"' is disabled by the client.\"), i);\n          if (!(t.transferFormats.map(function (t) {\n            return O[t];\n          }).indexOf(n) >= 0)) return this.u.log(e.Debug, \"Skipping transport '\".concat(W[i], \"' because it does not support the requested transfer format '\").concat(O[n], \"'.\")), new Error(\"'\".concat(W[i], \"' does not support \").concat(O[n], \".\"));\n          if (i === W.WebSockets && !this.Pt.WebSocket || i === W.ServerSentEvents && !this.Pt.EventSource) return this.u.log(e.Debug, \"Skipping transport '\".concat(W[i], \"' because it is not supported in your environment.'\")), new o(\"'\".concat(W[i], \"' is not supported in your environment.\"), i);\n          this.u.log(e.Debug, \"Selecting transport '\".concat(W[i], \"'.\"));\n\n          try {\n            return this.Gt(i);\n          } catch (t) {\n            return t;\n          }\n        }\n      }, {\n        key: \"ee\",\n        value: function ee(t) {\n          return t && \"object\" == _typeof(t) && \"connect\" in t;\n        }\n      }, {\n        key: \"Vt\",\n        value: function Vt(t) {\n          var _this29 = this;\n\n          if (this.u.log(e.Debug, \"HttpConnection.stopConnection(\".concat(t, \") called while in state \").concat(this.q, \".\")), this.transport = void 0, t = this.zt || t, this.zt = void 0, \"Disconnected\" !== this.q) {\n            if (\"Connecting\" === this.q) throw this.u.log(e.Warning, \"Call to HttpConnection.stopConnection(\".concat(t, \") was ignored because the connection is still in the connecting state.\")), new Error(\"HttpConnection.stopConnection(\".concat(t, \") was called while the connection is still in the connecting state.\"));\n\n            if (\"Disconnecting\" === this.q && this.jt(), t ? this.u.log(e.Error, \"Connection disconnected with error '\".concat(t, \"'.\")) : this.u.log(e.Information, \"Connection disconnected.\"), this.Jt && (this.Jt.stop()[\"catch\"](function (t) {\n              _this29.u.log(e.Error, \"TransportSendQueue.stop() threw error '\".concat(t, \"'.\"));\n            }), this.Jt = void 0), this.connectionId = void 0, this.q = \"Disconnected\", this.M) {\n              this.M = !1;\n\n              try {\n                this.onclose && this.onclose(t);\n              } catch (s) {\n                this.u.log(e.Error, \"HttpConnection.onclose(\".concat(t, \") threw error '\").concat(s, \"'.\"));\n              }\n            }\n          } else this.u.log(e.Debug, \"Call to HttpConnection.stopConnection(\".concat(t, \") was ignored because the connection is already in the disconnected state.\"));\n        }\n      }, {\n        key: \"Bt\",\n        value: function Bt(t) {\n          if (0 === t.lastIndexOf(\"https://\", 0) || 0 === t.lastIndexOf(\"http://\", 0)) return t;\n          if (!g.isBrowser || !window.document) throw new Error(\"Cannot resolve '\".concat(t, \"'.\"));\n          var s = window.document.createElement(\"a\");\n          return s.href = t, this.u.log(e.Information, \"Normalizing '\".concat(t, \"' to '\").concat(s.href, \"'.\")), s.href;\n        }\n      }, {\n        key: \"Zt\",\n        value: function Zt(t) {\n          var e = t.indexOf(\"?\");\n          var s = t.substring(0, -1 === e ? t.length : e);\n          return \"/\" !== s[s.length - 1] && (s += \"/\"), s += \"negotiate\", s += -1 === e ? \"\" : t.substring(e), -1 === s.indexOf(\"negotiateVersion\") && (s += -1 === e ? \"?\" : \"&\", s += \"negotiateVersion=\" + this.Ft), s;\n        }\n      }]);\n\n      return J;\n    }();\n\n    var z = /*#__PURE__*/function () {\n      function z(t) {\n        _classCallCheck(this, z);\n\n        this.ne = t, this.ie = [], this.re = !0, this.oe = new V(), this.he = new V(), this.ce = this.ae();\n      }\n\n      _createClass(z, [{\n        key: \"send\",\n        value: function send(t) {\n          return this.le(t), this.he || (this.he = new V()), this.he.promise;\n        }\n      }, {\n        key: \"stop\",\n        value: function stop() {\n          return this.re = !1, this.oe.resolve(), this.ce;\n        }\n      }, {\n        key: \"le\",\n        value: function le(t) {\n          if (this.ie.length && _typeof(this.ie[0]) != _typeof(t)) throw new Error(\"Expected data to be of type \".concat(_typeof(this.ie), \" but was of type \").concat(_typeof(t)));\n          this.ie.push(t), this.oe.resolve();\n        }\n      }, {\n        key: \"ae\",\n        value: function () {\n          var _ae = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee21() {\n            var _t18, _e10;\n\n            return regeneratorRuntime.wrap(function _callee21$(_context21) {\n              while (1) {\n                switch (_context21.prev = _context21.next) {\n                  case 0:\n                    _context21.next = 2;\n                    return this.oe.promise;\n\n                  case 2:\n                    if (this.re) {\n                      _context21.next = 5;\n                      break;\n                    }\n\n                    this.he && this.he.reject(\"Connection stopped.\");\n                    return _context21.abrupt(\"break\", 21);\n\n                  case 5:\n                    this.oe = new V();\n                    _t18 = this.he;\n                    this.he = void 0;\n                    _e10 = \"string\" == typeof this.ie[0] ? this.ie.join(\"\") : z.ue(this.ie);\n                    this.ie.length = 0;\n                    _context21.prev = 10;\n                    _context21.next = 13;\n                    return this.ne.send(_e10);\n\n                  case 13:\n                    _t18.resolve();\n\n                    _context21.next = 19;\n                    break;\n\n                  case 16:\n                    _context21.prev = 16;\n                    _context21.t0 = _context21[\"catch\"](10);\n\n                    _t18.reject(_context21.t0);\n\n                  case 19:\n                    _context21.next = 0;\n                    break;\n\n                  case 21:\n                  case \"end\":\n                    return _context21.stop();\n                }\n              }\n            }, _callee21, this, [[10, 16]]);\n          }));\n\n          function ae() {\n            return _ae.apply(this, arguments);\n          }\n\n          return ae;\n        }()\n      }], [{\n        key: \"ue\",\n        value: function ue(t) {\n          var e = t.map(function (t) {\n            return t.byteLength;\n          }).reduce(function (t, e) {\n            return t + e;\n          }),\n              s = new Uint8Array(e);\n          var n = 0;\n\n          var _iterator6 = _createForOfIteratorHelper(t),\n              _step6;\n\n          try {\n            for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n              var _e11 = _step6.value;\n              s.set(new Uint8Array(_e11), n), n += _e11.byteLength;\n            }\n          } catch (err) {\n            _iterator6.e(err);\n          } finally {\n            _iterator6.f();\n          }\n\n          return s.buffer;\n        }\n      }]);\n\n      return z;\n    }();\n\n    var V = /*#__PURE__*/function () {\n      function V() {\n        var _this30 = this;\n\n        _classCallCheck(this, V);\n\n        this.promise = new Promise(function (t, e) {\n          var _ref2;\n\n          return _ref2 = [t, e], _this30.de = _ref2[0], _this30.fe = _ref2[1], _ref2;\n        });\n      }\n\n      _createClass(V, [{\n        key: \"resolve\",\n        value: function resolve() {\n          this.de();\n        }\n      }, {\n        key: \"reject\",\n        value: function reject(t) {\n          this.fe(t);\n        }\n      }]);\n\n      return V;\n    }();\n\n    var G = /*#__PURE__*/function () {\n      function G() {\n        _classCallCheck(this, G);\n\n        this.name = \"json\", this.version = 1, this.transferFormat = O.Text;\n      }\n\n      _createClass(G, [{\n        key: \"parseMessages\",\n        value: function parseMessages(t, s) {\n          if (\"string\" != typeof t) throw new Error(\"Invalid input for JSON hub protocol. Expected a string.\");\n          if (!t) return [];\n          null === s && (s = f.instance);\n          var n = D.parse(t),\n              i = [];\n\n          var _iterator7 = _createForOfIteratorHelper(n),\n              _step7;\n\n          try {\n            for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {\n              var _t19 = _step7.value;\n\n              var _n14 = JSON.parse(_t19);\n\n              if (\"number\" != typeof _n14.type) throw new Error(\"Invalid payload.\");\n\n              switch (_n14.type) {\n                case A.Invocation:\n                  this.pe(_n14);\n                  break;\n\n                case A.StreamItem:\n                  this.we(_n14);\n                  break;\n\n                case A.Completion:\n                  this.ge(_n14);\n                  break;\n\n                case A.Ping:\n                case A.Close:\n                  break;\n\n                default:\n                  s.log(e.Information, \"Unknown message type '\" + _n14.type + \"' ignored.\");\n                  continue;\n              }\n\n              i.push(_n14);\n            }\n          } catch (err) {\n            _iterator7.e(err);\n          } finally {\n            _iterator7.f();\n          }\n\n          return i;\n        }\n      }, {\n        key: \"writeMessage\",\n        value: function writeMessage(t) {\n          return D.write(JSON.stringify(t));\n        }\n      }, {\n        key: \"pe\",\n        value: function pe(t) {\n          this.me(t.target, \"Invalid payload for Invocation message.\"), void 0 !== t.invocationId && this.me(t.invocationId, \"Invalid payload for Invocation message.\");\n        }\n      }, {\n        key: \"we\",\n        value: function we(t) {\n          if (this.me(t.invocationId, \"Invalid payload for StreamItem message.\"), void 0 === t.item) throw new Error(\"Invalid payload for StreamItem message.\");\n        }\n      }, {\n        key: \"ge\",\n        value: function ge(t) {\n          if (t.result && t.error) throw new Error(\"Invalid payload for Completion message.\");\n          !t.result && t.error && this.me(t.error, \"Invalid payload for Completion message.\"), this.me(t.invocationId, \"Invalid payload for Completion message.\");\n        }\n      }, {\n        key: \"me\",\n        value: function me(t, e) {\n          if (\"string\" != typeof t || \"\" === t) throw new Error(e);\n        }\n      }]);\n\n      return G;\n    }();\n\n    var K = {\n      trace: e.Trace,\n      debug: e.Debug,\n      info: e.Information,\n      information: e.Information,\n      warn: e.Warning,\n      warning: e.Warning,\n      error: e.Error,\n      critical: e.Critical,\n      none: e.None\n    };\n\n    var Q = /*#__PURE__*/function () {\n      function Q() {\n        _classCallCheck(this, Q);\n      }\n\n      _createClass(Q, [{\n        key: \"configureLogging\",\n        value: function configureLogging(t) {\n          if (w.isRequired(t, \"logging\"), void 0 !== t.log) this.logger = t;else if (\"string\" == typeof t) {\n            var _e12 = function (t) {\n              var e = K[t.toLowerCase()];\n              if (void 0 !== e) return e;\n              throw new Error(\"Unknown log level: \".concat(t));\n            }(t);\n\n            this.logger = new E(_e12);\n          } else this.logger = new E(t);\n          return this;\n        }\n      }, {\n        key: \"withUrl\",\n        value: function withUrl(t, e) {\n          return w.isRequired(t, \"url\"), w.isNotEmpty(t, \"url\"), this.url = t, this.httpConnectionOptions = \"object\" == _typeof(e) ? _objectSpread(_objectSpread({}, this.httpConnectionOptions), e) : _objectSpread(_objectSpread({}, this.httpConnectionOptions), {}, {\n            transport: e\n          }), this;\n        }\n      }, {\n        key: \"withHubProtocol\",\n        value: function withHubProtocol(t) {\n          return w.isRequired(t, \"protocol\"), this.protocol = t, this;\n        }\n      }, {\n        key: \"withAutomaticReconnect\",\n        value: function withAutomaticReconnect(t) {\n          if (this.reconnectPolicy) throw new Error(\"A reconnectPolicy has already been set.\");\n          return t ? Array.isArray(t) ? this.reconnectPolicy = new q(t) : this.reconnectPolicy = t : this.reconnectPolicy = new q(), this;\n        }\n      }, {\n        key: \"build\",\n        value: function build() {\n          var t = this.httpConnectionOptions || {};\n          if (void 0 === t.logger && (t.logger = this.logger), !this.url) throw new Error(\"The 'HubConnectionBuilder.withUrl' method must be called before building the connection.\");\n          var e = new J(this.url, t);\n          return L.create(e, this.logger || f.instance, this.protocol || new G(), this.reconnectPolicy);\n        }\n      }]);\n\n      return Q;\n    }();\n\n    return Uint8Array.prototype.indexOf || Object.defineProperty(Uint8Array.prototype, \"indexOf\", {\n      value: Array.prototype.indexOf,\n      writable: !0\n    }), Uint8Array.prototype.slice || Object.defineProperty(Uint8Array.prototype, \"slice\", {\n      value: function value(t, e) {\n        return new Uint8Array(Array.prototype.slice.call(this, t, e));\n      },\n      writable: !0\n    }), Uint8Array.prototype.forEach || Object.defineProperty(Uint8Array.prototype, \"forEach\", {\n      value: Array.prototype.forEach,\n      writable: !0\n    }), s;\n  }();\n}, \"object\" == ( false ? 0 : _typeof(exports)) && \"object\" == ( false ? 0 : _typeof(module)) ? module.exports = e() :  true ? !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (e),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : 0;\n\n//# sourceURL=webpack://vngageStreamLib/./node_modules/@microsoft/signalr/dist/browser/signalr.js?");

/***/ }),

/***/ "./node_modules/ws/browser.js":
/*!************************************!*\
  !*** ./node_modules/ws/browser.js ***!
  \************************************/
/***/ (function(module) {

"use strict";
eval("\n\nmodule.exports = function () {\n  throw new Error(\n    'ws does not work in the browser. Browser clients must use the native ' +\n      'WebSocket object'\n  );\n};\n\n\n//# sourceURL=webpack://vngageStreamLib/./node_modules/ws/browser.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			id: moduleId,
/******/ 			loaded: false,
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/node module decorator */
/******/ 	!function() {
/******/ 		__webpack_require__.nmd = function(module) {
/******/ 			module.paths = [];
/******/ 			if (!module.children) module.children = [];
/******/ 			return module;
/******/ 		};
/******/ 	}();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/VngageStream_deps.js");
/******/ 	
/******/ 	return __webpack_exports__;
/******/ })()
;
});