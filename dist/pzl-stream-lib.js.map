{"version":3,"file":"pzl-stream-lib.js","mappings":"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","sources":["webpack://pzl-stream-lib/./src/BrokerFSM.js","webpack://pzl-stream-lib/./src/Stream.js","webpack://pzl-stream-lib/./src/StreamConnector.js","webpack://pzl-stream-lib/./src/StreamErrors.js","webpack://pzl-stream-lib/./src/StreamEventTypes.js","webpack://pzl-stream-lib/./src/StreamSubscription.js","webpack://pzl-stream-lib/./src/StreamUtils.js","webpack://pzl-stream-lib/./src/SubscriptionsStore.js","webpack://pzl-stream-lib/./node_modules/stately.js/Stately.js","webpack://pzl-stream-lib/external module \"@microsoft/signalr\"","webpack://pzl-stream-lib/./node_modules/@babel/runtime/helpers/esm/defineProperty.js","webpack://pzl-stream-lib/./node_modules/@babel/runtime/helpers/esm/toPrimitive.js","webpack://pzl-stream-lib/./node_modules/@babel/runtime/helpers/esm/toPropertyKey.js","webpack://pzl-stream-lib/./node_modules/@babel/runtime/helpers/esm/typeof.js","webpack://pzl-stream-lib/webpack/bootstrap","webpack://pzl-stream-lib/webpack/runtime/compat get default export","webpack://pzl-stream-lib/webpack/runtime/define property getters","webpack://pzl-stream-lib/webpack/runtime/hasOwnProperty shorthand","webpack://pzl-stream-lib/webpack/runtime/make namespace object","webpack://pzl-stream-lib/./src/PzlStream.js"],"sourcesContent":["import Stately from 'stately.js';\r\nimport { noDebug } from './StreamUtils';\r\n\r\nconst reconnectRetryDelay = 10;\r\nconst reconnectMaxRetries = 12; // 12 retries รก 10 sec = 2 minutes\r\n\r\nexport const initBrokerConnectionFsm = (externals, brokerEventCallbacks = {}, debug) => {\r\n    /*******************************************************************************************\r\n     ** brokerConnection state machine\r\n     * Using https://github.com/fschaefer/Stately.js\r\n     *******************************************************************************************/\r\n    debug = debug || noDebug;\r\n    debug.log('initBrokerConnectionFsm');\r\n\r\n    const fsm_state = {\r\n        fsm: null,\r\n        connection: null,\r\n        reconnectCounter: 0,\r\n        eventListeners: {},\r\n        brokerEventCallbacks\r\n    };\r\n\r\n    const handle = (action, ...args) => fsm_state.fsm[action](...args);\r\n    const on = (eventName, callback) => {\r\n        fsm_state.eventListeners[eventName] = (fsm_state.eventListeners[eventName] || []).concat(callback);\r\n        return {\r\n            eventName: eventName,\r\n            callback: callback,\r\n            off: () => {\r\n                off(eventName, callback);\r\n            }\r\n        }\r\n    }\r\n    const off = (eventName, callback) => {\r\n        fsm_state.eventListeners[eventName] = (fsm_state.eventListeners[eventName] || []).filter(cb => callback && cb !== callback);\r\n    }\r\n    const emitEvent = (eventName, ...args) => {\r\n        (fsm_state.eventListeners[eventName] || []).forEach(function (callback) {\r\n            callback.call(this, ...args);\r\n        }.bind(this));\r\n    }\r\n\r\n    const fsmStates = {\r\n        disconnected: {\r\n            _onEnter: function () {\r\n                debug.log('FSM: disconnected._onEnter()');\r\n                fsm_state.connection = null;\r\n            },\r\n            connect: function () {\r\n                return this.connecting;\r\n            }\r\n        },\r\n        connecting: {\r\n            _onEnter: function () {\r\n                debug.log('FSM: connecting._onEnter()');\r\n                externals._connect();\r\n            },\r\n            connection_ok: function (connection) {\r\n                fsm_state.connection = connection;\r\n                return this.connected;\r\n            },\r\n            connection_failed: function (err) {\r\n                return this.disconnected;\r\n            },\r\n            disconnect: function () {\r\n                return this.disconnecting;\r\n            }\r\n        },\r\n        connected: {\r\n            _onEnter: function (action, prevState) {\r\n                debug.log('FSM: connected._onEnter()', action, prevState);\r\n                if (prevState === 'reconnecting') {\r\n                    // If coming here from 'reconnecting', we should resubscribe all subscriptions\r\n                    // (can't be done in 'reconnecting', since reSubscribeAll() will only work in state 'connected'!)\r\n                    externals.reSubscribeAll();\r\n                }\r\n                typeof fsm_state?.brokerEventCallbacks?.onConnectionStarted === 'function' && fsm_state.brokerEventCallbacks.onConnectionStarted(fsm_state.connection);\r\n            },\r\n            connection_failed: function () {\r\n                // Broker connection closed in \"connected\"-state - try to auto-reconnect to broker...\r\n                typeof fsm_state?.brokerEventCallbacks?.onConnectionFailed === 'function' && fsm_state.brokerEventCallbacks.onConnectionFailed('connection failed');\r\n                fsm_state.connection = null;\r\n                fsm_state.reconnectCounter = 0;\r\n                return this.reconnect_wait;\r\n            },\r\n            disconnect: function () {\r\n                return this.disconnecting;\r\n            }\r\n        },\r\n        reconnect_wait: {\r\n            _onEnter: function () {\r\n                debug.log('FSM: reconnect_wait._onEnter()');\r\n                if (fsm_state.reconnectCounter < reconnectMaxRetries) {\r\n                    handle('schedule_reconnect');\r\n                } else { // i.e. don't try to reconnect even once if reconnectMaxRetries <= 0\r\n                    handle('reconnection_failed');\r\n                }\r\n            },\r\n            schedule_reconnect: function () {\r\n                debug.log('FSM reconnect_wait.schedule_reconnect(): Reconnecting to broker in ' + reconnectRetryDelay + ' sec...');\r\n                clearTimeout(fsm_state.reconnectTimer);\t// Just make sure no other reconnects are already scheduled (should not happen, but maybe SignalR's connection.onclose() *could* be fired twice in that case we'd end up here twice before handling the 'reconnect'-action...)\r\n                fsm_state.reconnectTimer = setTimeout(function () {\r\n                    handle('connect');\r\n                }.bind(this), reconnectRetryDelay * 1000);\r\n            },\r\n            connect: function () {\r\n                return this.reconnecting;\r\n            },\r\n            disconnect: function () {\r\n                return this.disconnecting;\r\n            },\r\n            reconnection_failed: function () {\r\n                return this.disconnected;\r\n            },\r\n            _onExit: function () {\r\n                clearTimeout(fsm_state.reconnectTimer);\r\n            }\r\n        },\r\n        reconnecting: {\r\n            _onEnter: function () {\r\n                debug.log('FSM: reconnecting._onEnter()');\r\n                fsm_state.reconnectCounter++;\r\n                externals._connect();\r\n            },\r\n            connection_ok: function (connection) {\r\n                fsm_state.connection = connection;\r\n                // After successful re-connect, transition to 'connected'\r\n                // After the transition, all existing subscriptions will be re-subscribed\r\n                // (but reSubscribeAll() can only be done *AFTER* the transition because it needs to be 'connected')!\r\n                return this.connected;\r\n            },\r\n            connection_failed: function (err) {\r\n                typeof fsm_state?.brokerEventCallbacks?.onConnectionFailed === 'function' && fsm_state.brokerEventCallbacks.onConnectionFailed(err);\r\n                return this.reconnect_wait;\r\n            },\r\n            disconnect: function () {\r\n                return this.disconnecting;\r\n            }\r\n        },\r\n        disconnecting: {\r\n            _onEnter: function () {\r\n                debug.log('FSM: disconnecting._onEnter()', this);\r\n                externals.unSubscribeAll();\r\n\r\n                if (fsm_state.connection) {\r\n                    // Stop connection, ignore errors, then go to \"disconnected\"\r\n                    fsm_state.connection.stop()\r\n                        .catch(() => {})\r\n                        .finally(() => {\r\n                            handle('disconnect_ok');\r\n                        });\r\n                } else {\r\n                    // No connection to stop: Go directly to \"disconnected\"\r\n                    handle('disconnect_ok');\r\n                }\r\n            },\r\n            disconnect_ok: function () {\r\n                typeof fsm_state?.brokerEventCallbacks?.onDisconnected === 'function' && fsm_state.brokerEventCallbacks.onDisconnected();\r\n                return this.disconnected;\r\n            }\r\n        }\r\n    };\r\n\r\n    Object.keys(fsmStates).forEach(function (state) {\r\n        // Push some \"global\" events to all states (_onEnter(), _onExit()),\r\n        // as proposed by the author (https://github.com/fschaefer/Stately.js/issues/11)\r\n\r\n        // First save a ref to any existing onEnter()-event in the original state definition...\r\n        const ___onEnter = fsmStates[state].onEnter;\r\n\r\n        // Inject a re-defined onEnter() into each state that will capture state transitions.\r\n        // The new onEnter() will also call prev state's _onExit() and new state's _onEnter()\r\n        // (if they exist and if (and only if!) we actually did a transition - i.e. mimic machina.js behaviour!)\r\n        // And also call any registered state-transition-listeners...\r\n        // NOTE: There is one subtle difference from machina.js: When _onExit() is called, the state-transition has actually already occurred!!!\r\n        // (so this.getMachineState() and this.getMachineEvents() will be in the context of newState, if called from prevState's _onExit()-handler)\r\n        fsmStates[state].onEnter = function onEnter(action, prevState, newState) {\r\n            let _onEnterAction = null;\r\n            if (prevState !== newState) {\r\n                // console.log('state transition:', action, prevState, newState, this, fsm_state.fsm, fsmStates)\r\n                if (typeof fsmStates[prevState]._onExit === 'function') {\r\n                    // Call prev state's _onExit() if exists...\r\n                    fsmStates[prevState]._onExit.call(this, action, prevState, newState);\r\n                }\r\n\r\n                emitEvent('transition', { fromState: prevState, toState: newState });\r\n\r\n                if (typeof fsmStates[newState]._onEnter === 'function') {\r\n                    // Call new state's _onEnter() if exists...\r\n                    // Remember the return value to support state transition from _onEnter()\r\n                    _onEnterAction = fsmStates[newState]._onEnter.call(this, action, prevState, newState);\r\n                }\r\n            }\r\n            if (typeof ___onEnter === 'function') {\r\n                // If there was also an original onEnter()-hook in new state, call it!\r\n                // Do this, even if no actual transition occurred - i.e. preserve Stately's weird behaviour!\r\n                ___onEnter.call(this, action, prevState, newState);\r\n            }\r\n\r\n            if (_onEnterAction) {\r\n                // Allow state transition from _onEnter()\r\n                // (but only transition *AFTER* original onEnter()-hook has been executed)\r\n                this.setMachineState(_onEnterAction, '_onEnter');\r\n            }\r\n        }\r\n    });\r\n\r\n    fsm_state.fsm = new Stately(fsmStates, 'disconnected');\r\n\r\n    return {\r\n        handle,\r\n        on,\r\n        off,\r\n        getState: () => fsm_state.fsm.getMachineState(),\r\n        getConnection: () => fsm_state.connection,\r\n        setEventCallbacks: brokerEventCallbacks => fsm_state.brokerEventCallbacks = brokerEventCallbacks,\r\n    }\r\n}\r\n","const get = (connection, subscription, fromId) => {\r\n    const method = subscription.options.getMethod || 'Get';\r\n    const [topic, type] = subscription[subscription.options.topicProperty].split('::').reverse();\r\n    return connection.stream(method, {\r\n        type,\r\n        [subscription.options.topicProperty]: topic,\r\n        skip: Math.max(0, fromId - 1) || undefined,\r\n        ...(subscription.extraProps || {})\r\n    });\r\n}\r\n\r\nconst getReverse = (connection, subscription, take, skip = 0) => {\r\n    const method = subscription.options.getReverseMethod || 'GetReverse';\r\n    const [topic, type] = subscription[subscription.options.topicProperty].split('::').reverse();\r\n    return connection.stream(method, {\r\n        type,\r\n        [subscription.options.topicProperty]: topic,\r\n        skip: Math.max(0, skip) || undefined,\r\n        take, // No of events to 'Get' from \"latest\"\r\n        ...(subscription.extraProps || {})\r\n    });\r\n}\r\n\r\nconst stream = (connection, subscription, fromId) => {\r\n    const method = subscription.options.streamMethod || 'Subscribe';\r\n    const [topic, type] = subscription[subscription.options.topicProperty].split('::').reverse();\r\n    return connection.stream(method, {\r\n        type,\r\n        [subscription.options.topicProperty]: topic,\r\n        skip: Math.max(0, fromId - 1) || undefined,\r\n        ...(subscription.extraProps || {})\r\n    });\r\n}\r\n\r\nconst publish = (connection, topic, data, options, extraProps = {}) => {\r\n    // NOTE: Publish is not yet implemented in OnePlatform broker...\r\n    const method = options.publishMethod || 'Publish';\r\n    return connection.invoke(method, {\r\n        topic,\r\n        data,\r\n        ...extraProps\r\n    });\r\n}\r\n\r\nexport const Stream = {\r\n    get,\r\n    getReverse,\r\n    stream,\r\n    publish\r\n};\r\n","import * as signalr from '@microsoft/signalr';\r\nimport { initBrokerConnectionFsm } from './BrokerFSM';\r\nimport StreamEventTypes from './StreamEventTypes';\r\nimport StreamErrors from './StreamErrors';\r\nimport { Stream } from './Stream';\r\nimport { promiseTimeout, retryPromiseFunc, noDebug, safeLocalStorageGet } from './StreamUtils';\r\nimport * as SubscriptionsStore from './SubscriptionsStore';\r\n\r\nconst resubscribeDelay = 1;\r\nconst reconnectMaxRetries = 60; // 60 = 1 minute if resubscribeDelay == 1\r\n\r\nlet debug = noDebug;\r\n\r\nlet options = {\r\n    publishMethod: 'Publish',\r\n    brokerUrl: null,\r\n    brokerTransport: 'WebSockets',\r\n    brokerLogLevel: 'none',\r\n}\r\nlet lastSubscribeInvocationId = 0;\r\nlet brokerConnection = null;\r\n\r\n/*******************************************************************************************\r\n ** Function for connecting (and maintaining connection) to broker\r\n *******************************************************************************************/\r\nfunction _connect() {\r\n\r\n    debug.log('_connect: Connecting to broker url: ' + options.brokerUrl);\r\n\r\n    let brokerConnectionOptions;\r\n    switch (options.brokerTransport) {\r\n        case 'None':\r\n        case 'Negotiate':\r\n            brokerConnectionOptions = {};\r\n            break;\r\n        case 'LongPolling':\r\n            brokerConnectionOptions = {\r\n                transport: signalr.HttpTransportType.LongPolling\r\n            }\r\n            break;\r\n        case 'ServerSentEvents':\r\n            brokerConnectionOptions = {\r\n                transport: signalr.HttpTransportType.ServerSentEvents\r\n            }\r\n            break;\r\n        default:\r\n            // Use WebSockets without negotiation by default... Is this ok? Do we ever want WebSockets *WITH* negotiation?\r\n            brokerConnectionOptions = {\r\n                skipNegotiation: true,\r\n                transport: signalr.HttpTransportType.WebSockets\r\n            }\r\n    }\r\n\r\n    // If an accessTokenFactory()-function is supplied with options, use that.\r\n    // ...else if \"access_token\" is supplied as a string, create an accessTokenFactory() returning it\r\n    brokerConnectionOptions.accessTokenFactory = options.accessTokenFactory || options.access_token && (() => options.access_token) || null;\r\n\r\n    const hubConnectionBuilder = new signalr.HubConnectionBuilder()\r\n        .withUrl(options.brokerUrl, brokerConnectionOptions)\r\n        .configureLogging(options.brokerLogLevel)\r\n        .withAutomaticReconnect(options.reconnectRetryPolicy || [0, 500, 3000, 5000, 10000]);\r\n    const connection = hubConnectionBuilder.build();\r\n\r\n    connection.onreconnecting(err => {\r\n        debug.warn('_connect: Broker connection onreconnecting:', err, connection.connectionState, connection.receivedHandshakeResponse);\r\n        typeof options.brokerEventHandlers?.onReconnecting === 'function' && options.brokerEventHandlers.onReconnecting(err);\r\n        unSubscribeAll();\r\n    });\r\n\r\n    connection.onreconnected(async connectionId => {\r\n        debug.warn('_connect: Broker connection onreconnected:', connection.connectionState, connection.receivedHandshakeResponse);\r\n        typeof options.brokerEventHandlers?.onReconnected === 'function' && options.brokerEventHandlers.onReconnected(connectionId);\r\n        await reSubscribeAll();\r\n    });\r\n\r\n    connection.onclose(err => {\r\n        debug.log('_connect: Broker connection closed:', err, connection.connectionState, connection.receivedHandshakeResponse);\r\n        brokerConnection.handle('connection_failed');\r\n    });\r\n\r\n    // Start the connection...\r\n    connection.start().then(() => {\r\n        debug.log('_connect: Broker connection.start() successful:', connection, connection.connectionState, connection.receivedHandshakeResponse);\r\n        brokerConnection.handle('connection_ok', connection);\r\n    }, err => {\r\n        debug.log('_connect: Broker connection.start() error: ', err, connection, connection.connectionState);\r\n        brokerConnection.handle('connection_failed', err);\r\n    });\r\n}\r\n\r\nfunction isConnected() {\r\n    return (brokerConnection && brokerConnection.getState() === 'connected');\r\n}\r\n\r\nfunction isDisconnected() {\r\n    return (!brokerConnection || brokerConnection.getState() === 'disconnected');\r\n}\r\n\r\nfunction connectToBroker() {\r\n    return new Promise(function (resolve, reject) {\r\n        if (isConnected()) {\r\n            // Already connected. Resolve with brokerConnection.connection\r\n            resolve(brokerConnection.getConnection());\r\n        } else {\r\n            // Not connected. Hook up a state transition-listener to monitor brokerConnection state changes...\r\n            const transitionListener = brokerConnection.on('transition', function (data) {\r\n                if (data.toState === 'connected') {\r\n                    // Successfully connected: Resolve and stop listening\r\n                    resolve(brokerConnection.getConnection());\r\n                    transitionListener.off();\r\n                } else if (data.toState === 'disconnected' || data.toState === 'reconnect_wait') {\r\n                    // Transitioned to \"disconnected\": Reject and stop listening\r\n                    reject();\r\n                    transitionListener.off();\r\n                }\r\n            });\r\n\r\n            // And try to connect...\r\n            // Note: The \"connect\"-action will only be effective in states \"disconnected\" and \"reconnect_wait\".\r\n            // In all other states, we should end up in either \"connected\", \"disconnected\" or \"reconnect_wait\" soon anyway\r\n            brokerConnection.handle('connect');\r\n        }\r\n    });\r\n}\r\n\r\nfunction disconnectFromBroker() {\r\n    return new Promise(function (resolve, reject) {\r\n        if (isDisconnected()) {\r\n            // Already disconnected: Resolve\r\n            resolve();\r\n        } else {\r\n            // Not disconnected. Hook up a state transition-listener to monitor brokerConnection state changes...\r\n            const disconnectedTransitionListener = brokerConnection.on('transition', function (data) {\r\n                if (data.toState === 'disconnected') {\r\n                    // Successfully disconnected: Resolve and stop listening\r\n                    resolve();\r\n                    disconnectedTransitionListener.off();\r\n                }\r\n            });\r\n\r\n            // And try to disconnect...\r\n            brokerConnection.handle('disconnect');\r\n        }\r\n    });\r\n}\r\n\r\nfunction reConnectToBroker() {\r\n    return disconnectFromBroker().then(function () {\r\n        return connectToBroker().then(function (connection) {\r\n            reSubscribeAll().then(function (subscriptions) {\r\n                // Don't care about the result of this...\r\n                debug.log('reConnectToBroker: all topics re-subscribed:', subscriptions);\r\n            });\r\n            return Promise.resolve(connection); // Resolve with connection (reSubscribeAll() resolves with subscriptions, and that's probably not what the caller of reConnectToBroker() expects)\r\n        });\r\n    });\r\n}\r\n\r\nfunction getConnection() {\r\n    // Todo: Do we need more checks that connection is in the right state?\r\n    return connectToBroker();\r\n}\r\n\r\n\r\n/*******************************************************************************************\r\n ** Functions for adding and removing streamSubscriptions\r\n *******************************************************************************************/\r\nfunction addStreamSubscription(subscription, timeout) {\r\n    debug.log('addStreamSubscription:', subscription, timeout);\r\n    unsubscribe(subscription);\r\n    SubscriptionsStore.add(subscription);\r\n\r\n    // Subscribe to topic, skip retrying on failures (better to reject and let caller handle it)...\r\n    // If a \"timeout\" is specified, reject if it's taking too long...\r\n    if (timeout) {\r\n        return promiseTimeout(getAndStreamSubscription(subscription), timeout);\r\n    } else {\r\n        return getAndStreamSubscription(subscription);\r\n    }\r\n}\r\n\r\nfunction removeStreamSubscription(subscription) {\r\n    // Can either take a streamSubscription object, or a subscriptionId (returned from StreamSubscription.getSubscriptionId())\r\n    debug.log('removeStreamSubscription:', subscription);\r\n\r\n    if (typeof subscription === 'string') {\r\n        subscription = SubscriptionsStore.findById(subscription);\r\n    }\r\n\r\n    if (subscription) {\r\n        unsubscribe(subscription);\r\n        SubscriptionsStore.remove(subscription);\r\n    }\r\n\r\n    if (SubscriptionsStore.getAll().length < 1) {\r\n        // No more active subscriptions - disconnect from broker\r\n        debug.log('No more subscriptions - disconnecting from broker');\r\n        disconnectFromBroker();\r\n    }\r\n}\r\n\r\nfunction reSubscribeAll() {\r\n    var subscribePromises = [];\r\n    SubscriptionsStore.getAll().forEach(subscription => {\r\n        debug.log('reSubscribeAll: Re-subscribing to subscription: ', subscription);\r\n        subscribePromises.push(getAndStreamSubscription(subscription, true).catch(err => {\r\n            // Catch any errors from _getAndStreamSubscription() to prevent Promise.all() below to \"fail-fast\" on errors...\r\n            debug.warn('reSubscribeAll: Error re-subscribing to subscription: \"' + subscription + '\"', err);\r\n        }));\r\n    });\r\n    return Promise.all(subscribePromises);\r\n}\r\n\r\nfunction unSubscribeAll() {\r\n    // Unsubscribe any active subscription...\r\n    SubscriptionsStore.getAll().forEach(unsubscribe);\r\n}\r\n\r\n\r\n/*******************************************************************************************\r\n ** Functions for getting and subscribing/unsubscribing to any topic\r\n *******************************************************************************************/\r\nfunction getTopic(connection, subscription, fromId) {\r\n    // debug.log('getTopic:', topic, 'from:', fromId);\r\n    return new Promise(function (resolve, reject) {\r\n        const resultArray = [];\r\n        const reverse = (fromId < 0);\r\n        const handlers = {\r\n            next: function (event) {\r\n                // debug.log('getTopic Get stream next:', event);\r\n                resultArray.push(event);\r\n            },\r\n            complete: function () {\r\n                // debug.log('getTopic Get stream complete:', resultArray);\r\n                resolve(reverse ? resultArray.reverse() : resultArray);\r\n            },\r\n            error: function (err) {\r\n                debug.error('getTopic(): Get stream error:', err);\r\n                reject(err);\r\n            }\r\n        };\r\n        if (reverse) {\r\n            // A negative \"fromId\" can be used to fetch events from \"latest\" and back\r\n            Stream.getReverse(connection, subscription, -fromId).subscribe(handlers);\r\n        } else {\r\n            Stream.get(connection, subscription, fromId).subscribe(handlers);\r\n        }\r\n    });\r\n}\r\n\r\nfunction getAndStreamSubscription(subscription, keepRetrying) {\r\n    if (keepRetrying) {\r\n        return retryPromiseFunc(_getAndStreamSubscription.bind(null, subscription), resubscribeDelay * 1000, reconnectMaxRetries, 'abort');\r\n    } else {\r\n        return _getAndStreamSubscription(subscription);\r\n    }\r\n}\r\n\r\nfunction _getAndStreamSubscription(subscription) {\r\n    debug.log('_getAndStreamSubscription:', subscription);\r\n\r\n    return new Promise(function (resolve, reject) {\r\n\r\n        // Unsubscribe if already subscribing...\r\n        unsubscribe(subscription);\r\n\r\n        subscription = SubscriptionsStore.get(subscription);\r\n        if (!subscription) {\r\n            return reject('abort');\t// Reject with reason 'abort' to skip retrying...\r\n        }\r\n\r\n        // Track invocations to _getAndStreamSubscription() by subscription.subscribeInvocationId\r\n        var currentSubscribeInvocationId = ++lastSubscribeInvocationId;\r\n        subscription.subscribeInvocationId = currentSubscribeInvocationId;\r\n        debug.log('_getAndStreamSubscription currentSubscribeInvocationId:', currentSubscribeInvocationId);\r\n\r\n        getConnection().then(function (connection) {\r\n            debug.log('_getAndStreamSubscription: gotConnection:', connection);\r\n\r\n            // Important: Look up the subscription again - it may have changed while waiting for connection!\r\n            subscription = SubscriptionsStore.get(subscription);\r\n            if (subscription.subscribeInvocationId !== currentSubscribeInvocationId) {\r\n                debug.log('_getAndStreamSubscription: A newer subscription has been invoked while waiting for connection - abort this one...');\r\n                return reject('abort');\t// Reject with reason 'abort' to skip retrying...\r\n            }\r\n            if (subscription.subscriberRef) {\r\n                // Stop any existing subscription if exists (should not happen, as we have already called unsubscribe() before connecting, and if we get here we should be in the same invocation)\r\n                unsubscribe(subscription);\r\n            }\r\n\r\n            var getFullTopicState = (subscription.lastReceivedEventId < 0 && (typeof subscription.fromEventId !== 'number' || subscription.fromEventId === subscription.options.topicStartEventId)); // No events received yet, and no \"fromEventId\" specified (different from \"topicStartEventId\") => We want the full topic state!\r\n            var fromEventId = (getFullTopicState ? subscription.options.topicStartEventId : (subscription.lastReceivedEventId >= 0 ? subscription.lastReceivedEventId + 1 : subscription.fromEventId));\r\n            var getTopicPromise;\r\n\r\n            // Decide if we should do invoke 'Get' before start streaming the topic or not.\r\n            // Streaming a large state with many events will be inefficient, so usually when\r\n            // getting a topic from start (full topic history/state), we want to invoke 'Get' first.\r\n            // But when only subscribing for incremental (real-time) events,\r\n            // we want to start streaming directly from last received eventId, without first invoking 'Get' (which causes an extra db lookup in BE)\r\n\r\n            // Merge settings from subscription and global option (settings on the individual subscriptions have priority!)\r\n            const streamingSubscribeOnly = (typeof subscription.streamingSubscribeOnly === 'boolean' ? subscription.streamingSubscribeOnly : options.streamingSubscribeOnly);\r\n            const streamingSubscribeOnResume = (typeof subscription.streamingSubscribeOnResume === 'boolean' ? subscription.streamingSubscribeOnResume : options.streamingSubscribeOnResume);\r\n            if (streamingSubscribeOnly || streamingSubscribeOnResume && !getFullTopicState) {\r\n                // Skip invoking an initial 'Get' for this topic if settings say: streamingSubscribeOnly or streamingSubscribeOnResume and we are not fetching the full topic state\r\n                getTopicPromise = Promise.resolve([]);\r\n            } else {\r\n                debug.log('_getAndStreamSubscription: \\'Get\\': ', subscription, ' from: ', fromEventId, 'invocationId:', currentSubscribeInvocationId);\r\n                getTopicPromise = getTopic(connection, subscription, fromEventId);\r\n            }\r\n\r\n            getTopicPromise.then(function (eventsArray) {\r\n\r\n                // Important: Look up the subscription for this topic again - it may have changed while waiting for connection!\r\n                subscription = SubscriptionsStore.get(subscription);\r\n                if (subscription.subscribeInvocationId !== currentSubscribeInvocationId) {\r\n                    debug.log('_getAndStreamSubscription: A newer subscription to this topic has been invoked while waiting for getTopic() - abort this one...');\r\n                    return reject('abort');\t// Reject with reason 'abort' to skip retrying...\r\n                }\r\n\r\n                if (eventsArray && Array.isArray(eventsArray) && eventsArray.length) {\r\n                    // Handle events from broker 'Get' (if any exists)\r\n                    debug.log('_getAndStreamSubscription: Got topic eventsArray:', eventsArray, 'invocationId:', currentSubscribeInvocationId);\r\n\r\n                    try {\r\n                        // Filter eventsArray to remove duplicates (which is a recoverable error condition)\r\n                        // Or throw a StreamErrors.TOPIC_STREAM_OUT_OF_ORDER if expected event(s) are missing (which is an unrecoverable error)\r\n                        // NOTE: This check assumes that events in eventsArray are in correct time order (even if fetched in reverse, i.e. from \"latest\" using a negative \"fromEventId\")\r\n                        eventsArray = eventsArray.filter(function (event) {\r\n                            const eventId = event[subscription.options.eventIdProperty];\r\n                            if (eventId < subscription.lastReceivedEventId + 1) {\r\n                                debug.error('Error: Broker event id in response-array from \\'Get\\' out of order (old event received). Expected ' + (subscription.lastReceivedEventId + 1) + ', received ' + eventId, event, 'invocationId:', currentSubscribeInvocationId);\r\n                                debug.log('Skipping event...');\r\n                                return false;\t// return false to skip by filter\r\n                            } else if (subscription.lastReceivedEventId != -1 && eventId > subscription.lastReceivedEventId + 1) {\r\n                                debug.error('Error: Broker event id in response-array from \\'Get\\' out of order (gap - event(s) missing). Expected ' + (subscription.lastReceivedEventId + 1) + ', received ' + eventId, event, 'invocationId:', currentSubscribeInvocationId);\r\n                                throw StreamErrors.TOPIC_STREAM_OUT_OF_ORDER;\t// throw exception to abort (unrecoverable error)\r\n                            }\r\n                            subscription.lastReceivedEventId = eventId;\r\n                            return true;\t// All ok, return true to include event\r\n                        });\r\n\r\n                        var receivedAs = (getFullTopicState ? StreamEventTypes.STATE : StreamEventTypes.STREAMED_CHUNK);\r\n                        var preparedEventsData = _prepareEventsData(eventsArray, receivedAs, 'invocationId: ' + currentSubscribeInvocationId);\r\n                        subscription.onDataReceived(preparedEventsData.eventsArray, preparedEventsData.receivedAs);\r\n\r\n                    } catch (e) {\r\n                        if (e === StreamErrors.TOPIC_STREAM_OUT_OF_ORDER) {\r\n                            debug.log('Unrecoverable error: Re-subscribing to topic...');\r\n                        } else {\r\n                            debug.log('Unknown error:', e);\r\n                        }\r\n                        getAndStreamSubscription(subscription).then(resolve, reject); // Try to resubscribe, but skip retrying on failures... Warning: Does not work!!! This loops forever if getAndStreamSubscription() constantly fails!\r\n                        return;\r\n                    }\r\n                    fromEventId = subscription.lastReceivedEventId + 1;\r\n                }\r\n\r\n                try {\r\n                    debug.log('_getAndStreamSubscription: \\'Subscribe\\': ', subscription, ' from id: ', fromEventId, 'invocationId:', currentSubscribeInvocationId);\r\n\r\n                    subscription.subscriberRef = Stream.stream(connection, subscription, fromEventId, options)\r\n                        // subscription.subscriberRef = connection.stream('Subscribe', '1'+topic, fromEventId) // Test invalid topic\r\n                        .subscribe({\r\n                            next: function (event) {\r\n                                // Handle events from broker 'Subscribe'\r\n                                const eventId = event[subscription.options.eventIdProperty];\r\n                                if (eventId < subscription.lastReceivedEventId + 1) {\r\n                                    debug.error('Error: Broker event id in \\'Subscribe\\'-stream out of order (old event received). Expected ' + (subscription.lastReceivedEventId + 1) + ', received ' + eventId, event, 'invocationId:', currentSubscribeInvocationId);\r\n                                    debug.log('Skipping event...');\r\n                                } else if (subscription.lastReceivedEventId != -1 && eventId > subscription.lastReceivedEventId + 1) {\r\n                                    debug.error('Error: Broker event id in \\'Subscribe\\'-stream out of order: (gap - event(s) missing). Expected ' + (subscription.lastReceivedEventId + 1) + ', received ' + eventId, event, 'invocationId:', currentSubscribeInvocationId);\r\n                                    debug.log('Re-subscribing to topic...');\r\n                                    getAndStreamSubscription(subscription, true).catch(function (err) {\r\n                                        debug.log('Error resubscribing to topic (subscribe, stream out of order, gap)', err);\r\n                                    });\r\n                                } else {\r\n                                    const preparedEventsData = _prepareEventsData(event, StreamEventTypes.STREAM, 'invocationId: ' + currentSubscribeInvocationId);\r\n                                    subscription.onDataReceived(preparedEventsData.eventsArray, preparedEventsData.receivedAs);\r\n                                    subscription.lastReceivedEventId = eventId;\r\n                                }\r\n                            },\r\n                            complete: function () {\r\n                                debug.log('Stream completed on \"' + subscription + '\"', 'invocationId:', currentSubscribeInvocationId);\r\n                                subscription.onSubscriptionStreamComplete && subscription.onSubscriptionStreamComplete();\r\n                            },\r\n                            error: function (err) {\r\n                                debug.error('Stream error on \"' + subscription + '\":', err, connection, connection.connectionState, 'invocationId:', currentSubscribeInvocationId);\r\n                                subscription.onSubscriptionError && subscription.onSubscriptionError(err);\r\n                            }\r\n                        });\r\n\r\n                    // After successful subscription: Call onSubscriptionStart()-hook in the subscription, if it exists\r\n                    subscription.onSubscriptionStart && subscription.onSubscriptionStart();\r\n\r\n                    resolve(subscription.subscriberRef);\r\n                } catch (err) {\r\n                    debug.error('Exception subscribing to topic \"' + subscription + '\":', err, 'invocationId:', currentSubscribeInvocationId, connection, connection.connectionState);\r\n                    reject({\r\n                        errorCode: StreamErrors.TOPIC_SUBSCRIBE_ERROR,\r\n                        errorMessage: 'Error subscribing to topic: ' + subscription,\r\n                        err: err\r\n                    });\r\n                }\r\n            }).catch(function (err) {\r\n                // getTopic() rejected or unrecoverable reSubscribe from eventsArray array out of order\r\n                debug.error('_getAndStreamSubscription: Exception from getTopic(\"' + subscription + '\"):', err, 'invocationId:', currentSubscribeInvocationId, connection, connection && connection.connectionState);\r\n                reject({\r\n                    errorCode: StreamErrors.TOPIC_GET_ERROR,\r\n                    errorMessage: 'Error getting topic: ' + subscription,\r\n                    err: err\r\n                });\r\n            });\r\n        }, function (err) {\r\n            debug.error('_getAndStreamSubscription: Exception from getConnection(\"' + subscription + '\"):', err, 'invocationId:', currentSubscribeInvocationId);\r\n            reject({\r\n                errorCode: StreamErrors.BROKER_CONNECT_ERROR,\r\n                errorMessage: 'Could not connect to broker (from _getAndStreamSubscription)',\r\n                err: err\r\n            });\r\n        });\r\n    });\r\n}\r\n\r\nfunction unsubscribe(subscription) {\r\n    subscription = SubscriptionsStore.get(subscription);\r\n\r\n    if (subscription && subscription.subscriberRef) {\r\n\r\n        // Before unsubscribing an active subscription: Call onSubscriptionEnd()-hooks in the subscription, if it exists\r\n        subscription.onSubscriptionEnd && subscription.onSubscriptionEnd();\r\n\r\n        try {\r\n            subscription.subscriberRef.dispose();\r\n            debug.log('topic subscriber disposed');\r\n        } catch (e) {\r\n            debug.log('Exception disposing topic subscriber:', e);\r\n        }\r\n        subscription.subscriberRef = null;\r\n    }\r\n}\r\n\r\nfunction publishTopicWhenConnected(topic, data) {\r\n    return getConnection().then(function (connection) {\r\n        try {\r\n            return Stream.publish(connection, topic, data, options);\r\n        } catch (e) {\r\n            debug.log('Exception in publishTopic: ', e);\r\n            return Promise.reject(e);\r\n        }\r\n    });\r\n}\r\n\r\nfunction publishTopicIfConnected(topic, data) {\r\n    if (!isConnected()) {\r\n        return Promise.reject('Not connected');\r\n    }\r\n    return publishTopicWhenConnected(topic, data);\r\n}\r\n\r\n\r\nfunction getStreamSubscriptions() {\r\n    return SubscriptionsStore.getAll();\r\n}\r\n\r\n\r\n/*******************************************************************************************\r\n ** Util-function to prepare the received events before calling the subscription.onDataReceived() hook\r\n *******************************************************************************************/\r\nfunction _prepareEventsData(events, receivedAs, extraLoggingArg) {\r\n    // Incoming data from broker\r\n    // \"events\" contains the actual event data\r\n    // \t\tIt can be an array (from 'Get' topic, together with \"receivedAs\" = StreamEventTypes.STATE or StreamEventTypes.STREAMED_CHUNK)\r\n    // \t\tor a single event object (together with \"receivedAs\" = StreamEventTypes.STREAM)\r\n    // \"receivedAs\" can be StreamEventTypes.STATE, StreamEventTypes.STREAM or StreamEventTypes.STREAMED_CHUNK depending on how the data was received\r\n    //\t\tStreamEventTypes.STATE means than \"events\" contains the full topic state as an array\r\n    // \t\tStreamEventTypes.STREAMED_CHUNK means than \"events\" contains an events-array, but it does not begin with topic start, so it's not a full state (but rather a \"chunk\" of streamed data in the middle of the topic)\r\n    // \t\tStreamEventTypes.STREAM means than \"events\" contains a single, streamed event object (from connection.stream('Subscribe', ...)\r\n    // \"extraLoggingArg\" (optional) will be added to the debug log\r\n\r\n    if (debug && !debug.debugDisabled) {\r\n        // Assemble debug data (if enabled)...\r\n        const debugData = [];\r\n        if (receivedAs === StreamEventTypes.STREAM) {\r\n            const eventType = (events.data && events.data.type || events.type);\r\n            const messageType = (events.data && events.data.messageType || events.messageType);\r\n            debugData.push('conversationData STREAM-event:', eventType + (eventType === 'conversationMessage' ? ' (' + messageType + ')' : ''));\r\n        } else if (receivedAs === StreamEventTypes.STREAMED_CHUNK) {\r\n            debugData.push('conversationData STREAMED_CHUNK-array:');\r\n        } else if (receivedAs === StreamEventTypes.STATE) {\r\n            debugData.push('conversationData STATE-array:');\r\n        } else {\r\n            debugData.push('conversationData (receivedAs = unknown)):');\r\n        }\r\n        debugData.push(events, extraLoggingArg);\r\n        debug.log.apply(null, debugData);\r\n    }\r\n\r\n    return {\r\n        eventsArray: (receivedAs === StreamEventTypes.STREAM ? [events] : events),\r\n        receivedAs: receivedAs\r\n    }\r\n}\r\n\r\n\r\n/*******************************************************************************************\r\n ** Init function to configure the StreamConnector\r\n *\r\n *   brokerUrl        = URL to CommSrv broker endpoint\r\n *\r\n *   initOptions      = Config object for signalR and related behavior\r\n *       initOptions.brokerTransport (optional, default 'WebSockets'):\r\n *          One of: 'None' | 'Negotiate' | 'WebSockets' | 'LongPolling' | 'ServerSentEvents'\r\n *       initOptions.brokerLogLevel (optional, default 'none'):\r\n *          One of: 'trace' | 'debug' | 'info' | 'warn' | 'error' | 'critical' | 'none'\r\n *       initOptions.streamingSubscribeOnly (optional, default false):\r\n *          If true, topic history/state is not fetched using 'Get' (i.e. everything is streamed using 'Subscribe' only)\r\n *       initOptions.reconnectRetryPolicy (optional, default [0, 500, 3000, 5000, 10000]):\r\n *          An array of retry intervals times in ms, or an object with more controlled retry policy\r\n *          (see \"Automatically reconnect\" on https://learn.microsoft.com/en-us/aspnet/core/signalr/javascript-client?view=aspnetcore-7.0&tabs=visual-studio)\r\n *\r\n *   eventHandlers    = Object containing (optional) event handler hook functions, e.g.\r\n *      {\r\n *    \t\tonConnectionStarted = (connection) => { // Do something on broker connection started...  },\r\n *    \t\tonConnectionFailed  = (error) => { // Do something on broker connection failed... },\r\n *    \t    onDisconnected = () => { // Do something on broker disconnect (after auto reconnect failed... }\r\n *   \t    onReconnecting = (error) => { // Do something on broker auto-reconnecting... }\r\n *  \t    onReconnected = (connectionId) => { // Do something on successful broker auto-reconnect... }\r\n *\t\t}\r\n *\r\n *   debugFns        = Optional object containing debug functions (default will be noop), e.g.:\r\n *      {\r\n * \t\t\tlog: (...args) => { ... },\r\n * \t\t\twarn: (...args) => { ... },\r\n * \t\t\terror: (...args) => { ... },\r\n * \t\t\tinfo: (...args) => { ... },\r\n *\t \t}\r\n *******************************************************************************************/\r\nconst init = async (brokerUrl, initOptions = {}, brokerEventHandlers = {}, debugFns) => {\r\n    const debugOverride = (safeLocalStorageGet('pzl-streaming-debug') === 'true');\r\n    debug = debugOverride && console || debugFns || noDebug;\r\n    const brokerLogLevelOverride = safeLocalStorageGet('pzl-broker-log-level') || debugOverride && 'info' || null;\r\n\r\n    if (!brokerConnection) {\r\n        brokerConnection = initBrokerConnectionFsm({\r\n            _connect,\r\n            reSubscribeAll,\r\n            unSubscribeAll\r\n        }, brokerEventHandlers, debug);\r\n    }\r\n\r\n    initOptions.brokerTransport = initOptions.brokerTransport || 'WebSockets';\r\n    initOptions.brokerLogLevel = brokerLogLevelOverride || initOptions.brokerLogLevel || 'none';\r\n    initOptions.streamingSubscribeOnly = !!initOptions.streamingSubscribeOnly || false;     // default false\r\n    initOptions.streamingSubscribeOnResume = (initOptions.streamingSubscribeOnResume === false ? false : true); // default true\r\n    initOptions.access_token = initOptions.access_token || await initOptions.accessTokenFactory?.() || null;\r\n\r\n    if (brokerUrl && brokerUrl !== options.brokerUrl ||\r\n        initOptions.access_token !== options.access_token ||\r\n        initOptions.brokerTransport !== options.brokerTransport ||\r\n        initOptions.brokerLogLevel !== options.brokerLogLevel)\r\n    {\r\n        options = {\r\n            ...options,\r\n            brokerUrl,\r\n            ...initOptions,\r\n            brokerEventHandlers\r\n        }\r\n\r\n        brokerConnection.setEventCallbacks(brokerEventHandlers);\r\n\r\n        debug.log('Initializing StreamConnector');\r\n        debug.log('SignalR client lib version:', signalr.VERSION);\r\n\r\n        if (!isDisconnected()) {\r\n            // If we have an active connection: Re-connect to broker with the new brokerUrl, access_token or changed options...\r\n            try {\r\n                const connection = await reConnectToBroker();\r\n                debug.log('StreamConnector: broker config changed: Successfully re-connected to broker', connection);\r\n                return 're-connected';\r\n            } catch (err) {\r\n                debug.error('StreamConnector: broker config changed: Error re-connecting to broker', err);\r\n                throw ('Error re-connecting');\r\n            }\r\n        } else {\r\n            return 'disconnected';\r\n        }\r\n    } else {\r\n        return 'no change';\r\n    }\r\n};\r\n\r\nconst updateAccessToken = async (new_access_token) => {\r\n    // Call when access_token has changed.\r\n    // Will re-connect broker and re-subscribe if connected and token has changed\r\n    // (just like on init() above, but will not require re-register options and handlers)\r\n    // If \"new_access_token\" is empty/false/null, options.accessTokenFactory?.() will be called instead\r\n    // I.e. if an accessTokenFactory()-function has been supplied in options,\r\n    // this function can be called without options to force a token re-check using accessTokenFactory()\r\n\r\n    if (!brokerConnection) {\r\n        throw new Error('StreamConnection not initialized. This function can only be called after init')\r\n    }\r\n\r\n    new_access_token = new_access_token || await options.accessTokenFactory?.() || null;\r\n\r\n    if (new_access_token !== options.access_token) {\r\n        options.access_token = new_access_token;\r\n        debug.log('StreamConnector.updateAccessToken(): new access_token');\r\n        if (!isDisconnected()) {\r\n            // If we have an active connection: Re-connect to broker with the new brokerUrl, access_token or changed options...\r\n            try {\r\n                const connection = await reConnectToBroker();\r\n                debug.log('StreamConnector.updateAccessToken(): Successfully re-connected to broker', connection);\r\n                return 're-connected';\r\n            } catch (err) {\r\n                debug.error('StreamConnector.updateAccessToken(): Error re-connecting to broker', err);\r\n                throw ('Error re-connecting');\r\n            }\r\n        }\r\n    } else {\r\n        debug.log('StreamConnector.updateAccessToken(): access_token not changed => Do nothing');\r\n    }\r\n};\r\n\r\nexport default {\r\n    _signalr: signalr,\t// Expose the signalr lib  - mainly for debugging...\r\n    init,\r\n    updateAccessToken,\r\n    getStreamSubscriptions,\r\n    addStreamSubscription,\r\n    removeStreamSubscription,\r\n    publishTopicIfConnected\r\n}\r\n","export default {\r\n    BROKER_DISCONNECTED: 0,\r\n    BROKER_CONNECT_ERROR: 1,\r\n    BROKER_RECONNECT_ATTEMPT_ERROR: 2,\r\n    BROKER_RECONNECT_FATAL_ERROR: 3,\r\n    BROKER_INVALID_CONNECTION_ERROR: 4,\r\n    TOPIC_GET_ERROR: 5,\r\n    TOPIC_SUBSCRIBE_ERROR: 6,\r\n    TOPIC_STREAM_OUT_OF_ORDER: 7\r\n}\r\n","export default {\r\n    STATE: 'state',\r\n    STREAM: 'stream',\r\n    STREAMED_CHUNK: 'chunk'\r\n}\r\n","// Simple module to create a new \"subscription\"-object to subscribe to events from streaming broker (via SignalR)\r\n// It will add and init correct default properties for usage by StreamConnector\r\n// Add overridden and/or custom props as the arg to Subscription constructor\r\n\r\nimport { mergeDeep } from './StreamUtils';\r\n\r\nclass DefaultSubscription {\r\n\t// options added to support broker v3\r\n\tconstructor() {\r\n\t\tthis.options = {\r\n\t\t\ttopicProperty: 'topic',\r\n\t\t\ttopicStartEventId: 1,\r\n\t\t\teventIdProperty: 'id',\r\n\t\t\tgetMethod: 'Get',\r\n\t\t\tstreamMethod: 'Subscribe',\r\n\t\t};\r\n\t\tthis.topic = '';\r\n\t\tthis.fromEventId = null;\r\n\t\tthis.subscribeInvocationId = -1;\r\n\t\tthis.subscriberRef = null;\r\n\t\tthis.lastReceivedEventId = -1;\r\n\t\tthis.onDataReceived = function () {};\r\n\t\tthis.onSubscriptionStart = null;\r\n\t\tthis.onSubscriptionEnd = null;\r\n\t\tthis.getSubscriptionId = function () {\r\n\t\t\t// Should generate a string that uniquely identifies this subscription/stream\r\n\t\t\t// Note: Two subscriptions for the same stream should result in the same \"id\" so we can compare and identify the same stream!!\r\n\t\t\treturn this[this.options.topicProperty];\r\n\t\t};\r\n\t\tthis.toString = function () {\r\n\t\t\treturn this.getSubscriptionId();\r\n\t\t}\r\n\t}\r\n}\r\n\r\nclass StreamSubscription extends DefaultSubscription {\r\n\tconstructor(props) {\r\n\t\tsuper();\r\n\t\tfor (const [prop, value] of Object.entries(props)) {\r\n\t\t\tthis[prop] = mergeDeep(this[prop], value); // Deep merge each prop...\r\n\t\t}\r\n\t}\r\n}\r\n\r\nexport default StreamSubscription;\r\n","const wait = (ms) => {\r\n    return new Promise(function (r) {\r\n        return setTimeout(r, ms)\r\n    });\r\n}\r\n\r\nexport const retryPromiseFunc = (promisedFunction, delay, maxRetries, abortReason) => {\r\n    // This function retries \"promisedFunction\" (a function which is expected to return a Promise) until it's reloved, or until retried \"maxRetries\" number of times or until rejected with reason == \"abortReason\"...\r\n    return new Promise(function (resolve, reject) {\r\n        return promisedFunction()\r\n            .then(resolve)\r\n            .catch(function (reason) {\r\n                if (maxRetries - 1 > 0 && reason !== abortReason) {\r\n                    return wait(delay)\r\n                        .then(retryPromiseFunc.bind(null, promisedFunction, delay, maxRetries - 1, abortReason))\r\n                        .then(resolve)\r\n                        .catch(reject);\r\n                }\r\n                return reject(reason);\r\n            });\r\n    });\r\n}\r\n\r\nexport const promiseTimeout = (promise, ms) => {\r\n    // Create a promise that rejects in <ms> milliseconds\r\n    // Returns a race between our timeout and the passed in promise\r\n    return Promise.race([\r\n        promise,\r\n        new Promise(function (resolve, reject) {\r\n            wait(ms).then(reject.bind(null, new Error('timeout')))\r\n        })\r\n    ])\r\n}\r\n\r\nexport const mergeDeep = (...objects) => {\r\n    // Deep merge from: https://stackoverflow.com/a/48218209 (modified for unique arrays as suggested in comments)\r\n    // Also modified to handle primitives and differing types\r\n    const isObject = obj => obj && typeof obj === 'object';\r\n    return objects.reduce((prev = {}, obj) => {\r\n        if (isObject(obj)) {\r\n            Object.keys(obj).forEach(key => {\r\n                const pVal = prev[key];\r\n                const oVal = obj[key];\r\n                if (Array.isArray(oVal) && Array.isArray(pVal)) {\r\n                    // Merging arrays is a bit tricky: Concatenate or only keep unique elements?\r\n                    // prev[key] = pVal.concat(...oVal);\r\n                    prev[key] = [...new Set([...oVal, ...pVal])];\r\n                } else if (isObject(oVal) && isObject(pVal)) {\r\n                    prev[key] = mergeDeep(pVal, oVal);\r\n                } else {\r\n                    // Values are primitives or of different types\r\n                    if (isObject(pVal)) {\r\n                        prev[key] = oVal;\r\n                    } else {\r\n                        // prev[key] not an object! => Simply overwrite prev!\r\n                        prev = obj;\r\n                    }\r\n                }\r\n            });\r\n            return prev;\r\n        } else {\r\n            return obj;\r\n        }\r\n    }, {});\r\n};\r\n\r\nexport const safeLocalStorageGet = key => {\r\n    try {\r\n        if (typeof localStorage !== 'undefined') {\r\n            return localStorage.getItem(key);\r\n        }\r\n    } catch (e) {\r\n        // Node or sandboxed env โ ignore\r\n    }\r\n}\r\n\r\nexport const noDebug = {\r\n    debugDisabled: true,\r\n    log: () => {},\r\n    warn: () => {},\r\n    error: () => {},\r\n    info: () => {}\r\n};\r\n","let subscriptions = [];\r\n\r\nexport const findById = subscriptionId => {\r\n    return subscriptionId && subscriptions.find(s => s.getSubscriptionId() === subscriptionId) || null;\r\n}\r\nexport const exists = subscription => {\r\n    return !!get(subscription);\r\n}\r\n\r\nexport const add = subscription => {\r\n    remove(get(subscription));\r\n    subscriptions.push(subscription);\r\n}\r\n\r\nexport const get = subscription => {\r\n    return subscription && subscriptions.find(s => s.getSubscriptionId() === subscription.getSubscriptionId()) || null;\r\n}\r\nexport const getAll = () => {\r\n    return subscriptions;\r\n}\r\n\r\nexport const remove = subscription => {\r\n    if (subscription && typeof subscription === 'object') {\r\n        subscriptions = subscriptions.filter(s => s.getSubscriptionId() !== subscription.getSubscriptionId());\r\n        return true;\r\n    }\r\n    return false;\r\n}\r\nexport const removeAll = () => {\r\n    subscriptions = [];\r\n}\r\n\r\n","/*\n * Stately.js: A JavaScript based finite-state machine (FSM) engine.\n *\n * Copyright (c) 2012 Florian Schรคfer (florian.schaefer@gmail.com)\n * Released under MIT license.\n *\n * Version: 2.0.0\n *\n */\n(function (root, factory) {\n    if (typeof exports === 'object') {\n        module.exports = factory();\n    } else if (typeof define === 'function' && define.amd) {\n        define(factory);\n    } else {\n        root.Stately = factory();\n    }\n})(this, function () {\n\n    var\n        toString = Object.prototype.toString,\n\n        InvalidStateError = (function () {\n\n            function InvalidStateError(message) {\n\n                this.name = 'InvalidStateError';\n\n                this.message = message;\n            }\n\n            InvalidStateError.prototype = new Error();\n\n            InvalidStateError.prototype.constructor = InvalidStateError;\n\n            return InvalidStateError;\n        })();\n\n    function Stately(statesObject, initialStateName) {\n\n        if (typeof statesObject === 'function') {\n\n            statesObject = statesObject();\n        }\n\n        if (toString.call(statesObject) !== '[object Object]') {\n\n            throw new InvalidStateError('Stately.js: Invalid states object: `' + statesObject + '`.');\n        }\n\n        function resolveSpecialEventFn(stateName, fnName) {\n\n            for (var property in stateStore[stateName]) {\n\n                if (stateStore[stateName].hasOwnProperty(property)) {\n\n                    if (property.toLowerCase() === fnName.toLowerCase()) {\n\n                        return stateStore[stateName][property];\n\n                    }\n                }\n            }\n        }\n\n        var\n            currentState,\n\n            stateStore = {\n\n                getMachineState: function getMachineState() {\n\n                    return currentState.name;\n                },\n\n                setMachineState: function setMachineState(nextState /*, eventName */) {\n\n                    var\n                        eventName = arguments[1],\n\n                        onEnterState,\n\n                        onLeaveState,\n\n                        lastState = currentState;\n\n                    if (typeof nextState === 'string') {\n\n                        nextState = stateStore[nextState];\n\n                    }\n\n                    if (!nextState || !nextState.name || !stateStore[nextState.name]) {\n\n                        throw new InvalidStateError('Stately.js: Transitioned into invalid state: `' + setMachineState.caller + '`.');\n                    }\n\n                    currentState = nextState;\n\n                    onLeaveState = resolveSpecialEventFn(lastState.name, \"onLeave\");\n\n                    if (onLeaveState && typeof onLeaveState === 'function') {\n\n                        onLeaveState.call(stateStore, eventName, lastState.name, currentState.name);\n                    }\n\n                    onEnterState = resolveSpecialEventFn(currentState.name, \"onEnter\");\n\n                    if (onEnterState && typeof onEnterState === 'function') {\n\n                        onEnterState.call(stateStore, eventName, lastState.name, nextState.name);\n                    }\n\n                    return this;\n                },\n\n                getMachineEvents: function getMachineEvents() {\n\n                    var events = [];\n\n                    for (var property in currentState) {\n\n                        if (currentState.hasOwnProperty(property)) {\n\n                            if (typeof currentState[property] === 'function') {\n\n                                events.push(property);\n                            }\n                        }\n                    }\n\n                    return events;\n                }\n\n            },\n\n            stateMachine = {\n\n                getMachineState: stateStore.getMachineState,\n\n                getMachineEvents: stateStore.getMachineEvents\n\n            },\n\n            transition = function transition(stateName, eventName, nextEvent) {\n\n                return function event() {\n\n                    var\n                        onBeforeEvent,\n\n                        onAfterEvent,\n\n                        nextState,\n\n                        eventValue = stateMachine;\n\n                    if (stateStore[stateName] !== currentState) {\n\n                        if (nextEvent) {\n\n                            eventValue = nextEvent.apply(stateStore, arguments);\n                        }\n\n                        return eventValue;\n                    }\n\n                    onBeforeEvent = resolveSpecialEventFn(currentState.name, \"onBefore\" + eventName);\n\n                    if (onBeforeEvent && typeof onBeforeEvent === 'function') {\n\n                        onBeforeEvent.call(stateStore, eventName, currentState.name, currentState.name);\n                    }\n\n                    eventValue = stateStore[stateName][eventName].apply(stateStore, arguments);\n\n                    if (typeof eventValue === 'undefined') {\n\n                        nextState = currentState;\n\n                        eventValue = stateMachine;\n\n                    } else if (typeof eventValue === 'string') {\n\n                        nextState = stateStore[eventValue];\n\n                        eventValue = stateMachine;\n\n                    } else if (toString.call(eventValue) === '[object Object]') {\n\n                        nextState = (eventValue === stateStore ? currentState : eventValue);\n\n                        eventValue = stateMachine;\n\n                    } else if (toString.call(eventValue) === '[object Array]' && eventValue.length >= 1) {\n\n                        if (typeof eventValue[0] === 'string') {\n\n                            nextState = stateStore[eventValue[0]];\n\n                        } else {\n\n                            nextState = eventValue[0];\n\n                        }\n\n                        eventValue = eventValue[1];\n                    }\n\n                    onAfterEvent = resolveSpecialEventFn(currentState.name, \"onAfter\" + eventName);\n\n                    if (onAfterEvent && typeof onAfterEvent === 'function') {\n\n                        onAfterEvent.call(stateStore, eventName, currentState.name, nextState.name);\n                    }\n\n                    stateStore.setMachineState(nextState, eventName);\n\n                    return eventValue;\n                };\n            };\n\n        for (var stateName in statesObject) {\n\n            if (statesObject.hasOwnProperty(stateName)) {\n\n                stateStore[stateName] = statesObject[stateName];\n\n                for (var eventName in stateStore[stateName]) {\n\n                    if (stateStore[stateName].hasOwnProperty(eventName)) {\n\n                        if (typeof stateStore[stateName][eventName] === 'string') {\n\n                            stateStore[stateName][eventName] = (function (stateName) {\n\n                                return function event() {\n\n                                    return this[stateName];\n                                };\n\n                            })(stateStore[stateName][eventName]);\n                        }\n\n                        if (\n                            typeof stateStore[stateName][eventName] === 'function'\n                                && !/^onEnter$/i.test(eventName)\n                                && !/^onLeave$/i.test(eventName)\n                                && !/^onBefore/i.test(eventName)\n                                && !/^onAfter/i.test(eventName)\n                        ) {\n\n                            stateMachine[eventName] = transition(stateName, eventName, stateMachine[eventName]);\n                        }\n                    }\n                }\n\n                stateStore[stateName].name = stateName;\n\n                if (!currentState) {\n\n                    currentState = stateStore[stateName];\n                }\n            }\n        }\n\n        if (typeof stateStore[initialStateName] !== 'undefined') {\n            currentState = stateStore[initialStateName];\n        }\n\n        if (!currentState) {\n\n            throw new InvalidStateError('Stately.js: Invalid initial state.');\n        }\n\n        return stateMachine;\n    }\n\n    Stately.machine = function machine(statesObject, initialStateName) {\n        return new Stately(statesObject, initialStateName);\n    };\n\n    Stately.InvalidStateError = InvalidStateError;\n\n    return Stately;\n\n});\n","module.exports = __WEBPACK_EXTERNAL_MODULE__microsoft_signalr_e3fad43b__;","import toPropertyKey from \"./toPropertyKey.js\";\nfunction _defineProperty(e, r, t) {\n  return (r = toPropertyKey(r)) in e ? Object.defineProperty(e, r, {\n    value: t,\n    enumerable: !0,\n    configurable: !0,\n    writable: !0\n  }) : e[r] = t, e;\n}\nexport { _defineProperty as default };","import _typeof from \"./typeof.js\";\nfunction toPrimitive(t, r) {\n  if (\"object\" != _typeof(t) || !t) return t;\n  var e = t[Symbol.toPrimitive];\n  if (void 0 !== e) {\n    var i = e.call(t, r || \"default\");\n    if (\"object\" != _typeof(i)) return i;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return (\"string\" === r ? String : Number)(t);\n}\nexport { toPrimitive as default };","import _typeof from \"./typeof.js\";\nimport toPrimitive from \"./toPrimitive.js\";\nfunction toPropertyKey(t) {\n  var i = toPrimitive(t, \"string\");\n  return \"symbol\" == _typeof(i) ? i : i + \"\";\n}\nexport { toPropertyKey as default };","function _typeof(o) {\n  \"@babel/helpers - typeof\";\n\n  return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) {\n    return typeof o;\n  } : function (o) {\n    return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o;\n  }, _typeof(o);\n}\nexport { _typeof as default };","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Check if module exists (development only)\n\tif (__webpack_modules__[moduleId] === undefined) {\n\t\tvar e = new Error(\"Cannot find module '\" + moduleId + \"'\");\n\t\te.code = 'MODULE_NOT_FOUND';\n\t\tthrow e;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// getDefaultExport function for compatibility with non-harmony modules\n__webpack_require__.n = (module) => {\n\tvar getter = module && module.__esModule ?\n\t\t() => (module['default']) :\n\t\t() => (module);\n\t__webpack_require__.d(getter, { a: getter });\n\treturn getter;\n};","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","import StreamConnector from './StreamConnector';\r\nimport StreamEventTypes from './StreamEventTypes';\r\nimport StreamErrors from './StreamErrors';\r\nimport StreamSubscription from './StreamSubscription';\r\n\r\nexport {\r\n    StreamEventTypes,\t// Is this needed? Or could it be required/imported directly?\r\n    StreamErrors,\t// Is this needed? Or could it be required/imported directly?\r\n    StreamConnector,\r\n    StreamSubscription\r\n}\r\n"],"names":["Stately","noDebug","reconnectRetryDelay","reconnectMaxRetries","initBrokerConnectionFsm","externals","brokerEventCallbacks","arguments","length","undefined","debug","log","fsm_state","fsm","connection","reconnectCounter","eventListeners","handle","action","_len","args","Array","_key","on","eventName","callback","concat","off","filter","cb","emitEvent","_len2","_key2","forEach","call","bind","_this","fsmStates","disconnected","_onEnter","connect","connecting","_connect","connection_ok","connected","connection_failed","err","disconnect","disconnecting","prevState","_fsm_state$brokerEven","reSubscribeAll","onConnectionStarted","_fsm_state$brokerEven2","onConnectionFailed","reconnect_wait","schedule_reconnect","clearTimeout","reconnectTimer","setTimeout","reconnecting","reconnection_failed","_onExit","_fsm_state$brokerEven3","unSubscribeAll","stop","catch","finally","disconnect_ok","_fsm_state$brokerEven4","onDisconnected","Object","keys","state","___onEnter","onEnter","newState","_onEnterAction","fromState","toState","setMachineState","getState","getMachineState","getConnection","setEventCallbacks","get","subscription","fromId","method","options","getMethod","topic","type","topicProperty","split","reverse","stream","_objectSpread","skip","Math","max","extraProps","getReverse","take","getReverseMethod","streamMethod","publish","data","publishMethod","invoke","Stream","signalr","StreamEventTypes","StreamErrors","promiseTimeout","retryPromiseFunc","safeLocalStorageGet","SubscriptionsStore","resubscribeDelay","brokerUrl","brokerTransport","brokerLogLevel","lastSubscribeInvocationId","brokerConnection","brokerConnectionOptions","transport","HttpTransportType","LongPolling","ServerSentEvents","skipNegotiation","WebSockets","accessTokenFactory","access_token","hubConnectionBuilder","HubConnectionBuilder","withUrl","configureLogging","withAutomaticReconnect","reconnectRetryPolicy","build","onreconnecting","_options$brokerEventH","warn","connectionState","receivedHandshakeResponse","brokerEventHandlers","onReconnecting","onreconnected","connectionId","_options$brokerEventH2","onReconnected","onclose","start","then","isConnected","isDisconnected","connectToBroker","Promise","resolve","reject","transitionListener","disconnectFromBroker","disconnectedTransitionListener","reConnectToBroker","subscriptions","addStreamSubscription","timeout","unsubscribe","add","getAndStreamSubscription","removeStreamSubscription","findById","remove","getAll","subscribePromises","push","all","getTopic","resultArray","handlers","next","event","complete","error","subscribe","keepRetrying","_getAndStreamSubscription","currentSubscribeInvocationId","subscribeInvocationId","subscriberRef","getFullTopicState","lastReceivedEventId","fromEventId","topicStartEventId","getTopicPromise","streamingSubscribeOnly","streamingSubscribeOnResume","eventsArray","isArray","eventId","eventIdProperty","TOPIC_STREAM_OUT_OF_ORDER","receivedAs","STATE","STREAMED_CHUNK","preparedEventsData","_prepareEventsData","onDataReceived","e","STREAM","onSubscriptionStreamComplete","onSubscriptionError","onSubscriptionStart","errorCode","TOPIC_SUBSCRIBE_ERROR","errorMessage","TOPIC_GET_ERROR","BROKER_CONNECT_ERROR","onSubscriptionEnd","dispose","publishTopicWhenConnected","publishTopicIfConnected","getStreamSubscriptions","events","extraLoggingArg","debugDisabled","debugData","eventType","messageType","apply","init","_initOptions$accessTo","initOptions","debugFns","debugOverride","console","brokerLogLevelOverride","VERSION","updateAccessToken","new_access_token","_options$accessTokenF","_options","Error","_signalr","BROKER_DISCONNECTED","BROKER_RECONNECT_ATTEMPT_ERROR","BROKER_RECONNECT_FATAL_ERROR","BROKER_INVALID_CONNECTION_ERROR","mergeDeep","DefaultSubscription","constructor","getSubscriptionId","toString","StreamSubscription","props","prop","value","entries","wait","ms","r","promisedFunction","delay","maxRetries","abortReason","reason","promise","race","isObject","obj","objects","reduce","prev","key","pVal","oVal","Set","_mergeDeep","localStorage","getItem","info","subscriptionId","find","s","exists","removeAll","StreamConnector"],"sourceRoot":""}